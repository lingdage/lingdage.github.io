<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AsyncTask 源码分析]]></title>
    <url>%2Fposts%2F96014b68.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 1framework/base/core/java/andorid/os/AsyncTask.java 简介之前讲解了能够在后台工作线程中执行耗时任务的IntentService框架，在这里我们继续学习Android提供的另外一个异步执行任务的框架AsyncTask，它和IntentService既有相似点也有不同点，其相似之处在于都能在新的线程中执行耗时任务防止阻塞主线程，不同之处在于AsyncTask能够追踪任务的执行过程和结果并在主线程中显示出来。 知识储备LinkedBlockingQueue 链阻塞队列阻塞队列BlockingQueue被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。LinkedBlockingQueue 类实现了BlockingQueue 接口。LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 ArrayDeque数组队列 ArrayDeque的特点 大小自增长的队列 内部使用数组存储数据 线程不安全 内部数组长度为8、16、32….. 2的n次方 头指针head从内部数组的末尾开始，尾指针tail从0开始，在头部插入数据时，head减一，在尾部插入数据时，tail加一。当head==tail时说明数组的容量满足不了当前的情况，此时需要扩大容量为原来的二倍。 ExecutorService 执行器服务java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。 ExecutorService 简单实现 123456789ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println("Asynchronous task"); &#125; &#125;); executorService.shutdown(); 首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService。这里创建了一个十个线程执行任务的线程池。然后，将一个 Runnable 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。 ThreadPoolExecutor 线程池执行者ava.util.concurrent.ThreadPoolExecutor 是 ExecutorService 接口的一个实现。ThreadPoolExecutor 使用其内部池中的线程执行给定任务(Callable 或者 Runnable)。 构造方法： 12345678910111213141516171819202122//构造方法public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 下面看看几个参数的含义及作用 corePoolSize — 核心线程数，即允许闲置的线程数目 maximumPoolSize — 最大线程数，即这个线程池的容量 keepAliveTime — 非核心线程的闲置存活时间 unit — 上一个参数的单位 workQueue — 任务队列（阻塞队列） threadFacotry — 线程创建工厂 handler — 当线程池或者任务队列容量已满时用于 reject Callable&amp;&amp;Future 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 1234567891011121314public interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 简单来讲，Callable接口等价于Runable，call()等价于run()，区别在于它是有返回值的。我们可以通过ExecutorService调用Callable，执行后将返回Future对象，比如:Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable); 1234567891011121314 public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future接口两个方法着重理解下，一是cancel(boolean mayInterruptIfRunning)，顾名思义就是终止线程，二是get()，它会阻塞线程，直到Callable的call()返回对象，并以此作为返回值。至于mayInterruptIfRunning这个boolean值的含义，大家看看FutureTask中相应的源码就直到了，其实只是多了thread.interrupt()的逻辑而已。结合Callable的代码，Future的使用如下： 123Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable);//阻塞线程，等待Callable.call()的返回值String result = future.get(); FutureTask123456789public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647从`FutureTask`的继承关系来看，它既是`Runable`也是Future，所以我们可以把当做Runable来使用，同时它也具备Future的能力，可以终止线程，可以阻塞线程，等待Callable的执行，并获取返回值。另外要注意的是，它的构造函数是public FutureTask(Callable&lt;V&gt; callable)，因此实例化FutureTask时需要Callable对象作为参数。## AsyncTask 的使用方式### 使用示例```javaprivate class DownloadFileTask extends AsyncTask&lt;String, Integer, Long&gt; &#123; @Override public void onPreExecute() &#123; mProgress.setVisibility(View.VISIBLE); mProgress.setMax(100); mProgress.setProgress(0); &#125; @Override public Long doInBackground(String... uris) &#123; int count = uris.length; long size = 0; for (int i = 1; i &lt;= count; i ++) &#123; try &#123; // 休眠5秒模拟下载过程 Thread.sleep(5 * 1000); // 假设每个下载文件的大小为（序号*100） size += i * 100; // 发布进度更新 publishProgress( (100* i )/count); &#125; catch (InterruptedException ie) &#123; ie.printStackTrace(); &#125; &#125; return size; &#125; @Override public void onProgressUpdate(Integer... progress) &#123; mProgress.setProgress(progress[0]); &#125; @Override public void onPostExecute(Long result) &#123; mText.setText(String.valueOf(result)); &#125;&#125; 通过这段代码可以看到要使用AsyncTask实行异步任务是非常容易的，只需要做两件事: 确定在整个处理过程中需要的参数类型，包括Params,Progress和Result,分别对应着输入参数、进度参数和结果参数。 实现必要的回调方法，其中必须是实现的是doInBackground，耗时任务正是在这里进行处理的，可以想象doInBackground一定是在子线程里进行的；其他可选实现方法包括onPreExecute,onProgressUpdate和onPostExecute，这些在示例中都参与了UI的更新，所以一定是在主线程中进行的。 参数介绍public abstract class AsyncTask&lt;Params, Progress, Result&gt; { ... } 可以发现AsyncTask中使用的都是泛型参数，在使用过程中要根据需求选择合适的参数类型，在示例中使用的参数类型分别是String,Integer和Long,如果某一个参数是不需要的，可以用Void来表示，下面通过一个表格来对每个参数进行说明： 参数声明 含义 作用 产生处/调用处 注意事项 Params 输入参数 任务开始执行时客户端发送开始参数 execute()中发送，在doInBackground()中调用。 可变参类型 Progress 过程参数 任务后台执行过程中服务端发布的当前执行进度 在doInBackground()中产生并通过publishProgess()发送，在onProgressUpdate()调用。 可变参类型 Result 结果参数 任务执行完成后服务端发送的执行结果 在doInBackground()中产生并在onPostExecute()中调用。 参数类型不能是基本数据类型，要使用对应的封装类型，例如示例的Progress和Result参数使用的Integer和Long而不是int和long。 回调接口 回调方法 运行线程 作用 执行顺序 是否需要重新实现 onPreExecute 主线程 在开始执行后台任务前进行初始化 首先开始执行 可选 doInBackground 后台线程 执行后台耗时任务完成后返回结果 onPreExecute 执行完成后执行 必须实现 publishProgress 后台线程 在执行任务过程中发布执行进度 在 doInBackground 中执行 无须实现，直接调用。 onProgressUpdate 主线程 接收进度并在主线程处理 在 publishProgress 之后执行 可选 onPostExecute 主线程 接收执行结果并在主线程处理 在 doInBackground 执行完成后执行 可选 AsyncTask 源码分析回到我们一开始提到的那个示例代码，当我们定义了好自己的AsyncTask之后，要开始运行这个任务时非常简单，只需要一行代码： new DownloadFileTask().execute(url1, url2, url3); 我们就以这个为切入点来分析，首先看下execute()做了什么 首先，new DownloadFileTask() ，执行DownloadFileTask的构造方法，因此必然会执行DownloadFileTask的父类AsyncTask的构造方法，也就是 AsyncTask() ： 123456/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */public AsyncTask() &#123; this((Looper) null);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; //设置当前任务已被执行 mTaskInvoked.set(true); Result result = null; try &#123; //设置线程执行的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 构造方法的工作很简单，就是完成了mWorker 和 mFuture 的初始化工作，也就是Callable和Future 的初始化，并关联他们，让mFuture 可以获取mWorker 的执行结果，或者停止mWorker 的执行。 这里主要由两个方法call()和done()，总的来说当mFuture 开始被执行的时候，call() 就会执行，当这个任务执行完毕后done()方法就会执行。 那么这个mFuture 什么 时候会被执行呢？继续往下看execute(Params... params) 1234@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 12345678910111213141516171819202122232425@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; // 回调方法中首先被调用的方法，由于"execute()"是在主线程中执行的, // 目前为止也没有进行线程的切换，所以"onPreExecute"也是在主线程中执行的。 onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 到这里就很清楚了，mStatus 默认状态为PENDING，因此任务开始执行后首先将其状态改为RUNNING；同时从异常判断我们也可以看出一个AsyncTask的execute方法不能同时执行两次。 接下来，onPreExecute()，我们是在onCreate 中开启了AsyncTask的任务，因此这个时候，依旧属于主线程，onPreExecute()方法也会工作在主线程，我们可以在这个方法中执行一些预备操作，初始相关内容。 mWorker，前面已经说过他就是实现了Callable接口，并添加了一个参数属性，在这里我们把executor中传入的参数赋给了这个属性。exec=sDefaultExecutor=SerialExecutor ，这里任务就开始真正的执行了；按照之前所说就会开始执行mFuture这个任务，因此就会开始执行mWorker的call方法。 123456789101112131415161718192021&gt; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;&gt; public Result call() throws Exception &#123;&gt; //设置当前任务已被执行&gt; mTaskInvoked.set(true);&gt; Result result = null;&gt; try &#123;&gt; //设置线程执行的优先级&gt; &gt; &gt; &gt;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);&gt; //noinspection unchecked&gt; result = doInBackground(mParams);&gt; Binder.flushPendingCommands();&gt; &#125; catch (Throwable tr) &#123;&gt; mCancelled.set(true);&gt; throw tr;&gt; &#125; finally &#123;&gt; postResult(result);&gt; &#125;&gt; return result;&gt; &#125;&gt; &#125;;&gt; 到这里，我们终于看到了熟悉的 doInBackground，这是我们必须实现的一个方法，在其中完成耗时操作，并返回结果。由于已经设置了Process的优先级，因此这个方法会处于后台进程。在 doInBackground 里，我们还可以返回当前执行进度 12345678910111213141516171819&gt; @Override&gt; public Long doInBackground(String... uris) &#123;&gt; int count = uris.length;&gt; long size = 0;&gt; for (int i = 1; i &lt;= count; i ++) &#123;&gt; try &#123;&gt; // 休眠5秒模拟下载过程&gt; Thread.sleep(5 * 1000);&gt; // 假设每个下载文件的大小为（序号*100）&gt; size += i * 100;&gt; // 发布进度更新&gt; publishProgress( (100* i )/count);&gt; &#125; catch (InterruptedException ie) &#123;&gt; ie.printStackTrace();&gt; &#125;&gt; &#125;&gt; return size;&gt; &#125;&gt; 我们调用了 publishProgress 可以将 doInBackground中耗时任务的进度发送出去，大家都知道这个进度会发送到onProgressUpdate() 方法中，在onProgressUpdate我们可以方便的进行UI 更新，比如进度条进度更新等。那么他是怎么实现的呢？这就要看publishProgress这个方法的实现了。 1234567@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; AsyncTaskResult 顾名思义，很好理解了，就是AsyncTask的执行结果，这是一个静态的内部类，包括两个属性mTask和mData 。 1234567891011@SuppressWarnings(&#123;"RawUseOfParameterizedType"&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125;&#125; 因此publishProgress中 new AsyncTaskResult 就是创建了一个AsyncTaskResult,他的两个两个属性为当前的AsyncTask和任务任务执行进度。 到这里的逻辑很清楚了，如果当前任务没有被取消， 那么就从消息池中获取一个Message的实例，同时设置这个Message对象的msg.what=MESSAGE_POST_PROGRESS, msg.obj为一个AsyncTaskResult对象，最后执行sendToTarget方法，通过之前对Handler实现机制的了解，我们知道sendXXX方法殊途同归，所完成的任务都是将Message对象插入到MessageQueue当中，等着Looper的loop方法一个个取出。由于我们是在主线程开启了AsyncTask任务的执行，因此，一旦我们将一个消息插入到队列，那么就会执行Handler的handleMessage方法。下面就来看看你这个InternalHandler 的实现。 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 很简单,在handleMessage中首先取出结果，并强制转换为AsyncTaskResult对象，在msg.what=MESSAGE_POST_PROGRESS时，就会执行result.mTask.onProgressUpdate(result.mData);mTask 就是当前AsyncTask，因此就会执行AsyncTask中声明的onProgressUpdate方法。这样，就把参数从一个子线程传递到了UI 线程，非常方便开发人员用这个完成相关业务。 我们再回到mWorker 的call() 方法中，当doInBackground执行完毕后，最后就会执行postResult。 1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 这个方法和publishProgress逻辑一样，懂事把result 封装到一个AsyncTaskResult 对象中，做为一个Message对象的obj属性插入到MessageQueue中，只不过msg.what=MESSAGE_POST_RESULT. 这样就会来到InternalHandler 的handleMessage中，这一次msg.what=MESSAGE_POST_RESULT.时执行result.mTask.finish(result.mData[0]); 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 这个方法也很简单，任务未取消时，onPostExecute(result) 方法被执行。这个onPostExecute(result)就是我们最后要执行的方法，在这个方法中得到最终的执行结果；并将任务状态标记为FINISHED。 其他串行or并行？在SimpleAsyncTask中，我们使用private static final Executor EXECUTOR = Executors.newCachedThreadPool()作为线程池，而实际上，源码中的默认线程池是自定义的，这个类是SerialExecutor，从类的命名上看，Serial是串行的意思，所以很明显，AsyncTask默认是串行的。除此之外，AsyncTask里还有个线程池 THREAD_POOL_EXECUTOR，实在需要并行的话我们就用这个线程池。 如果都些都不满足要求，我们也可以自定义符合自己业务要求的线程池，并通过setDefaultExecutor(Executor exec)改变默认的线程池。 在executeOnExecutor中我们还可以传入自己自定义的线程池： 123456//跟默认一样的按顺序执行asyncTask.executeOnExecutor(Executors.newSingleThreadExecutor());//无限制的ExecutorasyncTask.executeOnExecutor(Executors.newCachedThreadPool());//同时执行数目为10的ExecutorasyncTask.executeOnExecutor(Executors.newFixedThreadPool(10)); postResultIfNotInvoked的作用是什么？AsyncTask有很多逻辑干扰了我们解读源码，postResultIfNotInvoked便是其中一个。它实际上是Google解决的一个bug，确保如果cancel()方法过早调用的场景下，onCancelled()仍然能顺利的执行，参考stackoverflow这篇文章。 用这个玩意 退出页面必须取消运行 否则你下个页面用的时候就知道问题了 串行坑了我一次参考理解 AsyncTask 原理 关于AsyncTask的一次深度解析 AsyncTask:一只命途多舛的小麻雀]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Bound Service 知识总结]]></title>
    <url>%2Fposts%2Fccf7cf3d.html</url>
    <content type="text"><![CDATA[基础知识绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。 本文向您介绍如何创建绑定服务，包括如何绑定到来自其他应用组件的服务。 不过，您还应参阅Android Service 知识总结，了解有关一般服务的更多信息，例如：如何利用服务传送通知、如何将服务设置为在前台运行等等。 绑定服务是 Service 类的实现，可让其他应用与其绑定和交互。要提供服务绑定，您必须实现 onBind() 回调方法。该方法返回的 IBinder 对象定义了客户端用来与服务进行交互的编程接口。 绑定到已启动服务 正如Android Service 知识总结中所述，可以创建同时具有已启动和绑定两种状态的服务。 也就是说，可通过调用startService() 启动该服务，让服务无限期运行；此外，还可通过调用 bindService() 使客户端绑定到服务。 如果您确实允许服务同时具有已启动和绑定状态，则服务启动后，系统“不会”在所有客户端都取消绑定时销毁服务。 为此，您必须通过调用 stopSelf() 或 stopService() 显式停止服务。 尽管您通常应该实现 onBind() 或 onStartCommand()，但有时需要同时实现这两者。例如，音乐播放器可能发现让其服务无限期运行并同时提供绑定很有用处。 这样一来，Activity 便可启动服务进行音乐播放，即使用户离开应用，音乐播放也不会停止。 然后，当用户返回应用时，Activity 可绑定到服务，重新获得回放控制权。 请务必阅读管理绑定服务的生命周期部分，详细了解有关为已启动服务添加绑定时该服务的生命周期信息。 客户端可通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。bindService() 方法会立即无值返回，但当 Android 系统创建客户端与服务之间的连接时，会对 ServiceConnection 调用 onServiceConnected()，向客户端传递用来与服务通信的 IBinder。 多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。 当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 startService() 也启动了该服务）。 当您实现绑定服务时，最重要的环节是定义您的 onBind() 回调方法返回的接口。您可以通过几种不同的方法定义服务的IBinder 接口，下文对这些方法逐一做了阐述。 创建绑定服务创建提供绑定的服务时，您必须提供 IBinder，用以提供客户端用来与服务进行交互的编程接口。 您可以通过三种方法定义接口： 扩展 Binder 类如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service中可用的公共方法。如果服务只是您的自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的服务被其他应用或不同的进程占用。 使用 Messenger如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。 使用 AIDLAIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 注：大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用，本文也不会阐述如何将其用于您的服务。如果您确定自己需要直接使用 AIDL，请参阅 AIDL 文档。 在Android系统中，一个进程是不能直接访问另一个进程的内存的，需要提供一些机制在不同的进程之间进行通信，Android官方推出了AIDL(Android Interface Definition Language)，它是基于Binder机制的，至于官方为什么要采用Binder，查看为什么Android要采用Binder作为IPC机制，分析很全面。如果组件与服务通信是在同一进程，就使用第一种方式；如果是跨进程通信，使用第二种和第三种，两者不同在于，Messenger不能处理多线程并发请求。 扩展 Binder 类 如果您的服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让您的客户端通过该类直接访问服务中的公共方法。 注：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。 以下是具体的设置方法： 在您的服务中，创建一个可满足下列任一要求的Binder 实例： 包含客户端可调用的公共方法 返回当前 Service 实例，其中包含客户端可调用的公共方法 或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法 从 onBind() 回调方法返回此 Binder 实例。 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。 注：之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组。 例如，以下这个服务可让客户端通过 Binder 实现访问服务中的方法： 123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; LocalBinder 为客户端提供 getService() 方法，以检索 LocalService 的当前实例。这样，客户端便可调用服务中的公共方法。 例如，客户端可调用服务中的 getRandomNumber()。 点击按钮时，以下这个 Activity 会绑定到 LocalService 并调用 getRandomNumber() ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 上例说明了客户端如何使用 ServiceConnection 的实现和 onServiceConnected() 回调绑定到服务。下文更详细介绍了绑定到服务的过程。 注：在上例中，onStop() 方法将客户端与服务取消绑定。 客户端应在适当时机与服务取消绑定，如附加说明中所述。 使用 Messenger 与 AIDL 比较 当您需要执行 IPC 时，为您的接口使用 Messenger 要比使用 AIDL 实现它更加简单，因为 Messenger 会将所有服务调用排入队列，而纯粹的 AIDL 接口会同时向服务发送多个请求，服务随后必须应对多线程处理。 对于大多数应用，服务不需要执行多线程处理，因此使用 Messenger 可让服务一次处理一个调用。如果您的服务必须执行多线程处理，则应使用 AIDL 来定义接口。 如需让服务与远程进程通信，则可使用 Messenger 为您的服务提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。 以下是 Messenger 的使用方法摘要： 服务实现一个 Handler，由其接收来自客户端的每个调用的回调 Handler 用于创建 Messenger 对象（对 Handler 的引用） Messenger 创建一个 IBinder，服务通过 onBind() 使其返回客户端 客户端使用 IBinder 将 Messenger（引用服务的 Handler）实例化，然后使用后者将 Message 对象发送给服务 服务在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message。 这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message 对象）是服务在其 Handler 中接收的。以下是一个使用 Messenger 接口的简单服务示例： 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 请注意，服务就是在 Handler#handleMessage() 方法中接收传入的 Message，并根据 what 成员决定下一步操作。 客户端只需根据服务返回的IBinder 创建一个 Messenger，然后利用 send() 发送一条消息。例如，以下就是一个绑定到服务并向服务传递 MSG_SAY_HELLO 消息的简单 Activity： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 请注意，此示例并未说明服务如何对客户端作出响应。如果您想让服务作出响应，则还需要在客户端中创建一个Messenger。然后，当客户端收到 onServiceConnected() 回调时，会向服务发送一条 Message，并在其 send() 方法的 replyTo 参数中包含客户端的 Messenger。 使用 AIDLAIDL，即Android Interface Definition Language，Android接口定义语言。它是一种IDL语言，可以拿来生成用于IPC的代码。在我看来，它其实就是一个模板。为什么这样说呢？在我们的使用中，实际上起作用的并不是我们写的AIDL代码，而是系统根据它生成的一个IInterface实例的代码。而如果大家多生成几个这样的实例，然后把它们拿来比较，你会发现它们都是有套路的——都是一样的流程，一样的结构，只是根据具体的AIDL文件的不同有细微的变动。所以其实AIDL就是为了避免我们一遍遍的写一些千篇一律的代码而出现的一个模板。 使用Messenger也是基于AIDL的，Messenger把所有请求都放在一个线程中，service每次处理一个。然而对于AIDL实现来说。service可以同时处理多个请求（应该是并发处理）。这种情况下，你的服务必须拥有多线程处理能力，并且是以线程安全的方式编写的。要直接使用AIDL，你必须创建一个.aidl文件，其中定义了编程接口。 Android SDK 工具使用此文件来自动生成一个抽象类，其中实现了接口及对IPC的处理，然后我们就可以在自己的服务中继承该类。 那么如何使用AIDL来通过bindService()进行线程间通信呢？基本上有下面这些步骤： 服务端创建一个AIDL文件，将暴露给客户端的接口在里面声明在service中实现这些接口客户端绑定服务端，并将onServiceConnected()得到的IBinder转为AIDL生成的IInterface实例通过得到的实例调用其暴露的方法上面的描述其实比较抽象，基本上是那种看了也不知道怎么做的类型——这个如果要展开讲的话就又是长篇大论的了。基于这种考虑，这里只是简单的介绍一下AIDL这个东西，它的具体的语法，到底怎么来实现IPC，参考Android进程通信之Messenger&amp;AIDL使用详解。 绑定到服务应用组件（客户端）可通过调用 bindService() 绑定到服务。Android 系统随后调用服务的 onBind() 方法，该方法返回用于与服务交互的IBinder。 绑定是异步的。bindService() 会立即返回，“不会”使IBinder返回客户端。要接收 IBinder，客户端必须创建一个 ServiceConnection 实例，并将其传递给 bindService()。ServiceConnection 包括一个回调方法，系统通过调用它来传递IBinder。 注：只有 Activity、服务和内容提供程序可以绑定到服务 — 您无法从广播接收器绑定到服务。 因此，要想从您的客户端绑定到服务，您必须：1.实现ServiceConnection。 您的实现必须重写两个回调方法： onServiceConnected() 系统会调用该方法以传递服务的 onBind() 方法返回的 IBinder。 onServiceDisconnected() Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。 2.调用 bindService()，传递 ServiceConnection 实现。3.当系统调用您的 onServiceConnected() 回调方法时，您可以使用接口定义的方法开始调用服务。4.要断开与服务的连接，请调用 unbindService()。 如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。 更好的做法是在客户端与服务交互完成后立即取消绑定客户端。 这样可以关闭空闲服务。如需了解有关绑定和取消绑定的适当时机的详细信息，请参阅附加说明。 例如，以下代码段通过扩展 Binder 类将客户端与上面创建的服务相连，因此它只需将返回的 IBinder转换为 LocalService类并请求 LocalService 实例： 123456789101112131415161718LocalService mService;private ServiceConnection mConnection = new ServiceConnection() &#123; // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) &#123; // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) &#123; Log.e(TAG, "onServiceDisconnected"); mBound = false; &#125;&#125;; 客户端可通过将此 ServiceConnection 传递至 bindService() 绑定到服务。例如： 12Intent intent = new Intent(this, LocalService.class);bindService(intent, mConnection, Context.BIND_AUTO_CREATE); bindService() 的第一个参数是一个 Intent，用于显式命名要绑定的服务（但 Intent 可能是隐式的） 第二个参数是 ServiceConnection 对象 第三个参数是一个指示绑定选项的标志。它通常应该是 BIND_AUTO_CREATE，以便创建尚未激活的服务。其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或 0（表示无）。 附加说明以下是一些有关绑定到服务的重要说明： 您应该始终捕获 DeadObjectException 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。 对象是跨进程计数的引用。 您通常应该在客户端生命周期的匹配引入 (bring-up) 和退出 (tear-down) 时刻期间配对绑定和取消绑定。 例如： 如果您只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。 如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。 注：通常情况下，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的处理保持在最低水平。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （Activity文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。） 管理绑定服务的生命周期当服务与所有客户端之间的绑定全部取消时，Android 系统便会销毁服务（除非还使用 onStartCommand() 启动了该服务）。因此，如果您的服务是纯粹的绑定服务，则无需对其生命周期进行管理 — Android 系统会根据它是否绑定到任何客户端代您管理。 不过，如果您选择实现 onStartCommand() 回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过 stopSelf() 自行停止，或其他组件调用 stopService() 为止，无论其是否绑定到任何客户端。 此外，如果您的服务已启动并接受绑定，则当系统调用您的 onUnbind() 方法时，如果您想在客户端下一次绑定到服务时接收 onRebind() 调用，则可选择返回 true。onRebind() 返回空值，但客户端仍在其 onServiceConnected() 回调中接收 IBinder。下图说明了这种生命周期的逻辑。 其他知识Messenger与AIDL的比较首先，在实现的难度上，肯定是Messenger要简单的多——至少不需要写AIDL文件了(虽然如果认真的究其本质，会发现它的底层实现还是AIDL)。另外，使用Messenger还有一个显著的好处是它会把所有的请求排入队列，因此你几乎可以不用担心多线程可能会带来的问题。 但是这样说来，难道AIDL进行IPC就一无是处了么？当然不是，如果是那样的话它早就被淘汰了。一方面是如果项目中有并发处理问题的需求，或者会有大量的并发请求，这个时候Messenger就不适用了——它的特性让它只能串行的解决请求。另外，我们在使用Messenger的时候只能通过Message来传递信息实现交互，但是在有些时候也许我们需要直接跨进程调用服务端的方法，这个时候又怎么办呢？只能使用AIDL。 所以，这两种IPC方式各有各的优点和缺点，具体使用哪种就看具体的需要了——当然，能使用简单的就尽量使用简单的吧。 参考Android Developers/Docs/指南/绑定服务 Android中的Service：Binder，Messenger，AIDL（2）]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service 知识总结]]></title>
    <url>%2Fposts%2F75909e64.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 framework/base/core/java/andorid/app/Service.java 简介引用官方定义: Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 注意：服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。 Service是一个可以在后台执行长时间操作而不使用用户界面的应用组件。那么问题来了，既然它不使用用户界面，那么它怎么知道应该什么时候开始执行什么操作呢？答案是——它可以与其他的引用组件形成一些联系，从而可以根据其传来的信息在合适的时候执行合适的操作。 一般来讲，这种联系分为两种：startService()以及bindService()。这两种联系都可以使得一个Service开始运行，但是在其他方面有着诸多不同。 启动service的方式 停止service的方式 service与启动它的组件之间的通信方式 service的生命周期 startService 在其他组件中调用startService()方法后，服务即处于启动状态 service中调用stopSelf()方法，或者其他组件调用stopService()方法后，service将停止运行 没有提供默认的通信方式，启动service后该service就处于独立运行状态 一旦启动，service即可在后台无限期运行，即使启动service的组件已被销毁也不受其影响，直到其被停止 bindService 在其他组件中调用bindService()方法后，服务即处于启动状态 所有与service绑定的组件都被销毁，或者它们都调用了unbindService()方法后，service将停止运行 可以通过 ServiceConnection进行通信，组件可以与service进行交互、发送请求、获取结果，甚至是利用IPC跨进程执行这些操作 当所有与其绑定的组件都取消绑定(可能是组件被销毁也有可能是其调用了unbindService()方法)后，service将停止 注：1.表格中的“其他组件”不包括Broadcast receiver，其不能bindService,但是可以startService的 2.startService()与bindService()并不冲突，同一个service可能既有组件调用了startService()启动它，又有组件与它进行了绑定。当同一个service与其他组件同时存在这两种联系时，其生命周期会发生变化，必须从两种方法的角度看service均停止才能真正停止。 创建Service创建一个Service一般有下面2个步骤 创建一个类继承自Service(或它的子类，如IntentService)，重写里面的一些键的回调方法，如onStartCommand()，onBind()等 在Manifests文件里面为其声明，并根据需要配置一些其他属性。 讲道理，这一切跟新建一个Activity非常的像。 onCreate()在每个Service的生命周期中这个方法会且仅会调用一次，并且它的调用在onStartCommand()以及onBind()之前，我们可以在这个方法中进行一些一次性的初始化工作。 onStartCommand()当其他组件通过startService()方法启动Service时，此方法将会被调用。 onBind()当其他组件通过bindService()方法与Service相绑定之后，此方法将会被调用。这个方法有一个IBinder的返回值，这意味着在重写它的时候必须返回一个IBinder对象，它是用来支撑其他组件与Service之间的通信的——另外，如果你不想让这个Service被其他组件所绑定，可以通过在这个方法返回一个null值来实现。 onDestroy()这是Service一生中调用的最后一个方法，当这个方法被调用之后，Service就会被销毁。所以我们应当在这个方法里面进行一些资源的清理，比如注册的一些监听器什么的。 在Manifests文件里进行声明的时候，只有android:name属性是必须要有的，其他的属性都可以没有。但是有的时候适当的配置可以让我们的开发进行地更加顺利，所以了解一下注册一个Service可以声明哪些属性也是很有必要的。12345678910&lt;service android:enabled=["true" | "false"] android:exported=["true" | "false"] android:icon="drawable resource" android:isolatedProcess=["true" | "false"] android:label="string resource" android:name="string" android:permission="string" android:process="string" &gt;&lt;/service&gt; 具体含义可参考官网 android:enabled : 如果为true，则这个Service可以被系统实例化，如果为false，则不行。默认为true android:exported : 如果为true，则其他应用的组件也可以调用这个Service并且可以与它进行互动，如果为false，则只有与Service同一个应用或者相同user ID的应用可以开启或绑定此Service。它的默认值取决于Service是否有intent filters。如果一个filter都没有，就意味着只有指定了Service的准确的类名才能调用，也就是说这个Service只能应用内部使用——其他的应用不知道它的类名。这种情况下exported的默认值就为false。反之，只要有了一个filter，就意味着Service是考虑到外界使用的情况的，这时exported的默认值就为true android:icon : 一个象征着这个Service的icon android:isolatedProcess : 如果设置为true，这个Service将运行在一个从系统中其他部分分离出来的特殊进程中，我们只能通过Service API来与它进行交流。默认为false。 android:label : 显示给用户的这个Service的名字。如果不设置，将会默认使用的label属性。 android:name : 这个Service的路径名，例如“com.lingdage.demo.ServiceDemo”。这个属性是唯一一个必须填的属性。 android:permission : 其他组件必须具有所填的权限才能启动这个Service。 android:process : Service运行的进程的name。默认启动的Service是运行在主进程中的。 Demo123456789101112131415161718192021222324252627282930313233343536public class ServiceDemo extends Service &#123; private static final String TAG = "ServiceDome"; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate"); //只在service创建的时候调用一次，可以在此进行一些一次性的初始化操作 &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand"); //当其他组件调用startService()方法时，此方法将会被调用 //在这里进行这个service主要的操作 return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind"); //当其他组件调用bindService()方法时，此方法将会被调用 //如果不想让这个service被绑定，在此返回null即可 return null; &#125; @Override public void onDestroy() &#123; Log.d(TAG, "onDestroy"); //service调用的最后一个方法 //在此进行资源的回收 super.onDestroy(); &#125;&#125; 注意:每个Service必须在manifest中 通过来声明 1234&gt; &lt;service android:name="com.example.servicetest.ServiceDemo" &gt; &gt; ... &gt; &lt;/service&gt;&gt; 现在我们通过继承Service的方式定义了我们自己的ServiceDemo类,并且在manifest中声明了我们的ServiceDemo,接下来我们应该启动我们自己的服务. 请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 启动Service另一个组件通过调用startService()方法，就可以启动一个特定的Service，并且这将导致Service中的onStartCommand()方法被调用。在调用startService()方法的时候，其他组件需要在方法中传递一个Intent参数，然后Service将会在onStartCommand()中接收这个Intent，并获取一些数据。比如此时某个Activity要将一些数据存入数据库中，我就可以通过Intent把数据传入Service，然后让Service去进行连接数据库，存储数据等操作，而此时用户可以执行其他的任何操作——甚至包括销毁那个Activity——这并不会影响Service存储数据这件事。 当一个Service通过这种方式启动之后，它的生命周期就已经不受启动它的组件影响了，它可以在后台无限期的运行下去，只要Service自身没有调用stopSelf()并且其他的组件没有调用针对它的stopService()。 另外，如果确定了使用这种方式启动Service并且不希望这个Service被绑定的话，那么也许除了传统的创建一个类继承Service之外我们有一个更好的选择——IntentService。 相比Service，IntentService要简单许多。但是要注意的是，如果你有让Service同时处理多个请求的需求，这个时候就只能去继承Service了。这个时候就要自己去处理工作线 demo 我们通过一个Intent对象，并调用startService()方法来启动ServiceDemo 12Intent startIntent = new Intent(this, ServiceDemo.class); startService(startIntent); 注意,假如我们是通过点击Button执行上面的代码,那么第一次点击的时候回执行其中的onCreate()和onStartCommand()方法,但是当我们第二次点击的时候就只会执行onStartCommand()方法了. 为什么会这样呢？这是由于onCreate()方法只会在Service第一次被创建的时候调用，如果当前Service已经被创建过了(第一次点击创建了ServiceDemo)，不管怎样调用startService()方法，onCreate()方法都不会再执行。 启动了之后,当我们想停止服务的时候该怎么做呢? 我们也是通过一个Intent对象，并调用stopService()方法来停止ServiceDemo 12Intent stopIntent = new Intent(this, ServiceDemo.class);stopService(stopIntent); 停止Service启动服务必须管理自己的生命周期。也就是说，除非系统必须回收内存资源，否则系统不会停止或销毁服务，而且服务在onStartCommand() 返回后会继续运行。因此，服务必须通过调用 stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 一旦请求使用 stopSelf() 或 stopService() 停止服务，系统就会尽快销毁服务。 但是，如果服务同时处理多个 onStartCommand() 请求，则您不应在处理完一个启动请求之后停止服务，因为您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，您可以使用stopSelf(int) 确保服务停止请求始终基于最近的启动请求。也就说，在调用 stopSelf(int) 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果在您能够调用 stopSelf(int) 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。 注意：为了避免浪费系统资源和消耗电池电量，应用必须在工作完成之后停止其服务。 如有必要，其他组件可以通过调用stopService() 来停止服务。即使为服务启用了绑定，一旦服务收到对 onStartCommand() 的调用，您始终仍须亲自停止服务。 创建绑定服务绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接（通常不允许组件通过调用startService() 来启动它）。 如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。 要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（您不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。 要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 bindService这是一种比startService更复杂的启动方式，同时使用这种方式启动的service也能完成更多的事情，比如其他组件可向其发送请求，接受来自它的响应，甚至通过它来进行IPC等等。我们通常将绑定它的组件成为客户端，而称它为服务器。 如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式 继承Binder类 使用Messenger类(AIDL的简化版) 使用AIDL 这一块比较复杂,我们新开一篇讲解。Android Bound Service 知识总结 在前台运行服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。 例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 要请求让服务运行于前台，请调用 startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的Notification。例如： 1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。 要从前台移除服务，请调用stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。 管理服务生命周期 服务的生命周期比 Activity的生命周期要简单得多。但是，密切关注如何创建和销毁服务反而更加重要，因为服务可以在用户没有意识到的情况下运行于后台。 服务生命周期（从创建到销毁）可以遵循两条不同的路径： 启动服务 该服务在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用 stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止服务。服务停止后，系统会将其销毁。 绑定服务 该服务在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过 IBinder 接口与服务进行通信。客户端可以通过调用 unbindService() 关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统即会销毁该服务。 （服务不必自行停止运行。） 这两条路径并非完全独立。也就是说，您可以绑定到已经使用 startService() 启动的服务。例如，可以通过使用Intent（标识要播放的音乐）调用 startService() 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 bindService() 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 stopService() 或 stopSelf() 不会实际停止服务。 实现生命周期回调与 Activity 类似，服务也拥有生命周期回调方法，您可以实现这些方法来监控服务状态的变化并适时执行工作。 以下框架服务展示了每种生命周期方法： 12345678910111213141516171819202122232425262728293031323334public class ExampleService extends Service &#123; int mStartMode; // indicates how to behave if the service is killed IBinder mBinder; // interface for clients that bind boolean mAllowRebind; // indicates whether onRebind should be used @Override public void onCreate() &#123; // The service is being created &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // The service is starting, due to a call to startService() return mStartMode; &#125; @Override public IBinder onBind(Intent intent) &#123; // A client is binding to the service with bindService() return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; // All clients have unbound with unbindService() return mAllowRebind; &#125; @Override public void onRebind(Intent intent) &#123; // A client is binding to the service with bindService(), // after onUnbind() has already been called &#125; @Override public void onDestroy() &#123; // The service is no longer used and is being destroyed &#125;&#125; 注：与 Activity 生命周期回调方法不同，您不需要调用这些回调方法的超类实现。 通过实现这些方法，您可以监控服务生命周期的两个嵌套循环： 服务的整个生命周期从调用onCreate() 开始起，到onDestroy()返回时结束。与 Activity 类似，服务也在onCreate()中完成初始设置，并在onDestroy()中释放所有剩余资源。例如，音乐播放服务可以在onCreate()中创建用于播放音乐的线程，然后在onDestroy()中停止该线程。 无论服务是通过 startService() 还是 bindService() 创建，都会为所有服务调用 onCreate() 和 onDestroy() 方法。 服务的有效生命周期从调用onStartCommand()或onBind()方法开始。每种方法均有Intent对象，该对象分别传递到startService()或bindService() 。 对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 onUnbind() 返回时结束。 注：尽管启动服务是通过调用 stopSelf() 或 stopService() 来停止，但是该服务并无相应的回调（没有 onStop() 回调）。因此，除非服务绑定到客户端，否则在服务停止时，系统会将其销毁 — onDestroy() 是接收到的唯一回调。 其他知识点Service和Thread的关系答案：Service和Thread之间没有任何关系！ 两者概念的迥异 Thread 是程序执行的最小单元，它是分配CPU的基本单位，Android系统中UI线程也是线程的一种，当然Thread还可以用于执行一些耗时异步的操作。 Service是Android的一种机制，服务是运行在主线程上的，它是由系统进程托管。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是Binder，它是在linux层交换信息的一种IPC，而所谓的Service后台任务只不过是指没有UI的组件罢了。 两者的执行任务迥异 在Android系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作。如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。 Service 则是Android系统中的组件，一般情况下它运行于主线程中，因此在Service中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称Service为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让Service执行耗时任务，可在Service中开启单独线程去执行。 两者使用场景 当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程Thread，这样才能保证UI线程不被占用而影响用户体验。 在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过Service+Notification方式在后台执行同时在通知栏显示着。 两者的最佳使用方式在大部分情况下，Thread和Service都会结合着使用，比如下载文件，一般会通过Service在后台执行+Notification在通知栏显示+Thread异步下载，再如应用程序会维持一个Service来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个Thread与Service的结合来方便我们执行后台耗时任务，它就是IntentService，(深入了解IntentService，可以看IntentService)，当然IntentService并不适用于所有的场景，但它的优点是使用方便、代码简洁，不需要我们创建Service实例并同时也创建线程，某些场景下还是非常赞的！由于IntentService是单个worker thread，所以任务需要排队，因此不适合大多数的多任务情况。还有为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联(通过绑定)，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 Service的种类按运行地点分类 类别 区别 优点 缺点 应用 本地服务(Local) 该服务依附在主进程上 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。 主进程被Kill后，服务便会终止。 非常常见的应用如：音乐播放服务。 远程服务(Remote) 该服务是独立的进程 服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 一些提供系统服务的Service，这种Service是常驻的。 按运行类型分类 类别 区别 应用 前台服务 会在通知一栏显示 ONGOING 的 Notification， 当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。 后台服务 默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。 当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。 有同学可能会问，后台服务我们可以自己创建ONGOING的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground（ android 2.0 及其以后版本 ）或 setForeground（android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification任然会移除掉。 #### 按使用方式分类 类别 区别 startService 启动的服务 主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService bindService 启动的服务 该方法启动的服务要进行通信。停止服务使用unbindService startService 同时也 bindService 启动的服务 停止服务应同时使用stepService与unbindService 特别注意:1、你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService 解除绑定（尽管 Activity被 finish 的时候绑定会自动解除，并且Service会自动停止）；2、你应当注意 使用startService启动服务之后，一定要使用 stopService停止服务，不管你是否使用bindService；3、同时使用 startService 与 bindService 要注意到，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context不存在了（如Activity被finish 的时候）之后服务才会自动停止；4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context不存在了），对应服务的生命周期与上述相同。5、在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用onStartCommand而不是 onStart。 这两种启动方式生命周期可以参考Android Service本地服务详解 onStartCommand详解第一次调用startService方法时，onCreate方法、onStartCommand`方法将依次被调用，而多次调用startService时，只有onStartCommand方法被调用，最后我们调用stopService方法停止服务时onDestory方法被回调，这就是启动状态下Service`的执行周期。接着我们重新回过头来进一步分析onStartCommand（Intent intent, int flags, int startId），这个方法有3个传入参数，它们的含义如下： intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下： START_FLAG_REDELIVERY这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。 START_FLAG_RETRY该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。 startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。 另外，我们注意到onStartCommand()的返回值是一个很奇怪的值START_STICKY，这是个什么呢？或者说这个方法的返回值是用来干嘛的呢？事实上，它的返回值是用来指定系统对当前线程的行为的。它的返回值必须是以下常量之一： START_NOT_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但绝对不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 关于启动服务与绑定服务间的转换问题虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个Service创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个Service实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况： 先绑定服务后启动服务如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主Activity被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。 先启动服务后绑定服务如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法抑或内存不足时才会销毁服务。 以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论Service是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用Activity那样通过调用Intent 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。 参考Android中的Service：默默的奉献者 (1) Android Developers/Docs/指南/服务 全面了解 Service 关于Android Service真正的完全详解，你需要知道的一切]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal 源码分析]]></title>
    <url>%2Fposts%2F26c77b42.html</url>
    <content type="text"><![CDATA[https://juejin.im/post/5c948d3b6fb9a070ba314002 基本使用 源码分析 使用场景 优缺点 Java 并发编程：ThreadLocal 的使用及其源码实现https://juejin.im/post/5b44cd7c6fb9a04f980cb065Java 200+ 面试题补充 ThreadLocal 模块https://juejin.im/post/5c805cb9f265da2d9e177f6d 带你揭秘神秘的ThreadLocal https://juejin.im/post/5c77a0dfe51d45374276fab9 https://blog.csdn.net/carson_ho/article/details/82344011]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService 源码分析]]></title>
    <url>%2Fposts%2Fe4e64342.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 framework/base/core/java/andorid/app/IntentService.java IntentService简介IntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题： Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中 Service 也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。 Service主要用来在后台进行任务处理，例如后台播放音乐、下载文件、上传文件等等。由于Service是运行在主线程中的，也有一定的时间限制，如果在主线程中对一个任务的处理时间超过了限制，进程就会出现“应用不响应”,即ANR, Application Not Responding。为了避免这样情况,一般都会在Service里用新的thread处理一些可能需要更多处理时间的任务。 其实Android早就替我们设计了一种更方便的Service + Thread模式，就是本文要讲的IntentService，通过它可以很方便地实现在Service中使用Thread进行耗时任务的处理。 基础用法扩展 IntentService 类以下是 IntentService 的实现示例： 123456789101112131415161718192021222324252627public class HelloIntentService extends IntentService &#123; /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() &#123; super("HelloIntentService"); &#125; /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; &#125;&#125; 您只需要一个构造函数和一个 onHandleIntent() 实现即可。 如果您决定还重写其他回调方法（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现，以便 IntentService 能够妥善处理工作线程的生命周期。 例如，onStartCommand() 必须返回默认实现（即，如何将 Intent 传递给 onHandleIntent()）： 12345@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId);&#125; 除 onHandleIntent() 之外，您无需从中调用超类的唯一方法就是 onBind()（仅当服务允许绑定时，才需要实现该方法）。 在下一部分中，您将了解如何在扩展 Service 基类时实现同类服务。该基类包含更多代码，但如需同时处理多个启动请求，则更适合使用该基类。 扩展服务类正如上一部分中所述，使用 IntentService 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 Service 类来处理每个 Intent。 为了便于比较，以下提供了 Service 类实现的代码示例，该类执行的工作与上述使用 IntentService 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HelloService extends Service &#123; private Looper mServiceLooper; private ServiceHandler mServiceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread thread = new HandlerThread("ServiceStartArguments", Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread's Looper and use it for our Handler mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; mServiceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // We don't provide binding, so return null return null; &#125; @Override public void onDestroy() &#123; Toast.makeText(this, "service done", Toast.LENGTH_SHORT).show(); &#125;&#125; 正如您所见，与使用 IntentService 相比，这需要执行更多工作。 但是，因为是由您自己处理对 onStartCommand() 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。 请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。以上大部分来自官方文档 源码分析创建工作线程123456789101112public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 当IntentService第一次启动的时候会调用其onCreate来完成一些初始化操作： 首先创建了一个HandlerThread对象，这就是前面一直提到的Worker线程。大家对Handler和Thread都很了解，那这个HandlerThread是什么呢？简单来说，它就是内部有一个消息循环队列的线程，我们知道默认的线程内部是没有消息循环队列的，这就导致我们无法直接在其内部使用Handler。Android为了方便使用，直接提供了一个含有消息循环队列的HandlerThread。具体见HandlerThread 源码分析 利用已创建的HandlerThread内部的消息循环创建一个 ServiceHandler对象，这样它的消息处理函数handleMessage就会在对应的线程中执行了。 接收和处理请求我们其他组件通过startService来发送请求的，结合service的生命周期，会执行onStartCommand回调 1234public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125; 1234567@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; 从这段代码看到，onStartCommand会直接调用onStart，在这里对发送过来的请求接收并通过mServiceHandler进行处理。 1234567891011private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125; 在handleMessage中对接收到的请求用onHandleIntent进行实际处理，而onHandleIntent就是我们在使用过程中必须实现的处理逻辑。 销毁Worker线程前面提到：当所有请求都被处理完成后，service就会被销毁，这是如何实现的呢？在上面看到handleMessage方法里在处理完当前请求时会调用stopSelf(msg.arg1)来尝试停止当前服务，之所以说“尝试”，是因为它不一定能真正停止服务。还是来看下stopSelf(int)的实现代码： 123456789101112131415/** * Old version of &#123;@link #stopSelfResult&#125; that doesn't return a result. * * @see #stopSelfResult */public final void stopSelf(int startId) &#123; if (mActivityManager == null) &#123; return; &#125; try &#123; mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125;&#125; 1234567891011public final boolean stopSelfResult(int startId) &#123; if (mActivityManager == null) &#123; return false; &#125; try &#123; return mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125; return false;&#125; 在stopSelf(int)的声明里提到它是stopSelfResult(int)的老版本，唯一的区别就是没有返回值。那我们直接看stopSelfResult(int)的声明，其中提到只有在当前的service的最近一次启动是startId发起的才会被停止。我们把这句话放在IntentService的场景里去理解，如果说当前接收到3个请求，在处理第一个请求后打算去停止服务，但是调用stopSelf(int)的时候发现最后一次启动是第三个请求发生的，并不会停止服务；处理完第二个请求后是类似的，只有在处理完第三个请求后，去尝试停止服务，这时发现最近一次启动就是它发起的，可以去停止服务了。 停止服务时，其onDestroy会得到调用： 1234@Overridepublic void onDestroy() &#123; mServiceLooper.quit();&#125; 具体的用法例子可以参考IntentService 示例与详解 总结IntentService相比父类Service而言，最大特点是其回调函数onHandleIntent中可以直接进行耗时操作，不必再开线程。其原理是IntentService的成员变量 Handler在初始化时已属于工作线程，之后handleMessage，包括onHandleIntent等函数都运行在工作线程中。 如果对IntentService的了解仅限于此，会有种IntentService很鸡肋的观点，因为在Service中开线程进行耗时操作也不麻烦。我当初也是这个观点，所以很少用IntentService。 但是IntentService还有一个特点，就是多次调用onHandleIntent函数（也就是有多个耗时任务要执行），多个耗时任务会按顺序依次执行。原理是其内置的Handler关联了任务队列，Handler通过Looper取任务执行是顺序执行的。 这个特点就能解决多个耗时任务需要顺序依次执行的问题。而如果仅用Service，开多个线程去执行耗时操作，就很难管理。 由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。 IntentService特征 会创建独立的worker线程用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。 创建worker队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。 所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service 为Service的onBind()提供默认实现，返回null 为Service的onStartCommand提供默认实现，可将Intent 依次发送到工作队列和 onHandleIntent() 实现。 IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常 可以启动IntentService 多次，而每一个耗时操作会以工作队列的方式在IntentService 的 onHandleIntent 回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推` 参考IntentService的实际应用场景理解 IntentService 原理]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread 源码分析]]></title>
    <url>%2Fposts%2Fb4da2c1c.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 framework/base/core/java/andorid/os/HandlerThread.java 使用简介在Handler源码分析中我们提到,在子线程中创建Handler,要手动调用Looper.prepare(),创建的过程大致如下123456789101112Handler mHandler;private void createManualThreadWithHandler() &#123; new Thread() &#123; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler(Looper.myLooper()); Looper.loop(); &#125; &#125;.start();&#125; Android为了简化Handler的创建过程提供了一个便捷的类，使用它我们可以快速的创建一个带有Looper的线程，有了Looper这个线程，我们就可以生成Handler。 如何使用1234567891011121314// Step 1: 创建并启动HandlerThread线程，内部包含LooperHandlerThread handlerThread = new HandlerThread("lingdage");handlerThread.start();// Step 2: 创建HandlerHandler handler = new Handler(handlerThread.getLooper());// Step 3: 发送消息handler.post(new Runnable() &#123; @Override public void run() &#123; System.out.println("thread id="+Thread.currentThread().getId()); &#125;&#125;); 源码分析创建HandlerThread对象12345678910public HandlerThread(String name) &#123; super(name); //HandlerThread的默认优先级是Process.THREAD_PRIORITY_DEFAULT,具体值为0。 mPriority = Process.THREAD_PRIORITY_DEFAULT;&#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority;&#125; 线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。注意！是Process里的优先级而不是Thread的。 可控制的优先级 THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。 THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。 THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。 THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。 THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。 以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。 常见的加入优先级的方法如下 123456Runnable run = new Runnable() &#123; @Override public void run() &#123; android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); &#125;&#125;; 关于Android中线程的调度详情，请参考剖析Android中进程与线程调度之nice 获取Looper1234567891011121314151617181920212223/** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */public Looper getLooper() &#123; //使用handlerThread 要先start if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; // 进入同步块，当条件不满足时无限等待， try &#123; // 直到mLooper被设置成有效值了才退出while（当然也可能是线程状态不满足）； wait(); // run方法里的notifyAll就是用来唤醒这里的 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; 这个方法比较简单，直接看官方的注释就明白了。 执行HandlerThread的run()123456789101112public void run() &#123; mTid = Process.myTid(); //获取线程的tid Looper.prepare(); // 创建Looper对象 synchronized (this) &#123; mLooper = Looper.myLooper(); //获取looper对象 notifyAll(); //唤醒等待线程 &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); // 重写 onLooperPrepared，做一些初始化工作 Looper.loop(); //loop方法是阻塞的 在未执行quit()或quitSafely()的时候后面代码是不执行的 mTid = -1;&#125; Looper退出12345678 public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125; 12345678public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false;&#125; quit()与quitSafely()的区别，仅仅在于是否移除当前正在处理的消息。移除当前正在处理的消息可能会出现不安全的行为。 使用场景总结之前，我们先想一个场景，如果我们现在需要请求网络数据(假设需要请求一张图片,图片请求返回后需要更新UI),我们都知道UI线程中不允许进行耗时的网络请求。那么，我们通常会开启一个子线程来进行请求,如果你不用网络请求的三方库，一般会通过new Thread(),然后start()来完成吧！这样的话，如果有多次请求图片，那么我们就得new 很多个Thread。所以这是个问题！！！ 问题解决分析通过上面代码我们知道：HandlerThread一个子线程，并且含有一个Looper。再来看看那个问题：我们之所以需要new Thread(),然后start().是因为UI线程无法进行网络请求，但是，HandlerThread可是一个子线程，所以，在它里面可以直接请求网络，于是上面的new Thread()然后start()问题就解决了。当然，就凭他是个子线程还没法说服我，虽然它是一个子线程不需要new Thread()，但是它自己也可能需要多次创建啊！只不过是从new一个Thread变成了new HanderThread()而已。这还不是没卵用。 那么如何解释它不需要重复创建呢？其实也不难，只需要子线程不结束不就行了。(run方法中加个while(true)啊)，不过，它这里并不是while(true),而是用到了调用了一个loop()方法。 loop方法是阻塞的，所以它后面的语句在它未退出的（可以通过quit()方法和quitSafely()方法退出）时候是没办法执行的。再加上它可以通过在外部实现一个Handler，然后，通过这个Handler给Looper发送message，近而源源不断的实现网络请求。所以，这就真正的解决了上面提出的那个问题。这里给一个连接，里面介绍了如何在外部创建一个Handler,然后源源不断进行网络请求。Android 多线程之HandlerThread 完全详解 总结HandlerThread所做的就是在新开的子线程中创建了 Looper，那它的使用场景就是 Thread+Looper使用场景的结合，即：在子线程中执行耗时的、可能有多个任务的操作。 HandlerThread比较适用于单线程+异步队列的场景，比如IO读写操作，耗时不多而且也不会产生较大的阻塞。对于网络IO操作，HandlerThread并不适合，因为它只有一个线程，还得排队一个一个等着。 对于本地IO读取操作，我们可以使用postAtFrontOfQueue方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。 使用 HandlerThread 的典型例子就是 IntentService，参考另一篇文章。IntentService 源码分析 参考Android消息机制3-Handler(实战) HandlerThread 对HandlerThread的理解 Android 进阶15：HandlerThread 使用场景及源码解析]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler源码分析]]></title>
    <url>%2Fposts%2F20470e2e.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码，来分析Handler的用法 12345framework/base/core/java/andorid/os/ - Handler.java - Looper.java - Message.java - MessageQueue.java Handler作用 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行 线程切换：执行耗时的操作，比如网络请求，IO操作等，需要在子线程中运行，不然会阻塞主线程。而执行完网络请求等耗时操作后通常需要更新UI，如果在子线程中更新UI，那么程序会崩溃。因为Android的UI是线程不安全的。 在Android中使用Rxjava，还要配合RxAndroid来使用，RxAndroid 内部就使用 Handler 来实现线程切换。 常见错误常见的子线程中更新UI,复现代码,更具体见 Android子线程和更新UI问题1234567textView = (TextView) findViewById(R.id.txt); new Thread(new Runnable() &#123; public void run() &#123; SystemClock.sleep(3000);//这句不加不会报错，具体分析见上面链接 textView.setText("from来自子线程"); &#125; &#125;).start(); 运行异常信息1234567891011121314ErrorInfo: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6903) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1050) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.widget.TextView.checkForRelayout(TextView.java:7368) at android.widget.TextView.setText(TextView.java:4480) at android.widget.TextView.setText(TextView.java:4337) at android.widget.TextView.setText(TextView.java:4312) 可以看到错误发生在android.view.ViewRootImpl#checkThread123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 可见此处会判断mThread是不是等于当前线程看下mThread到底是啥，在何处赋值的 12345public ViewRootImpl(Context context, Display display) &#123; ... mThread = Thread.currentThread(); ...&#125; 在构造方法中被赋值的，也就是说是创建ViewRootImpl时所在的线程ViewRootImpl又是在哪里被创建的呢?这里不深入讲了，是在main线程更具体的异常分析可以参考这个 基础用法1234567891011121314151617181920212223242526android.os.Handler handler = new Handler()&#123;//在主线程中获取handler @Override public void handleMessage(final Message msg) &#123; //这里接受并处理消息 &#125;&#125;;new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000);//子线程中执行耗时操作 //发送消息 Message message = Message.obtain(); message.what=1; message.obj=new Object(); handler.sendMessage(message); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start();new Handler().post(new Runnable() &#123; @Override public void run() &#123; //doSomething &#125;&#125;); 实例化一个 Handler 重写handleMessage方法 ，然后在需要的时候调用它的 send 以及 post系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档） 但是我们并没有看到Handler是如何与MessageQueue以及Looper关联起来的，下面我们进入源码分析下 Handler 源码分析Handler 实例化从构造函数开始,我们通常从主线程中创建,先看下Handler的构造函数有哪些 Handler() Handler(Callback callback) Handler(Looper looper) Handler(Looper looper, Callback callback) Handler(boolean async) Handler(Callback callback, boolean async) Handler(Looper looper, Callback callback, boolean async) 看最后两个构造方法就行，因为前面的几个也是依次调用到后的方法 先看Handler(Callback callback, boolean async) 123456789101112public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; Handler(Looper looper, Callback callback, boolean async)与上面的区别就是Looper是赋值进去的。 Looper 实例化由上面可以看到调用Looper#myLooper方法获取到Looper对象， 如果mLooper == null的话，会抛出异常 Can’t create handler inside thread that has not called Looper.prepare() 这个错误我们应该也见过。实际上我们在实例化 Handler 的时候 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 Looper 。我们平时一般不会遇到这个错，因为我们大多数都是在主线程创建Handler的，而为什么在主线程就不要自己创建Looper，我们待会再看，目前只需要知道如果Looper.myLooper()没有获取到Looper对象的话就会报这个错。 我们跟踪Looper#myLooper方法进去，解决为什么会抛出这个异常。123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 只有一行代码，从线程中取出Looper对象，那么我们有理由相信，这个ThreadLocal是通过set方法把Looper对象设置进去的。关于ThreadLocal，参考ThreadLocal 源码分析。 想一想ThreadLocal在哪里把Looper对象设置进去了呢。回到刚才想要解决的问题：Can’t create handler inside thread that has not called Looper.prepare() 。那会不会是Looper的prepare方法呢？ 12345678910public static void prepare() &#123; prepare(true); &#125;//调用私有构造方法 private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; ThreadLocal确实是在Looper#prepare方法里把Looper对象设置进去的，而且从第一行的判断可以知道，一个线程只有一个Looper对象。 所以，要创建Handler,那么Looper.myLooper()就必须非空，上面分析得出要非空，要先调用Looper.prepare()。 到了这里，Looper与ThreadLocal建立起了关联。 MessageQueue 实例化接着上面继续看下Looper的构造方法 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个MessageQueue，相比于 Looper 和Handler，MessageQueue就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。可以在 android_os_MessageQueue 查看其源码的定义。更多参考MessageQueue 的实例化 我们接着看Handle构造函数里的 mQueue = mLooper.mQueue 我们知道消息是存放在MessageQueue消息队列中的,而MessageQueue就是在上面Looper构造函数中new出来的，至此Handler通过Looper与MessageQueue也建立起了关联。 总结一下，创建Handler,他的构造函数中会先调用Looper.myLooper()获取Looper，也即是从ThreadLocal中获取，而ThreadLocal中要想获取到，要先调用Looper.prepare()来set值，那么问题又来了，我们写程序时好像没有手动调用Looper.prepare()吧，也不会抛出异常。其实这是一个特殊情况，我们通常都是在主线程，也就是UI线程中创建handler的。而在主线程中，系统已经为我们创建了一个Looper对象，所以不会抛出异常了,而那些会抛出异常报错的情况，是在子线程中创建的Handler，但是又没有调用Looper.prepare()去创建Looper对象。继续看，主线程在什么时候创建了Looper对象吧。 在ActivityThread的main方法，这个方法是应用程序的入口。123456789101112131415161718public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; Looper.prepareMainLooper(); 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; 可以看到第一行还是调用了prepar(false）方法的(false代表不可退出)。所以主线程是已经创建了一个Looper对象的。 Handler的创建过程分析完毕，现在总算搞明白了。 Handler、MessageQueue 和 Looper 之间的关系最后再总结一下，Handler的创建是依赖于Looper的。而主线程是默认创建了一个Looper对象的。每一个Looper会关联一个线程（ThreadLocal中封装了Looper)。每一个Looper中又会封装一个消息队列。这样一来，Handler，Looper，MessageQueue，Thread四个角色就关联了起来。Handler在主线程中创建，是因为要和主线程的消息队列关联起来，那样Handler#handleMessage方法才会在主线程中执行，那么这样在更新UI就是线程安全的了。 Handler 发送消息过程回想开头我们基础用法里提到 Handler一般是通过一下2个方法发送的 handler.sendMessage(message);handler.post(runnable); 发送过程我们先从第一个开始分析 handler.sendMessage(message) 123456789101112131415161718192021public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; sendMessage会调用sendMessageDelayed方法并将message对象传进去，第二个参数是延时时间，使用sendMessage方法时默认为0的,最后都会调用sendMessageAtTime。上面分析了，在创建Looper对象的时候，会创建一个MessageQueue，所以只要Looper是正常创建的话，消息队列是不为空的。那么到最后一行的enqueueMessage方法，源码如下 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 将handler本身赋值给msg.target 然后最终调用queue.enqueueMessage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; //消息是否正在使用 msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //很明显enqueueMessage需要同步,因为存在多个线程往一个Loop线程的MessageQueue中插入消息的场景。 //这里其实是将Message根据延时插入到特定的地方，先看下关键点1，mMessages其实代表消息队列的头部，如果mMessages为空，说明还没有消息，如果当前插入的消息不需要延时，或者说延时比mMessages头消息的延时要小，那么当前要插入的消息就需要放在头部 //至于是否需要唤醒队列，则需要根据当前的Loop线程的状态来判断，后面讲Loop线程的时候再回过头说； // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; //再来看下关键点2，这个时候需要将消息插入到队列中间，其实就是找到第一个Delay事件小于当前Message的非空Message，并插入到它的前面，往队列中插入消息时，如果Loop线程在睡眠，是不应该唤醒的，异步消息的处理会更加特殊一些，先不讨论。 //最后看关键点3，如果需要唤醒Loop线程，通过nativeWake唤醒，以上，就是普通消息的插入。 // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; Messagequeue中有一个对象mMessage用于指向当前传进的msg，即最新的消息。而刚才的sendMessageAtTime(Message msg, long uptimeMillis)方法，第二个参数指定了时间，然后在这里按照这个uptimeMillis来进行消息的排序，这样每一个消息都是按照时间的排序关联了起来，排在前面的消息指向了排在后面的消息。 以上是进入消息队列的分析，Handler调用sendMessage方法的最终将message对象传进Messagequeue。 取出消息那么消息是怎么从消息队列出来的呢？这时我们要回看ActiviryThread的main方法，去寻找点线索。源码在上面已贴出。发现了倒数第二行的Looper.loop()，简单理解就是消息执行循环操作。android.os.Looper#loop 1234567891011121314151617181920212223242526272829303132public static void loop() &#123; //确保MessageQueue准备好 final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; //for 无限循环，阻塞于消息队列的 next() 方法； //不断从队列中读取消息并移除，如果队列为空，阻塞等待 Message msg = queue.next(); // might block if (msg == null) &#123;//跳出循环，looper退出就是利用了这点 // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); ... &#125; finally &#123; ... &#125; ... //清理，回收到缓存池 msg.recycleUnchecked(); &#125; &#125; loop方法是个死循环，但是为什么不会卡死主线程呢，参考 Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ Handler后传篇一: 为什么Looper中的Loop()方法不能导致主线程卡死? 深入理解 MessageQueue loop内容有点复杂，借用一张图来看下 当我们调用 Looper#loop() 方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue#next()` 方法来获取下一个消息的时候，会调用 nativePollOnce()方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从MessageQueuue中取得一个消息之后给Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper`。 再看下关键的Message msg = queue.next() 深入分析参见MessageQueue中Message消息的执行以及 MessageQueue 的消息管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108Message next() &#123; ... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //是否需要阻塞等待，第一次一定不阻塞 // 调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。 // 在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。 // 如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123;//互斥同步 // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //是否存在barier if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; //第一个消息是否需要阻塞等待，并计算出阻塞等待时间 if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. //需要无限等待 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //没有可以即刻执行的Message，查看是否存在需要处理的IdleHandler，如果不存在，则返回，阻塞等待，如果存在则执行IdleHandler if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // 如果目前没有消息，已经处在空闲状态，则执行 idler.queueIdle for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. //处理完IdleHandler ，需要重新判断Message队列 nextPollTimeoutMillis赋值为0 pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 上面分析过msg.target就是handler，所以loop循环的时候又把消息取出扔给handler#dispatchMessage方法了，我们来看下 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 由于这种方法没有传callback，所以最终调用handleMessage，我们来看下12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125; 看到这里，相信大家应该很熟悉了，这就是我们重写的方法。 我们再看看另一个发送消息的方法 handler.post(runnable)123public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 接收一个实现了Runable接口的对象，然后将其传进getPostMessage()方法。跟进getPostMessage()方法看看12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 其实就是将Runable包装成message的callback嘛。所以，如果我们使用post方法发送消息，在执行dispatchMessage的时候,callback字段是不为空的，那么就会执行handleCallback()方法，而不是执行handleMessage方法了。 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 总结我们发现不管是使用post方法还是sendMessage方法来发送消息，最终都会调用sendMessageDelayed方法。handler将消息追加到消息队列中的过程都是一样的，然后Looper不断的从MessageQueue中取出消息，并由handler去分发消息，处理消息，这样就构成了完善的Android消息机制体系。 Handler扩展Handler 虽然简单易用，但是要用好它还是需要注意一点。 由于Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。 常见内存泄漏Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity会泄露。 这个泄露是因为Message会持有Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。 解决该问题的最有效的方法是：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息。 示例代码如下： 12345678910111213141516private static class SafeHandler extends Handler &#123; private WeakReference&lt;HandlerActivity&gt; ref; public SafeHandler(HandlerActivity activity) &#123; this.ref = new WeakReference(activity); &#125; @Override public void handleMessage(final Message msg) &#123; HandlerActivity activity = ref.get(); if (activity != null) &#123; activity.handleMessage(msg); &#125; &#125;&#125; 并且再在 Activity.onDestroy() 前移除消息，加一层保障： 12345@Overrideprotected void onDestroy() &#123; safeHandler.removeCallbacksAndMessages(null); super.onDestroy();&#125; 这样双重保障，就能完全避免内存泄露了。 注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。 Handler 里的 Callback 用处在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？ 来看看 Handler.dispatchMessage(msg) 方法： 1234567891011121314public void dispatchMessage(Message msg) &#123; //这里的 callback 是 Runnable if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 可以看到 Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。 这个就很有意思了，这有什么作用呢？ 我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！ 场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。 创建 Message 实例的最佳方式由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。 方法有二： 通过 Message 的静态方法 Message.obtain(); 获取； 通过 Handler 的公有方法 handler.obtainMessage(); 。 妙用 Looper 机制我们可以利用 Looper 的机制来帮助我们做一些事情： 将 Runnable post 到主线程执行 Activity.runOnUiThread(Runnable) 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125; View.post(Runnable) 12345678910public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; //直接通过handler发送Post消息 return attachInfo.mHandler.post(action); &#125; //先加入队列,等attachInfo被赋值时,会通过handler发送消息. getRunQueue().post(action); return true;&#125; 利用 Looper 判断当前线程是否是主线程 123456789101112131415161718public final class MainThread &#123; private MainThread() &#123; &#125; private static final Handler HANDLER = new Handler(Looper.getMainLooper()); public static void run(@NonNull Runnable runnable) &#123; if (isMainThread()) &#123; runnable.run(); &#125;else&#123; HANDLER.post(runnable); &#125; &#125; public static boolean isMainThread() &#123; return Looper.myLooper() == Looper.getMainLooper(); &#125;&#125; Looper 和 Handler 一定要处于一个线程吗？子线程中可以用 MainLooper 去创建 Handler吗？Looper 和Handler 不需要再一个线程中，默认的情况下会从ThreadLocal中取当前线程对应的 Looper，但我们可以通过显式地指定一个 Looper的方式来创建Handler. 比如，当我们想要在子线程中发送消息到主线程中，那么我们可以 1Handler handler = new Handler(Looper.getMainLooper()); 子线程中进行UI操作的方法 Handler的post()方法 View的post()方法 Activity的runOnUiThread()方法 如何理解Handler的异步参见Handler后传篇二: 该如何理解Handler的”异步”？ MessageQueue.next() 会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？ MessageQueue.next() 方法内部的原理？调用 MessageQueue.next() 方法的时候会调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。 当我们加入消息的时候，会调用 MessageQueue.enqueueMessage() 方法，添加完 Message 后，如果消息队列被阻塞，则会调用 Native 层的 nativeWake() 方法去唤醒。它通过向管道中写入一个消息，结束上述阻塞，触发上面提到的 nativePollOnce() 方法返回，好让加入的 Message 得到分发处理。 MessageQueue.enqueueMessage() 使用 synchronized 代码块去进行同步。 资料：Android 中的 Handler 的 Native 层研究 Looper 的退出方法？ quit() 和 quitSafely() 有什么区别子线程中创建了 Looper，在使用完毕后，终止消息循环的方法？quit() 和 quitSafely() 的本质是什么？ quit() 和 quitSafely()的本质就是让消息队列的 next() 返回 null，以此来退出Looper.loop()。quit() 调用后直接终止 Looper，不在处理任何 Message，所有尝试把Message 放进消息队列的操作都会失败，比如 Handler.sendMessage() 会返回 false，但是存在不安全性，因为有可能有Message 还在消息队列中没来的及处理就终止Looper了。quitSafely() 调用后会在所有消息都处理后再终止 Looper，所有尝试把 Message放进消息队列的操作也都会失败。 知识点汇总由前文可得出一些知识点，汇总一下，方便记忆。 Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理 在创建 Handler 之前一定需要先创建Looper Looper 有退出的功能，但是主线程的 Looper 不允许退出 异步线程的Looper 需要自己调用 Looper.myLooper().quit(); 退出 Runnable被封装进了 Message，可以说是一个特殊的 Message Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成Looper所在的线程，并不是创建 Handler 的线程 使用内部类的方式使用Handler可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类 参考Android中的消息机制Android点将台：烽火狼烟[-Handler-]Handler 都没搞懂，拿什么去跳槽啊？Android 高级面试-1：Handler 相关Android 消息机制：Handler、MessageQueue 和 Looper]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to read android framework source code in android studio]]></title>
    <url>%2Fposts%2Fca9841f5.html</url>
    <content type="text"><![CDATA[本文将记录最快捷的将framework层源码导入android studio进行源码分析的方法 获取framework源码，这里使用清华大学的镜像 123mkdir ~/WorkSpace/AOSPcd ~/WorkSpace/AOSPgit clone -b android-9.0.0_r1 https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base platform/frameworks/ --depth 1 新建out文件夹 和 frameworks 同级 12cd ~/WorkSpace/AOSP/platform/frameworksmkdir -p ./out/host/linux-x86/framework 获取idegen.jar 并复制到 out/host/linux-x86/framework 下idegen.jar 获取idegen.sh clone development 到本地 12git clone https://aosp.tuna.tsinghua.edu.cn/platform/development platform/development platform/development/tools/idegen/idegen.sh 或直接选择别人下好的idegen.shidegen.sh执行idegen.sh将会在～/WorkSpace/AOSP/platform/ 下生成android.iml 和 android.ipr 文件 打开android studio 选择android.ipr 导入工程即可]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划2019]]></title>
    <url>%2Fposts%2F397a8e26.html</url>
    <content type="text"><![CDATA[2015年12月入职的，一直在这家公司，时光如白驹过隙，一晃3年就过去了，从来没有好好静下心来回头看看。今年结了婚，有了十一，压力一下子大了一个级别，生活也瞬间过得捉襟见肘的。3年过去，自己的能力明显没有达到自己的期望，在公司这3年，怎么说呢，虽然不说虚度，但至少没有自己想象的那么努力，技术上广度我自认为还是可以的，深度就不行了，杂而不精。 希望今年不再碌碌无为，能有个质变。 2019年要努力达成的目标 ： 长10斤肉 早睡早起 每周至少运动2次 精读至少10本技术书 尽量阅读英文文档 产出至少10篇技术博客，3篇非技术博客 开源至少1个项目 Android常见组件以及目前流行框架源码至少都过一遍 参加至少1次技术沙龙 有机会去北上广深杭感受下 学会Kotlin/Flutter 并投入生产 了解，并初步使用Go 简单学习一些shell编程 工资翻一番]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
        <tag>计划</tag>
      </tags>
  </entry>
</search>
