<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Jetpack 之 LiveData]]></title>
    <url>%2Fposts%2F169f8f42.html</url>
    <content type="text"><![CDATA[LiveData 概述简介LiveData是一个可观察的数据持有者类，与常规observable不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，例如Activity，Fragment或Service。此感知确保LiveData仅更新处于活动生命周期状态的应用程序组件观察者。 注意：欲将 LiveData 组件导入您的 Android 项目，请参阅向您的项目中添加 Android 架构组件。 实例基本使用12345678910111213141516171819202122232425262728293031323334class LiveDataDemoActivity : AppCompatActivity() &#123; private lateinit var livedata: MutableLiveData&lt;String&gt; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_liva_data_demo) val observerForever = Observer&lt;String&gt; &#123; println("LiveData observeForever changed : $it") &#125; val observer = Observer&lt;String&gt; &#123; println("LiveData observe changed : $it") &#125; livedata = MutableLiveData() livedata.observeForever(observerForever) livedata.observe(this, observer) &#125; override fun onResume() &#123; super.onResume() livedata.value = "onResume" &#125; override fun onPause() &#123; super.onPause() livedata.value = "onPause" &#125; override fun onStop() &#123; super.onStop() livedata.value = "onStop" &#125; override fun onDestroy() &#123; super.onDestroy() livedata.value = "onDestroy" &#125;&#125; 打开这个Activity时日志如下 com.lingdage.androiddemo I/System.out: LiveData observeForever changed : onResumecom.lingdage.androiddemo I/System.out: LiveData observe changed : onResume 按home键之后 com.lingdage.androiddemo I/System.out: LiveData observeForever changed : onPausecom.lingdage.androiddemo I/System.out: LiveData observe changed : onPausecom.lingdage.androiddemo I/System.out: LiveData observeForever changed : onStop 重新打开应用 com.lingdage.androiddemo I/System.out: LiveData observe changed : onStopcom.lingdage.androiddemo I/System.out: LiveData observeForever changed : onResumecom.lingdage.androiddemo I/System.out: LiveData observe changed : onResume 按返回键 com.lingdage.androiddemo I/System.out: LiveData observeForever changed : onPausecom.lingdage.androiddemo I/System.out: LiveData observe changed : onPausecom.lingdage.androiddemo I/System.out: LiveData observeForever changed : onStopcom.lingdage.androiddemo I/System.out: LiveData observeForever changed : onDestroy 注意：若使用了observeForever会监听了所有生命周期方法，所以你会看到onDestroy()等生命周期函数的打印。 LiveData 是一个抽象类，我们不能直接使用。幸运的是，Google 提供了一些其简单实现，让我们来使用。 这里使用了MutableLiveData类来保存数据，它继承了LiveData，暴露了setValue、postValue方法。 1234567891011public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 结合ViewModel创建 LiveData 对象官方建议我们LiveData通常和Jetpack架构下的另一个组件ViewModel配合使用，ViewModel是一个负责为Activity或者Fragment准备和管理数据的类，同时处理和应用剩余部分的通信，注意ViewModel仅仅负责管理UI上的数据，其他都无权干涉，它和组件生命周期绑定，只有Activity结束了，它才会被销毁。 1234567891011121314public class NameViewModel extends ViewModel &#123; // 创建一个存储 String 的 LiveData 对象 private MutableLiveData&lt;String&gt; mCurrentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (mCurrentName == null) &#123; mCurrentName = new MutableLiveData&lt;String&gt;(); &#125; return mCurrentName; &#125;// ViewModel 的其余部分……&#125; 在初始状态，LiveData 对象中的数据是没有被赋值的。 注意：请务必将更新 UI 的 LiveData 对象存储在 ViewModel 对象中，而不是 activity 或 fragment。原因如下： 避免过于臃肿的 activity 和 fragment。现在这些 UI 控制器负责展示数据，而非存储数据的状态。 将 LiveData 实例从特定的 activity 或 fragment 中解耦出来，并允许 LiveData 存活过配置变更。 观测 LiveData 对象在大多数情况下，您应当在某个应用组件的 onCreate()方法中开始对 LiveData 对象的观测，原因如下： onCreate是activity创建时的第一个回调，onResume和onStart在activity生命周期内会回调多次，造成调用监听多次形成冗余。 确保activity和fragment在变成活跃状态进入started时可以尽快获得数据更新，所以要尽早开始监听。 一般而言，LiveData 只在数据变化的情况下才会将更新通知给活动状态的观测者。然而这有一个例外：观测者在从非活动状态进入活动状态的时候，也能收到更新。更进一步讲，如果观测者又一次从非活动状态进入活动状态，那么只有当数据在这期间又发生了变化，观测者才会收到更新。 如下的示例代码展示了如何开始观测一个 LiveData 对象： 1234567891011121314151617181920212223public class NameActivity extends AppCompatActivity &#123; private NameViewModel mModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 其他设置 activity 的代码…… // 获取 ViewModel mModel = ViewModelProviders.of(this).get(NameViewModel.class); // 创建用于更新 UI 的观测者 final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; mNameTextView.setText(newName); &#125; &#125;; // 将这个 activity 作为 LifecycleOwner 参数，和观测者一并传入，开始观测该 LiveData mModel.getCurrentName().observe(this, nameObserver); &#125;&#125; 在 observe()](https://developer.android.google.cn/reference/android/arch/lifecycle/LiveData.html#observe(android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Observer)) 被传入 nameObserver 参数并调用后，[onChanged() 立即被触发，用于提供 mCurrentName 所存储的数据的最新的值。如果 LiveData 对象还没有为 mCurrentName 设置一个值，那么 onChanged() 就不会被调用。 更新 LiveData 对象LiveData更改数据的方法不是public类型的，只在内部自己调用，所有这里才会使用MutableLiveData，他暴露了修改数据的公共方法。 当您已经设置好观测者的关系后，就可以更新 LiveData 对象中的数据了。如下面的例所示，用户点击按钮时所有观测者都被通知： 1234567mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String anotherName = "Naco Siren"; mModel.getCurrentName().setValue(anotherName); &#125;&#125;); 在该例中调用 setValue(T) 会导致观测者使用新的值 Naco Siren 去调用其 onChanged 方法。该例展示的是用户点击按钮的情况，但还有更多使用 setValue() 或 postValue() 的情形，比如对网络请求或者数据库完成加载做出反应：无论是哪种情况，setValue() 或 postValue() 的调用都会通知观测者去更新 UI。 注意：在主线程中，您必须调用 setValue(T) 来更新 LiveData 对象。如果代码是在工作线程中执行的，那么您可以使用 postValue(T) 来更新它。 自定义LiveData前面介绍了自带的MutableLiveData，同样也可以自己定义LiveData类。 自定义一个BatteryLiveData类继承自LiveData，通过广播去接受系统电池电量，通过setValue将数据设置给LiveData。 123456789101112131415161718192021222324public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123; private StockManager mStockManager; private SimplePriceListener mListener = new SimplePriceListener() &#123; @Override public void onPriceChanged(BigDecimal price) &#123; setValue(price); &#125; &#125;; public StockLiveData(String symbol) &#123; mStockManager = new StockManager(symbol); &#125; @Override protected void onActive() &#123; mStockManager.requestPriceUpdates(mListener); &#125; @Override protected void onInactive() &#123; mStockManager.removeUpdates(mListener); &#125;&#125; 该例所展示的价格监听器的实现包含了下列方法： 当 LiveData 有了活动状态的观测者时，其 onActive 方法被调用。这代表着您需要在这个方法中开始对股价的监听。 当 LiveData 没有任何处于活动状态的观测者时，其 onInactive 方法被调用。由于没有观测者在监听了，您就没必要让 StockManager 继续保持连接状态。 setValue(T) 方法更新 LiveData 示例的值，并把更新通知给每个处于活动状态的观测者。 您可以这样使用 StockLiveData： 12345678910public class MyFragment extends Fragment &#123; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); LiveData&lt;BigDecimal&gt; myPriceListener = ...; myPriceListener.observe(this, price -&gt; &#123; // 更新 UI &#125;); &#125;&#125; observe() 方法将 fragment 作为 LifecycleOwner 作为第一个参数。这样做是为了表明该观测者受限于该 LifecycleOwner 的生命周期 Lifecycle。因此： 如果 Lifecycle 对象并不处于活动状态，那么即使数据发生了变化，观测者也不会被通知。 当 Lifecycle 对象被销毁后，观测者也会被自动移除。 单例LiveDataLiveData 对象能感知生命周期这一点也意味着，您可以将其分享给多个 activity、fragment 和 service。为了让示例代码简单一些，您可以用单例模式这样实现 LiveData： 123456789101112131415161718192021222324252627282930313233public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123; private static StockLiveData sInstance; private StockManager mStockManager; private SimplePriceListener mListener = new SimplePriceListener() &#123; @Override public void onPriceChanged(BigDecimal price) &#123; setValue(price); &#125; &#125;; @MainThread public static StockLiveData get(String symbol) &#123; if (sInstance == null) &#123; sInstance = new StockLiveData(symbol); &#125; return sInstance; &#125; private StockLiveData(String symbol) &#123; mStockManager = new StockManager(symbol); &#125; @Override protected void onActive() &#123; mStockManager.requestPriceUpdates(mListener); &#125; @Override protected void onInactive() &#123; mStockManager.removeUpdates(mListener); &#125;&#125; 并在 fragment 中这样使用它： 12345678public class MyFragment extends Fragment &#123; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; StockLiveData.get(getActivity()).observe(this, price -&gt; &#123; // 更新 UI &#125;); &#125;&#125; MyPriceListener 示例可供多个 fragment 和 activity 观测，而 LiveData 只会在其中至少一个或多个处于可见的活动状态时，才会连接到系统服务。 和 Room 一起使用 LiveDatatodo Room 数据持久化库支持可观测的查询（observable queries），并返回 LiveData 对象。可观测的查询是数据库访问对象（Database Access Object，DAO）的一部分。 当数据库更新时，Room 会自动产生所有必要的代码来更新 LiveData 对象。在必要的时候，这些产生的代码会异步地运行在一个后台线程上。这种模式有利于保持 UI 展示的数据与数据库保持一致。欲了解更多有关 Room 和 DAO 的内容，请参阅 Room 持久化库。 Transformationstodo 有时您可能会想要在 LiveData 对象把数据更新分发给观测者之前对数据进行更改，或者想要根据另一个 LiveData 的值来返回一个不同的 LiveData 实例。LiveData 包中的 Transformations 类提供了若干辅助函数来帮助您处理这些情况。 [Transformations.map()](https://developer.android.google.cn/reference/android/arch/lifecycle/Transformations.html#map(android.arch.lifecycle.LiveData, android.arch.core.util.Function)) 把一个函数变换应用到 LiveData 对象所存储的值，并将结果向下传递。 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + " " + user.lastName&#125;); [Transformations.switchMap()](https://developer.android.google.cn/reference/android/arch/lifecycle/Transformations.html#switchMap(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;)) 与 map() 相似地，把一个函数变换应用到 LiveData 对象所存储的值，并将结果拆包后向下传递。该函数变换必须返回一个 LiveData 对象，如下例所示： 123456private LiveData&lt;User&gt; getUser(String id) &#123; ...; &#125; LiveData&lt;String&gt; userId = ...; LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) ); 您可以使用上述变换函数来在观测者的整个生命周期中传递信息。如果观测者没有监视返回的 LiveData 对象，那么变换函数的计算就不会被执行。由于变换是惰性求值的，生命周期相关的行为也会被隐式地传递，无须任何显式调用或依赖。 如果您在 ViewModel 对象中需要一个 LifeCycle 对象，那么变换可能是个更好的解决方案。譬如，假设您有一个 UI 组件来接收地址并返回其邮政编码，那么您也许会这样为该组件实现一个拿义务的 ViewModel： 1234567891011class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository; &#125; private LiveData&lt;String&gt; getPostalCode(String address) &#123; // 别这么干⬇️ return repository.getPostCode(address); &#125;&#125; 如果这么做的话，UI 组件每次调用 getPostalCode() 时都需要从之前的 LiveData 取消订阅，然后再注册新实例的订阅。更糟的是，如果 UI 组件被重建的话，它将触发一次新的对 repository.getPostCode() 的调用，而不是利用上一次调用的结果。 与之相反，您应当把邮政编码的查询实现为一个从地址输入到 LiveData 的变换，如下例所示： 12345678910111213141516class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; private final MutableLiveData&lt;String&gt; addressInput = new MutableLiveData(); public final LiveData&lt;String&gt; postalCode = Transformations.switchMap(addressInput, (address) -&gt; &#123; return repository.getPostCode(address); &#125;); public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository &#125; private void setInput(String address) &#123; addressInput.setValue(address); &#125;&#125; 在上面的例子中，postalCode 字段永不变化，因而是 public 而 final 的；postalCode 字段被定义为 addressInput 的变换，也就意味着 repository.getPostCode() 方法会在 addressInput 改变时被调用。当然，这只是有观测者的情况，如果在 repository.getPostCode() 被调用时没有活动状态的观测者，那么在添加观测者之前，计算都不会被执行。 这种机制允许应用的低级部分创建惰性求值的 LiveData 对象。一个 ViewModel 对象能轻易获得对 LiveData 对象的引用，然后在此基础上定义对其的变换。 创建新的变换todo 您的应用可能需要一大堆各不相同的变换，但它们并不是默认提供的。想要实现自己的变换，您可以使用 MediatorLiveData 类，该类监听其他 LiveData 对象并处理它们发出的事件。MediatorLiveData 正确地将其状态传递给来源的 LiveData 对象。欲了解更多有关该模式的内容，请参阅 Transformations 的文档。 MediatorLiveDataMediatorLiveData 是 LiveData 的一个子类，允许您合并多个 LiveData 数据源。当任何 LiveData 数据源对象发生改变时， MediatorLiveData 对象的观测者都会被通知。 例如，如果您在 UI 中有一个可以被本地数据库或网络更新的 LiveData 对象，那么您可以将下列数据源添加到 MediatorLiveData 对象： 一个与数据库中的数据关联的 LiveData 对象 一个与从网络获取的数据关联的 LiveData 对象 您的 activity 只需观测 MediatorLiveData 对象来接收两个数据源的更新。欲了解更详尽的例子，请参阅应用架构指南中的“附录：显示网络状态”。 todo 欲了解更多有关和 Snackbar 信息、导航事件等一同使用 LiveData 的内容，请参阅该博客。 源码分析LiveData#observe123456789101112131415161718192021private SafeIterableMap&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; mObservers = new SafeIterableMap&lt;&gt;(); @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread("observe"); if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper); &#125; 我们调用observer()时，传递了两个参数，第一个是LifecycleOwner接口实例，而我们继承的AppCompatActivity的父类就已经实现了这个接口，所以我们传this即可；第二个参数Observer就是我们观察的回调。 先判断是不是主线程,不是就抛异常,然后通过 owner.getLifecycle().getCurrentState() 获取状态，判断是否已经被销毁，如果已经被销毁，直接返回(因为已经说过只对处于活跃状态的组件做更新)； 接着将owner和observer构造成LifecycleBoundObserver实例，这是一个内部类，里面有关于状态变换的一系列操作，待会详细分析； 然后将observer和wrapper存入map缓存中，如果observer缓存已存在并且已经和另一个LifecycleOwner绑定，则抛出异常；如果缓存已经存在则直接忽略； 即一个 Observer 实例，只能绑定一个 LifecycleOwner，而一个 owner 可以绑定多个 Observer 实例； 最后调用addObserver方法将LifecycleBoundObserver实例和LifecycleOwner绑定。而addObserver是调用了LifecycleRegistry类的实现。 当 owner （Activity 或者 fragment） 生命周期变化的时候，会回调 LifecycleBoundObserver 的 onStateChanged 方法，onStateChanged 方法又会回调 observer 的 onChange 方法。 LifecycleBoundObserver123456789101112131415161718192021222324252627282930313233class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; mOwner.getLifecycle().removeObserver(this); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142private abstract class ObserverWrapper &#123; final Observer&lt;? super T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;? super T&gt; observer) &#123; mObserver = observer; &#125; abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) &#123; return false; &#125; void detachObserver() &#123; &#125; void activeStateChanged(boolean newActive) &#123; // 若新旧状态一致则忽略 if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; // 激活状态的 observer 个数从 0 到 1 if (wasInactive &amp;&amp; mActive) &#123; onActive();// 空实现，一般让子类去重写 &#125; // 激活状态的 observer 个数从 1 到 0 if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive();// 空实现，一般让子类去重写 &#125; // 激活状态，向观察者发送 LiveData 的值 if (mActive) &#123; dispatchingValue(this); &#125; &#125; &#125; 我们来看一下 LifecycleBoundObserver，继承ObserverWrapper，实现了 GenericLifecycleObserver接口。而 GenericLifecycleObserver 接口又实现了 LifecycleObserver 接口。它包装了我们外部的 observer，有点类似于代理模式。我们可以回顾下Lifecycle组件相关的内容。当组件（Fragment、Activity）生命周期变化时会通过onStateChanged()方法回调过来。 GenericLifecycleObserver#onStateChanged Activity 回调周期变化的时候，会回调 onStateChanged ，会先判断 mOwner.getLifecycle().getCurrentState() 是否已经 destroy 了，如果。已经 destroy，直接移除观察者。这也就是为什么我们不需要手动 remove observer 的原因。 如果不是销毁状态，会调用 activeStateChanged 方法 ，携带的参数为 shouldBeActive() 返回的值。而当 lifecycle 的 state 为 STARTED 或者 RESUMED 的时候，shouldBeActive 方法的返回值为 true，即表示激活。 activeStateChanged 方法中，，当 newActive 为 true，并且不等于上一次的值，会增加 LiveData 的 mActiveCount 计数。接着可以看到，onActive 会在 mActiveCount 为 1 时触发，onInactive 方法则只会在 mActiveCount 为 0 时触发。即回调 onActive 方法的时候活跃的 observer 恰好为 1，回调 onInactive 方法的时候，没有一个 Observer 处于激活状态。 当 mActive 为 true 时，会促发 dispatchingValue 方法。 123456789101112131415161718192021222324252627@SuppressWarnings("WeakerAccess") /* synthetic access */ void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; // 如果正在处理，直接返回 if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; // initiator 不为 null，调用 considerNotify 方法 if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; // 为 null 的时候，遍历所有的 obsever，进行分发 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); // 分发完成，设置为 false mDispatchingValue = false; &#125; 其中 mDispatchingValue, mDispatchInvalidated 只在 dispatchingValue 方法中使用，显然这两个变量是为了防止重复分发相同的内容。当 initiator 不为 null，只处理当前 observer，为 null 的时候，遍历所有的 obsever，进行分发 1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData); &#125; 如果状态不是在活跃中，直接返回，这也就是为什么当我们的 Activity 处于 onPause， onStop， onDestroy 的时候，不会回调 observer 的 onChange 方法的原因。 判断数据是否是最新，如果是最新，返回，不处理 数据不是最新，回调 mObserver.onChanged 方法。并将 mData 传递过去 LiveData#setValue1234567@MainThread protected void setValue(T value) &#123; assertMainThread("setValue"); mVersion++; mData = value; dispatchingValue(null); &#125; setValue 方法中，首先，断言是主线程，接着 mVersion + 1; 并将 value 赋值给 mData，接着调用 dispatchingValue 方法。dispatchingValue 传递 null，代表处理所有 的 observer。 这个时候如果我们依附的 activity 处于 onPause 或者 onStop 的时候，虽然在 dispatchingValue 方法中直接返回，不会调用 observer 的 onChange 方法。但是当所依附的 activity 重新回到前台的时候，会促发 LifecycleBoundObserver onStateChange 方法，onStateChange 又会调用 dispatchingValue 方法，在该方法中，因为 mLastVersion &lt; mVersion。所以会回调 obsever 的 onChange 方法，这也就是 LiveData 设计得比较巧妙的一个地方 同理，当 activity 处于后台的时候，您多次调用 livedata 的 setValue 方法，最终只会回调 livedata observer 的 onChange 方法一次。 LiveData#postValue123456789101112131415161718192021222324252627protected void postValue(T value) &#123; boolean postTask; // 锁住 synchronized (mDataLock) &#123; // 当前没有人在处理 post 任务 postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; // 处理完毕之后将 mPendingData 置为 NOT_SET mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125; &#125;; 首先，采用同步机制，通过 postTask = mPendingData == NOT_SET 有没有人在处理任务。 true，没人在处理任务， false ，有人在处理任务，有人在处理任务的话，直接返回 调用 AppToolkitTaskExecutor.getInstance().postToMainThread 到主线程执行 mPostValueRunnable 任务。 LiveData#observeForever1234567891011121314@MainThread public void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread("observeForever"); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; existing instanceof LiveData.LifecycleBoundObserver) &#123; throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); &#125; if (existing != null) &#123; return; &#125; wrapper.activeStateChanged(true); &#125; 因为 AlwaysActiveObserver 没有实现 GenericLifecycleObserver 方法接口，所以在 Activity o生命周期变化的时候，不会回调 onStateChange 方法。从而也不会主动 remove 掉 observer。因为我们的 obsever 被 remove 掉是依赖于 Activity 生命周期变化的时候，回调 GenericLifecycleObserver 的 onStateChange 方法。 时序图借用网上的一张图 LiveData主要涉及到的时序有三个： 在Fragment/Activity中通过LiveData.observer()添加观察者（observer()方法中的第二个参数）。 根据Fragment/Activity生命周期发生变化时，移除观察者或者通知观察者更新数据。 当调用LiveData的setValue()、postValue()方法后，通知观察者更新数据。 todoNetworkBoundResourcehttps://juejin.im/post/5cd6cef1f265da036207c669 权限https://juejin.im/post/5c106ac45188253828247da6 总结LiveData优点1. 确保UI符合数据状态 LiveData遵循观察者模式。 当生命周期状态改变时，LiveData会向Observer发出通知。 您可以把更新UI的代码合并在这些Observer对象中。不必去考虑导致数据变化的各个时机，每次数据有变化，Observer都会去更新UI。 2. 没有内存泄漏 Observer会绑定具有生命周期的对象，并在这个绑定的对象被销毁后自行清理。 3. 不会因停止Activity而发生崩溃 如果Observer的生命周期处于非活跃状态，例如在后退堆栈中的Activity，就不会收到任何LiveData事件的通知。 4.不需要手动处理生命周期 UI组件只需要去观察相关数据，不需要手动去停止或恢复观察。LiveData会进行自动管理这些事情，因为在观察时，它会感知到相应组件的生命周期变化。 5. 始终保持最新的数据 如果一个对象的生命周期变到非活跃状态，它将在再次变为活跃状态时接收最新的数据。 例如，后台Activity在返回到前台后立即收到最新数据。 6. 正确应对配置更改 如果一个Activity或Fragment由于配置更改（如设备旋转）而重新创建，它会立即收到最新的可用数据。 7.共享资源 您可以使用单例模式扩展LiveData对象并包装成系统服务，以便在应用程序中进行共享。LiveData对象一旦连接到系统服务，任何需要该资源的Observer都只需观察这个LiveData对象。 使用 LiveData 对象步骤 LiveData基于观察者模式实现，并且和LifecycleOwner进行绑定，而LifecycleOwner又被Fragment和Activity实现，所以它可以感知生命周期；在当前的LifecycleOwner不处于活动状态（例如onPasue()、onStop()）时，LiveData是不会回调observe()的，因为没有意义. 同时LiveData只会在LifecycleOwner处于Active的状态下通知数据改变，果数据改变发生在非 active 状态，数据会变化，但是不发送通知，等 owner 回到 active 的状态下，再发送通知； LiveData在DESTROYED时会移除Observer，取消订阅，不会出现内存泄漏 postValue在异步线程，setValue在主线程 如果LiveData没有被observe()，那么此时你调用这个LiveData的postValue(…)/value=…，是没有任何作用 参考官方文档:LiveData 概览 Jetpack源码解析—LiveData的使用及工作原理 Android livedata 源码解剖 Android源码解析-LiveData]]></content>
      <tags>
        <tag>Jetpack</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack 之 Lifecycle]]></title>
    <url>%2Fposts%2F5a4b1e7b.html</url>
    <content type="text"><![CDATA[Lifecycle 概述Google官方向我们推出了 Android Architecture Components,其中谈到Android组件处理生命周期的问题，向我们介绍了 Handling Lifecycles。同时，如何利用 android.arch.lifecycle 包提供的类来控制数据、监听器等的 lifecycle。同时，LiveData 与 ViewModel 的 lifecycle 也依赖于Lifecycle框架。不久前， Android Architecture Components 正式Release，Lifecycle也正式植入进了SupportActivity（AppCompatActivity的基类）和Fragment中。 简介Lifecycle 是一个存储某组件（如 acitivity 或 fragment）生命周期状态的信息的类，并且它还允许其他对象观察这个状态。从而在外部实现监听，能够使我们及时根据组件的生命周期变化做出相应动作，比如释放资源等，从而避免内存泄露和程序崩溃。 在开发应用时，我们可能会基于一系列的生命周期实现某种功能。之前一种常见的模式是在 acitivity 和 fragment 的生命周期方法中实现相关组件（dependent components）的行为，然而这种模式会导致混乱的代码和激增的错误。见下面的demo。 1234567891011121314151617181920212223242526272829303132333435363738class MyPresenter&#123; public MyPresenter() &#123; &#125; void create() &#123; //do something &#125; void start() &#123; //do something &#125; void destroy() &#123; //do something &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyPresenter presenter; @Override public void onCreate(...) &#123; presenter= new MyPresenter (); presenter.create(); &#125; @Override public void onStart() &#123; super.onStart(); presenter.start(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); presenter.destory(); &#125;&#125; 尽管这个例子看起来没什么问题，但在一个真实的应用中，您会发现最后有太多更新 UI 和其他组件相应当前生命周期状态的调用了。为了管理多个组件，您不得不向 onStart() 和 onStop() 等生命周期方法中添加大量的代码，这样就很难维护。 更糟的是，没人能保证这些组件会在 activity 或 fragment 停止前开始，尤其是在需要执行耗时较长的操作时，例如 onStart() 中的某些配置检查。这就会出现竞争情况（race condition），导致 onStop() 方法提前于 onStart() 结束，从而使这些组件存活得过久。 1234567891011121314151617181920212223242526class MyActivity extends AppCompatActivity &#123; private MyPresenter presenter; @Override public void onCreate(...) &#123; presenter= new MyPresenter (); presenter.create(); &#125; @Override public void onStart() &#123; super.onStart(); Util.checkUserStatus(result -&gt; &#123; // what if this callback is invoked AFTER activity is stopped? if (result) &#123; presenter.start(); &#125; &#125;); &#125; @Override public void onDestroy() &#123; super.onDestroy(); presenter.destory(); &#125;&#125; 为了复用，也为了不让应用组件变得很臃肿，实现该功能时会选择与生命周期组件解藕，独立成一种组件。这样能够很方便地在应用组件中使用，比如：Activity、Fragment 或 Service。 Android 官方把它叫做 lifecycle-aware 组件，这类组件会根据其他组件（例如 activity 和 fragment）的生命周期的状态改变而做出反应，从而帮助您编写更有条理、轻量且易于维护的代码。 通过使用能感知生命周期的组件，您就能将相关组件的代码从生命周期方法中移出到这些组件自身中去。 为了方便开发者创建 lifecycle-aware 组件，android.arch.lifecycle 包提供了让您构建能感知生命周期的组件的类和接口。 注意：欲将 android.arch.lifecycle 导入到您的 Android 项目中，请参阅为您的项目添加 Android 架构组件。 Android 框架中定义的大部分应用组件都附有相应的生命周期，而生命周期则是由操作系统、或是您的进程中运行的框架代码来管理。它们对于 Android 的正常工作来说是至关重要的，因此您的应用必须尊重其规律，否则就可能导致内存泄漏、甚至应用崩溃。 Demo Prestener继承LifecycleObserver接口 12345678910111213141516171819202122232425262728293031323334353637public interface IPresenter implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onLifecycleChanged(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event);&#125;public class BasePresenter implements IPresenter &#123; private static final String TAG = "BasePresenter"; @Override public void onLifecycleChanged(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event) &#123; &#125; @Override public void onCreate(@NotNull LifecycleOwner owner) &#123; Log.d(TAG, "BasePresenter.onCreate" + this.getClass().toString()); &#125; @Override public void onDestroy(@NotNull LifecycleOwner owner) &#123; Log.d(TAG, "BasePresenter.onDestroy" + this.getClass().toString()); &#125;&#125;public class MainPresenter extends BasePresenter &#123; //...&#125; 这里我直接将我想要观察到Presenter的生命周期事件都列了出来，然后封装到BasePresenter中，这样每一个BasePresenter 的子类都能感知到Activity容器对应的生命周期事件，并在子类重写的方法中，对应相应行为。 在Activity/Fragment中添加Observer 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private IPresenter mObserver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d("tag", "onCreate" + this.getClass().toString()); setContentView(R.layout.activity_main); mObserver = new MainPresenter(this); getLifecycle().addObserver(mObserver);//添加LifecycleObserver &#125; @Override protected void onDestroy() &#123; Log.d("tag", "onDestroy" + this.getClass().toString()); super.onDestroy(); &#125;&#125; 如此，每当Activity发生了对应生命周期改变，Presenter就会执行对应事件注解的方法，只要通过注解进行声明，就能够使LifecycleObserver观察到对应的生命周期事件。 源码分析借鉴Android 架构组件（一）——Lifecycle里的一张图进行简单的概括： 我们先将重要的这些类挑选出来： LifecycleObserver接口（生命周期观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。 LifecycleOwner接口（生命周期所有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。 Lifecycle(生命周期)：和LifecycleOwner不同的是，LifecycleOwner本身持有Lifecycle对象，LifecycleOwner通过其getLifecycle()获取内部Lifecycle对象。 State(当前生命周期所处状态)：如图所示。 Event(当前生命周期改变对应的事件)：如图所示，当Lifecycle发生改变，如进入onCreate,会自动发出ON_CREATE事件。 简单来说，LifecycleOwner 用于提供 Lifecycle，LifecycleObserver 监听 Lifecycle 的状态变化，Lifecycle 则是 Activity 或 Fragment 生命周期状态的抽象。 了解了这些类和接口的职责，接下来原理分析就简单很多了，我们来看下实际Fragment/Activity等类和上述类或接口的联系： 生命周期所有者（LifecycleOwner）123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; LifecycleOwner 是仅包含了一个方法(getLifecycle())的接口，通过@NonNull强制我们返回Lifecycle对象。 LifecycleOwner用以表示某个类拥有 Lifecycle。这唯一的 getLifecycle() 方法必须由那个类实现。另一方面，如果您试图管理的是整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。 该接口将 Lifecycle 的所有权从各自的类（如 Fragment 和 AppCompatActivity）中抽象出来，并允许用户编写与其协作的组件。任何定制的应用类都可以实现该接口。 实现了 LifecycleObserver 的接口的组件能够和实现了 LifecycleOwner 的组件无缝衔接，因为后者可以提供一个被前者注册以观察的生命周期。 如果一个库提供了需要和 Android 生命周期协调的类，我们推荐您使用能感知生命周期的组件。您的库的用户可以轻易地整合这些组件，而毋须手动地管理生命周期。 26.1.0 及更新版本的支持库里的 Fragments 和 Activity 已经实现了 LifecycleOwner 接口。 androidx.fragment.app.Fragment我们先看看androidx中的fragment中的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Fragment implements ..., LifecycleOwner &#123; LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; void performCreate(Bundle savedInstanceState) &#123; //1.先执行生命周期方法 onCreate(savedInstanceState); //...省略代码 //2.生命周期事件分发 mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); &#125; void performStart() &#123; onStart(); //... mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); &#125; void performResume() &#123; onResume(); //... mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); &#125; void performPause() &#123; //3.注意，调用顺序变了 mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); //... onPause(); &#125; void performStop() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); //... onStop(); &#125; void performDestroy() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); //... onDestroy(); &#125; &#125; 随着Fragment不同走到不同的生命周期，除了暴露给我们的生命周期方法onCreate/onStart/…./onDestroy等，同时，Fragment内部的Lifecycle对象（就是mLifecycleRegistry）还将生命周期对应的事件作为参数传给了 LifecycleRegistry#handleLifecycleEvent() 方法。这个方法分析见后文。 同时，你会发现Fragment中performCreate()、performStart()、performResume()会先调用自身的onXXX()方法，然后再调用LifecycleRegistry的handleLifecycleEvent()方法；而在performPause()、performStop()、performDestroy()中会先LifecycleRegistry的handleLifecycleEvent()方法 ，然后调用自身的onXXX()方法。 参照Android 架构组件（一）——Lifecycle文中的时序图： androidx.core.app.ComponentActivity我们再看看androidx中的ComponentActivity中的实现 12345678910111213141516public class ComponentActivity extends Activity implements LifecycleOwner,ViewModelStoreOwner, SavedStateRegistryOwner, OnBackPressedDispatcherOwner&#123; private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //... ReportFragment.injectIfNeededIn(this); //... &#125; @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125;&#125; 上面就是lifecycle相关的核心代码了，可以看到它并没有像Fragment一样在各个生命周期函数中调用mLifecycleRegistry.handleLifecycleEvent来发出事件，那么它是如何让做LifecycleObserver感受到到ComponentActivity的生命周期变化的呢？ 其实关键点就在于onCreate()方法中的ReportFragment.injectIfNeededIn(this)。 我们看下ReportFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class ReportFragment extends Fragment &#123; private static final String REPORT_FRAGMENT_TAG = "androidx.lifecycle" + ".LifecycleDispatcher.report_fragment_tag"; public static void injectIfNeededIn(Activity activity) &#123; // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125; &#125; static ReportFragment get(Activity activity) &#123; return (ReportFragment) activity.getFragmentManager().findFragmentByTag( REPORT_FRAGMENT_TAG); &#125; private ActivityInitializationListener mProcessListener; private void dispatchCreate(ActivityInitializationListener listener) &#123; if (listener != null) &#123; listener.onCreate(); &#125; &#125; private void dispatchStart(ActivityInitializationListener listener) &#123; if (listener != null) &#123; listener.onStart(); &#125; &#125; private void dispatchResume(ActivityInitializationListener listener) &#123; if (listener != null) &#123; listener.onResume(); &#125; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); &#125; @Override public void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE); &#125; @Override public void onStop() &#123; super.onStop(); dispatch(Lifecycle.Event.ON_STOP); &#125; @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; &#125; private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125; void setProcessListener(ActivityInitializationListener processListener) &#123; mProcessListener = processListener; &#125; interface ActivityInitializationListener &#123; void onCreate(); void onStart(); void onResume(); &#125;&#125; ReportFragment代码很简单，重写生命周期函数，并调用dispatch(Lifecycle.Event event)方法，来分发生命周期事件，这就是“生命周期感知能力”的来源。向 Activity 注册一个无 UI 的 Fragment 也叫 Headless Fragment 用于将各种 Activity 回调分离出来是个常用的做法，比如权限请求库 RxPermission ，以及 airbnb 开源的用于URL跳转的 DeepLinkDispatch（前者是使用空的 Fragment，后者使用的是空的 Activity） Activity 的生命周期变化是如何传递到 LifecycleObserver 有了清晰的图表： 最终也是调用((LifecycleRegistry) lifecycle).handleLifecycleEvent(event)方法，和上面一样，先不分析，下文会有分析的。 android.app.Activity这是普通Activity，如果想让这个Activity定制成 LifecycleOwner，您可以使用 LifecycleRegistry 类 网上很多文章都是按下面的方法做的 1234567891011121314151617181920212223public class MyActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry lifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); lifecycleRegistry = new LifecycleRegistry(this); lifecycleRegistry.markState(Lifecycle.State.CREATED); &#125; @Override public void onStart() &#123; super.onStart(); lifecycleRegistry.markState(Lifecycle.State.STARTED); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return lifecycleRegistry; &#125;&#125; 思路就是实例化一个LifecycleRegistry，然后重写Activity生命周期函数，再通过lifecycleRegistry.markState来分发事件。 虽然通过重写 Activity 生命周期，并通过在各方法中仅添加一行lifecycleRegistry.markState（）代码就能实现生命周期的感知。但是，作为推动社会发展的“懒人” – 程序员，自然想通过更简单的方式来解放右手。办法总比困难多。 从前面我们知道，通过继承 AppCompactActivity 这种实现方式中核心就是向 Activity 中注入一个空的 Fragment–ReportFragment。我们能不能也通过这种方式，动态的向 Activity 中注入这个 ReportFragment 呢？ 答案是行的，而且google已经帮我们实现了。 Google 为我们提供了一个extensions库，我们需要单独引入： 1implementation 'androidx.lifecycle:lifecycle-extensions:2.0.0' 引入该库之后，我们的使用方式，就跟继承自 AppCompactActivity 基本相同，唯一的不同点就是我们需要自己实现 LifecycleOwner ，提供一个LifecycleRegistry（不要担心，一行代码，直接用现成的就好） 123456789101112131415161718192021222324public class MyActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry lifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); lifecycleRegistry = new LifecycleRegistry(this); // 不再需要手动调用 markstate方法了 //lifecycleRegistry.markState(Lifecycle.State.CREATED); &#125; @Override public void onStart() &#123; super.onStart(); // 不再需要手动调用 markstate方法了 // lifecycleRegistry.markState(Lifecycle.State.STARTED); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return lifecycleRegistry; &#125;&#125; 是不是很神奇，这是如何实现的呢，我们顺着代码反推下： 我们Command/Ctrl+鼠标左键，点击ReportFragment，会发现使用到它的有两个类：LifecycleDispatcher.java 和 ProcessLifecycleOwner.java这两个类，而这二者，就是extensions这个库下的类。 那我们就先追踪ReportFragment.injectIfNeededIn(activity)在LifecycleDispatcher.java类中的调用： 123456789101112131415161718192021class LifecycleDispatcher &#123; static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; ReportFragment.injectIfNeededIn(activity); &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; &#125; private LifecycleDispatcher() &#123; &#125;&#125; ReportFragment.injectIfNeededIn(activity) 这行代码是在 LifecycleDispatcher 的静态内部类DispatcherActivityCallback的 onActivityCreated(…) 方法中调用的。而DispatcherActivityCallback又继承自EmptyActivityLifecycleCallbacks，EmptyActivityLifecycleCallbacks是啥？它其实就是Application.ActivityLifecycleCallbacks接口的空实现类。 1234567891011121314151617181920212223242526272829class EmptyActivityLifecycleCallbacks implements Application.ActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; &#125;&#125; 继续回到上面的 LifecycleDispatcher 的源码查看，发现静态内部类 DispatcherActivityCallback 的实例化是在LifecycleDispatcher类的static方法init()中,在该方法中进行监听器的注册： 1234567891011121314class LifecycleDispatcher &#123; private static AtomicBoolean sInitialized = new AtomicBoolean(false); static void init(Context context) &#123; if (sInitialized.getAndSet(true)) &#123; return; &#125; ((Application) context.getApplicationContext()) .registerActivityLifecycleCallbacks(new DispatcherActivityCallback()); &#125; //...&#125; 这里面，就真正的看到了通过Application的registerActivityLifecycleCallbacks来注册监听器。 继续追踪LifecycleDispatcher#init(...)方法在哪调用的,就进入了ProcessLifecycleOwnerInitializer类的onCreate()方法： 123456789public class ProcessLifecycleOwnerInitializer extends ContentProvider &#123; @Override public boolean onCreate() &#123; LifecycleDispatcher.init(getContext()); ProcessLifecycleOwner.init(getContext()); return true; &#125; //...&#125; ProcessLifecycleOwnerInitializer是继承自ContentProvider，在其 onCreate() 方法中，进行了LifecycleDispatcher 的初始化，并且也进行了ProcessLifecycleOwner 的初始化。关于ProcessLifecycleOwner，后文有介绍。 通过看源码，发现它对 ContentProvider 的各种方法都进行了空实现。其实，这里就是利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application#onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建，并判断是否已经添加过了一个空UI的 ReportFragment。若没有，就进行添加。这种设计真的是太妙了。 这里 ContentProvider 之于 Application 的作用就类似于 Headless Fragment 之于 Activity 一样，目的都是避免继承系统组件。关于 ContentProvider 的生命周期可以看 android - ContentProvider destruction/lifecycle - Stack Overflow， 我们知道，四大组件都是要在 AndroidManifest.xml 文件中进行生命的。那这个 ContentProvider 类型的 ProcessLifecycleOwnerInitializer 又是在什么时候声明的呢？ 我们找到extensions库，通过如下方式查看它的下载位置： Android Studio 切换到 Project 模式，在External Libraries中找到这个类所在的位置，右键下图箭头所指classes.jar 选择在本地显示。 在这个jar的上级目录下 有个AndroidManifest.xml 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="androidx.lifecycle.process" &gt; &lt;uses-sdk android:minSdkVersion="14" /&gt; &lt;application&gt; &lt;provider android:name="androidx.lifecycle.ProcessLifecycleOwnerInitializer" android:authorities="$&#123;applicationId&#125;.lifecycle-process" android:exported="false" android:multiprocess="true" /&gt; &lt;/application&gt;&lt;/manifest&gt; 在这里我们果真找到了声明。 这里的AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。 反推结束，我们再反过来梳理一遍： 在清单文件注册的ProcessLifecycleOwnerInitializer，这个provider在onCreate中调用了 LifecycleDispatcher.init(getContext()) LifecycleDispatcher.init(getContext())方法调用了((Application) context.getApplicationContext()).registerActivityLifecycleCallbacks(new DispatcherActivityCallback()); DispatcherActivityCallback中的onActivityCreated中调用了ReportFragment.injectIfNeededIn ; ReportFragment.injectIfNeededIn方法把ReportFragment的各个生命周期中调用了加入到我们activity中 在ReportFragment的各个生命周期中调用了它的dispatch()方法。 dispatch()调用了LifecycleRegister的handleLifecycleEvent()。 三个情况都分析完了，最后大家都是调用LifecycleRegister的handleLifecycleEvent() 所以我们接下来分析LifecycleRegistry类 而LifecycleRegistry继承自Lifecycle类 我们可以先看下Lifecycle 生命周期 (Lifecycle )123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public abstract class Lifecycle &#123; /** * Adds a LifecycleObserver that will be notified when the LifecycleOwner changes * state. * &lt;p&gt; * The given observer will be brought to the current state of the LifecycleOwner. * For example, if the LifecycleOwner is in &#123;@link State#STARTED&#125; state, the given observer * will receive &#123;@link Event#ON_CREATE&#125;, &#123;@link Event#ON_START&#125; events. * * @param observer The observer to notify. */ @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); /** * Removes the given observer from the observers list. * &lt;p&gt; * If this method is called while a state change is being dispatched, * &lt;ul&gt; * &lt;li&gt;If the given observer has not yet received that event, it will not receive it. * &lt;li&gt;If the given observer has more than 1 method that observes the currently dispatched * event and at least one of them received the event, all of them will receive the event and * the removal will happen afterwards. * &lt;/ul&gt; * * @param observer The observer to be removed. */ @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); /** * Returns the current state of the Lifecycle. * * @return The current state of the Lifecycle. */ @MainThread @NonNull public abstract State getCurrentState(); // Event 对应 activity 的各个生命周期 //ON_ANY事件可以代表前面任意一种。 //举个例子，当Activity的onCreate()生命周期方法被调用时会产生ON_CREATE事件，观察者可以监听该事件以便处理Activity此时的生命周期。 @SuppressWarnings("WeakerAccess") public enum Event &#123; ON_CREATE, //用于匹配生命周期所有者的onCreate事件. ON_START, //用于匹配生命周期所有者的onStart事件. ON_RESUME, //用于匹配生命周期所有者的onResume事件. ON_PAUSE, //用于匹配生命周期所有者的onCreate事件. ON_STOP, //用于匹配生命周期所有者的onStop事件. ON_DESTROY, //用于匹配生命周期所有者的onDestroy事件. ON_ANY //用于匹配生命周期所有者的所有事件. &#125; /** * Lifecycle states. You can consider the states as the nodes in a graph and * &#123;@link Event&#125;s as the edges between these nodes. */ @SuppressWarnings("WeakerAccess") public enum State &#123; /** * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch * any more events. For instance, for an &#123;@link android.app.Activity&#125;, this state is reached * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;@link android.app.Activity#onDestroy() onDestroy&#125; call. */ DESTROYED, /** * Initialized state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this is * the state when it is constructed but has not received * &#123;@link android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet. */ INITIALIZED, /** * Created state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached in two cases: * &lt;ul&gt; * &lt;li&gt;after &#123;@link android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call; * &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;@link android.app.Activity#onStop() onStop&#125; call. * &lt;/ul&gt; */ CREATED, /** * Started state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached in two cases: * &lt;ul&gt; * &lt;li&gt;after &#123;@link android.app.Activity#onStart() onStart&#125; call; * &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;@link android.app.Activity#onPause() onPause&#125; call. * &lt;/ul&gt; */ STARTED, /** * Resumed state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached after &#123;@link android.app.Activity#onResume() onResume&#125; is called. */ RESUMED; /** * Compares if this State is greater or equal to the given &#123;@code state&#125;. * * @param state State to compare with * @return true if this State is greater or equal to the given &#123;@code state&#125; */ public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125;&#125; Lifecycle 类表示Android应用组件的生命周期，是被观察者。这是一个抽象类，它的实现是 LifecycleRegistry 类。 Lifecycle 对象有3个方法： 添加观察者：void addObserver(LifecycleObserver observer)。 删除观察者：void removeObserver(LifecycleObserver observer)。- 获取当前状态：State getCurrentState()。 Lifecycle的2个关键方法中参数都是LifecycleObserver 所以在分析 LifecycleRegistry之前我们先看下LifecycleObserver 生命周期观察者 （LifecycleObserver）LifecycleObserver 基本介绍标记接口 LifecycleObserver 表示生命周期观察者，是 lifecycle-aware 组件。 123public interface LifecycleObserver &#123;&#125; 这个接口用来声明它的实现类是生命周期观察者 ，我们要在这个类里接收到LifecycleOwner的生命周期变化事件，然后做自身逻辑。 但当我们看到LifecycleObserver这个接口时，第一感觉是比较奇怪：这个接口竟然是空的。那我们如何去接受生命周期变化的事件呢？（通常正常的是回调接口） 其实开头就介绍过用法了，google的做法是配合注解 OnLifecycleEvent 使用，LifecycleObserver 只是起一个声明和约束作用。其内部继承数如下图： 看到这么多类似的接口，我猜或许这是因为生命周期钩子比较多，如果全都放在接口里，那么实现者需要添加很多空实现方法，可阅读性降低。 比如FullLifecycleObserver 1234567891011121314interface FullLifecycleObserver extends LifecycleObserver &#123; void onCreate(LifecycleOwner owner); void onStart(LifecycleOwner owner); void onResume(LifecycleOwner owner); void onPause(LifecycleOwner owner); void onStop(LifecycleOwner owner); void onDestroy(LifecycleOwner owner);&#125; 这个接口就将所有的生命周期函数声明了，如果我们实现这个接口，就得重写所有接口，然而我们不一定要用这么多接口。（其实你想用也用不了，这个接口不是public，我们不能实现） 我们知道用注解的话大多数是反射解析的，这就涉及到性能问题，当然使用apt可以在编译期解决这个问题。这点后文会详细分析。 如果我们不想用注解，又不想一下子实现所有的方法，可以吗？ 答案是肯定的。java8的接口default方法。而且google也鼓励我们用这种方式，那就是DefaultLifecycleObserver DefaultLifecycleObserver注意：在androidx.lifecycle.Lifecycle类的顶部注释里有一段 12345678910111213141516171819202122232425262728293031323334353637383940/** * If you use &lt;b&gt;Java 8 Language&lt;/b&gt;, then observe events with &#123;@link DefaultLifecycleObserver&#125;. * To include it you should add &#123;@code "androidx.lifecycle:common-java8:&lt;version&gt;"&#125; to your * build.gradle file. * &lt;pre&gt; * class TestObserver implements DefaultLifecycleObserver &#123; * &#123;@literal @&#125;Override * public void onCreate(LifecycleOwner owner) &#123; * // your code * &#125; * &#125; * &lt;/pre&gt; * If you use &lt;b&gt;Java 7 Language&lt;/b&gt;, Lifecycle events are observed using annotations. * Once Java 8 Language becomes mainstream on Android, annotations will be deprecated, so between * &#123;@link DefaultLifecycleObserver&#125; and annotations, * you must always prefer &#123;@code DefaultLifecycleObserver&#125;. * &lt;pre&gt; * class TestObserver implements LifecycleObserver &#123; * &#123;@literal @&#125;OnLifecycleEvent(ON_STOP) * void onStopped() &#123;&#125; * &#125; * &lt;/pre&gt; * &lt;p&gt; * Observer methods can receive zero or one argument. * If used, the first argument must be of type &#123;@link LifecycleOwner&#125;. * Methods annotated with &#123;@link Event#ON_ANY&#125; can receive the second argument, which must be * of type &#123;@link Event&#125;. * &lt;pre&gt; * class TestObserver implements LifecycleObserver &#123; * &#123;@literal @&#125;OnLifecycleEvent(ON_CREATE) * void onCreated(LifecycleOwner source) &#123;&#125; * &#123;@literal @&#125;OnLifecycleEvent(ON_ANY) * void onAny(LifecycleOwner source, Event event) &#123;&#125; * &#125; * &lt;/pre&gt; * These additional parameters are provided to allow you to conveniently observe multiple providers * and events without tracking them manually. */public abstract class Lifecycle &#123;&#125; 意思就是一旦Java 8成为Android的主流，注解将被弃用，所以介于DefaultLifecycleObserver和注解两者之间,更推荐使用 DefaultLifecycleObserver 。 使用方式如下 1implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version" 这个库里其实就一个 DefaultLifecycleObserver.java 接口类。之后我们需要 LifecycleObserver 的时候，一般实现 DefaultLifecycleObserver 接口即可（不用再去直接实现 LifecycleObserver 接口），使用方式变成了下面这样： 123456789101112131415161718192021222324252627282930313233343536class NormalActivity : Activity(), LifecycleOwner &#123; private var lifecycleRegistry: LifecycleRegistry = LifecycleRegistry(this) override fun getLifecycle(): Lifecycle &#123; return lifecycleRegistry &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_normal) lifecycle.addObserver(object : DefaultLifecycleObserver &#123; //下面的方法视自身情况选择实现 override fun onCreate(owner: LifecycleOwner) &#123; &#125; override fun onStart(owner: LifecycleOwner) &#123; &#125; override fun onResume(owner: LifecycleOwner) &#123; &#125; override fun onPause(owner: LifecycleOwner) &#123; &#125; override fun onStop(owner: LifecycleOwner) &#123; &#125; override fun onDestroy(owner: LifecycleOwner) &#123; &#125; &#125;) &#125;&#125; 可以看到，这里我们直接在覆写我们需要的生命周期对应回调方法中写入我们的逻辑代码即可。更加简洁。 LifecycleObserver 之间的转换我们在使用 LifecycleObserver时，框架内部会将其转换为GenericLifecycleObserver 或其子类。 其转换行为在类 androidx.lifecycle.Lifecycling#getCallback 中。至于这个方法何时触发，我们后续会分析。 现在先看下这个转换过程 1234567891011121314151617181920212223242526272829303132333435@NonNull static GenericLifecycleObserver getCallback(Object object) &#123; // 如果是 FullLifecycleObserver， 转换为 FullLifecycleObserverAdapter if (object instanceof FullLifecycleObserver) &#123; return new FullLifecycleObserverAdapter((FullLifecycleObserver) object); &#125; // 如果是 GenericLifecycleObserver， 不转换 if (object instanceof GenericLifecycleObserver) &#123; return (GenericLifecycleObserver) object; &#125; final Class&lt;?&gt; klass = object.getClass(); // 获取转换type, GENERATED_CALLBACK 为使用代码生成，REFLECTIVE_CALLBACK 为使用反射调用 int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; // 采用代码生成 List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); // 一个构造函数 if (constructors.size() == 1) &#123; GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; // 多个构造函数 GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; // 默认采用反射调用 return new ReflectiveGenericLifecycleObserver(object); &#125; 这个方法的本质，其实就是根据传进来的一个LifecycleObserver 对象，构造出来一个 GenericLifecycleObserver 对象(目前有四个子类:FullLifecycleObserverAdapter、SingleGeneratedAdapterObserver、CompositeGeneratedAdaptersObserver、ReflectiveGenericLifecycleObserver)，而最终构造出来的对象，就包含了我们创建的 LifecycleObserver 的所有信息，包括各种回调方法等。 当我们通过注解的方式来自定义LifecycleObserver 的时候，按照传统方式，必定要通过反射来对注解进行解析，这样就会对性能造成影响。那么如何优化呢？ 通过缓存，来避免每次都通过反射获取构造器。 通过注解处理器，在编译时对那些被@OnLifecycleEvent注解标注的普通方法，进行预处理，生成以“类名_LifecycleAdapter”命名的类，将各种回调方法直接进行逻辑转换，避免反射，进而来提高性能。 我们先看下仅用反射的情况下google是如何优化的 不引入注解处理器时，Lifecycling.getCallback(observer)返回的是ReflectiveGenericLifecycleObserver 123456789101112131415package androidx.lifecycle;class ReflectiveGenericLifecycleObserver implements GenericLifecycleObserver &#123; private final Object mWrapped; private final CallbackInfo mInfo; ReflectiveGenericLifecycleObserver(Object wrapped) &#123; mWrapped = wrapped; mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); &#125; @Override public void onStateChanged(LifecycleOwner source, Event event) &#123; mInfo.invokeCallbacks(source, event, mWrapped); &#125;&#125; 这里我们主要关注回调信息 CallbackInfo 的获取方式的代码： 1mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); 因为反射的代价是比较大的，所以又通过 ClassesInfoCache.java这个单例类，为 ReflectiveGenericLifecycleObserver 类要调用的各种方法的相关信息进行了缓存。 点进去看下它的 getInfo(...) 方法内部，是如何获取方法信息的。 123456789CallbackInfo getInfo(Class klass) &#123; // 先读取缓存 CallbackInfo existing = mCallbackMap.get(klass); if (existing != null) &#123; return existing; &#125; existing = createInfo(klass, null); return existing; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private CallbackInfo createInfo(Class klass, @Nullable Method[] declaredMethods) &#123; // 先提取父类的 CallbackInfo Class superclass = klass.getSuperclass(); Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = new HashMap&lt;&gt;(); if (superclass != null) &#123; CallbackInfo superInfo = getInfo(superclass); if (superInfo != null) &#123; handlerToEvent.putAll(superInfo.mHandlerToEvent); &#125; &#125; // 再提取接口的 CallbackInfo Class[] interfaces = klass.getInterfaces(); for (Class intrfc : interfaces) &#123; for (Map.Entry&lt;MethodReference, Lifecycle.Event&gt; entry : getInfo( intrfc).mHandlerToEvent.entrySet()) &#123; // verifyAndPutHandler 的作用是实现了接口或者覆写了父类的方法，但是添加了不同的注解事件。 verifyAndPutHandler(handlerToEvent, entry.getKey(), entry.getValue(), klass); &#125; &#125; // 最后处理类自身的注解 Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass); boolean hasLifecycleMethods = false; // 遍历方法，寻找被 OnLifecycleEvent 注解的方法 for (Method method : methods) &#123; OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation == null) &#123; continue; &#125; hasLifecycleMethods = true; // 处理参数个数，最多两个参数 Class&lt;?&gt;[] params = method.getParameterTypes(); int callType = CALL_TYPE_NO_ARG; if (params.length &gt; 0) &#123; callType = CALL_TYPE_PROVIDER; if (!params[0].isAssignableFrom(LifecycleOwner.class)) &#123; throw new IllegalArgumentException( "invalid parameter type. Must be one and instanceof LifecycleOwner"); &#125; &#125; Lifecycle.Event event = annotation.value(); if (params.length &gt; 1) &#123; callType = CALL_TYPE_PROVIDER_WITH_EVENT; if (!params[1].isAssignableFrom(Lifecycle.Event.class)) &#123; throw new IllegalArgumentException( "invalid parameter type. second arg must be an event"); &#125; if (event != Lifecycle.Event.ON_ANY) &#123; throw new IllegalArgumentException( "Second arg is supported only for ON_ANY value"); &#125; &#125; if (params.length &gt; 2) &#123; throw new IllegalArgumentException("cannot have more than 2 params"); &#125; MethodReference methodReference = new MethodReference(callType, method); verifyAndPutHandler(handlerToEvent, methodReference, event, klass); &#125; CallbackInfo info = new CallbackInfo(handlerToEvent); // 放入缓存中 mCallbackMap.put(klass, info); mHasLifecycleMethods.put(klass, hasLifecycleMethods); return info; &#125; 这里，就能看到对注解进行处理的代码了。 我们再看下另一种优化（使用注解处理器） 首先需要在项目模块中引入 1annotationProcessor "androidx.lifecycle:lifecycle-compiler:2.0.0" 引入这个之后,会自动生成xxx_LifecycleAdapter的文件,路径为 /app/build/generated/source/apt/debug/package_name/LifeObserveCustomName_LifecycleAdapter.java 我们先看下效果： 1234567891011121314151617public class LifecyclePresenter implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreateInPresenter(@NotNull LifecycleOwner owner)&#123; System.out.println("on create"); &#125;; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroyInPresenter(@NotNull LifecycleOwner owner)&#123; System.out.println("on destory"); &#125;; @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onLifecycleChangedInPresenter(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event)&#123; System.out.println("on any"); &#125;&#125; 上面的代码在引入注解处理器后，编译项目时就会在build目录下自动生成LifecyclePresenter_LifecycleAdapter 12345678910111213141516171819202122232425262728293031public class LifecyclePresenter_LifecycleAdapter implements GeneratedAdapter &#123; final LifecyclePresenter mReceiver; LifecyclePresenter_LifecycleAdapter(LifecyclePresenter receiver) &#123; this.mReceiver = receiver; &#125; @Override public void callMethods(LifecycleOwner owner, Lifecycle.Event event, boolean onAny, MethodCallsLogger logger) &#123; boolean hasLogger = logger != null; if (onAny) &#123; if (!hasLogger || logger.approveCall("onLifecycleChangedInPresenter", 4)) &#123; mReceiver.onLifecycleChangedInPresenter(owner,event); &#125; return; &#125; if (event == Lifecycle.Event.ON_CREATE) &#123; if (!hasLogger || logger.approveCall("onCreateInPresenter", 2)) &#123; mReceiver.onCreateInPresenter(owner); &#125; return; &#125; if (event == Lifecycle.Event.ON_DESTROY) &#123; if (!hasLogger || logger.approveCall("onDestroyInPresenter", 2)) &#123; mReceiver.onDestroyInPresenter(owner); &#125; return; &#125; &#125;&#125; 这样通过该依赖库,在编译期把这些标注了的方法进行预处理,然后直接回调这些方法,避免反射,进行提高性能。 我们回头看下Lifecycling.getCallback(observer)方法中是如何判断 是代码生成还是反射调用的代码 1234&gt; // 获取转换type, GENERATED_CALLBACK 为使用代码生成，REFLECTIVE_CALLBACK 为使用反射调用&gt; int type = getObserverConstructorType(klass);&gt; // todo 详细过程暂不分析 下面简要分析下&gt; 前面已经分析过，引入注解处理器后，会生成xxx_LifecycleAdapter类，因此如果我们找到这个生成类，则认为采用代码生成方式，否则采取反射调用。 我们看下关键方法 12345678private static int getObserverConstructorType(Class&lt;?&gt; klass) &#123; if (sCallbackCache.containsKey(klass)) &#123; return sCallbackCache.get(klass); &#125; int type = resolveObserverCallbackType(klass); sCallbackCache.put(klass, type); return type; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static int resolveObserverCallbackType(Class&lt;?&gt; klass) &#123; // anonymous class bug:35073837 // 匿名内部类采用反射 if (klass.getCanonicalName() == null) &#123; return REFLECTIVE_CALLBACK; &#125; // 寻找生成类 Constructor&lt;? extends GeneratedAdapter&gt; constructor = generatedConstructor(klass); if (constructor != null) &#123; // 找到生成类，则采用 GENERATED_CALLBACK sClassToAdapters.put(klass, Collections .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor)); return GENERATED_CALLBACK; &#125; // 是否有方法被 OnLifecycleEvent 注解 boolean hasLifecycleMethods = ClassesInfoCache.sInstance.hasLifecycleMethods(klass); if (hasLifecycleMethods) &#123; // 如果有方法被 OnLifecycleEvent 注解， 则采用反射 return REFLECTIVE_CALLBACK; &#125; // 如果没有找到生成类，也没有方法被 OnLifecycleEvent 注解。 我们需要去看其父类和接口，或许它们被注解，因此这里又递归调用 Class&lt;?&gt; superclass = klass.getSuperclass(); List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; adapterConstructors = null; // 如果父类实现了 LifecycleObserver if (isLifecycleParent(superclass)) &#123; if (getObserverConstructorType(superclass) == REFLECTIVE_CALLBACK) &#123; return REFLECTIVE_CALLBACK; &#125; adapterConstructors = new ArrayList&lt;&gt;(sClassToAdapters.get(superclass)); &#125; // 如果有接口继承了 LifecycleObserver for (Class&lt;?&gt; intrface : klass.getInterfaces()) &#123; if (!isLifecycleParent(intrface)) &#123; continue; &#125; if (getObserverConstructorType(intrface) == REFLECTIVE_CALLBACK) &#123; return REFLECTIVE_CALLBACK; &#125; if (adapterConstructors == null) &#123; adapterConstructors = new ArrayList&lt;&gt;(); &#125; adapterConstructors.addAll(sClassToAdapters.get(intrface)); &#125; if (adapterConstructors != null) &#123; sClassToAdapters.put(klass, adapterConstructors); return GENERATED_CALLBACK; &#125; return REFLECTIVE_CALLBACK; &#125; 因此当我们引入注解处理器后，这里将会返回GENERATED_CALLBACK Lifecycling.getCallback(observer)方法就会把我们的LifecyclePresenter对象构建成一个 SingleGeneratedAdapterObserver对象返回（因为这里只有一个构造器，如果是多个构造器的话返回CompositeGeneratedAdaptersObserver），之后的 mLifecycleObserver.onStateChanged(owner, event);其实调用的就是SingleGeneratedAdapterObserver的onStateChanged(owner, event)方法： 123456789101112131415@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public class SingleGeneratedAdapterObserver implements GenericLifecycleObserver &#123; private final GeneratedAdapter mGeneratedAdapter; SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123; mGeneratedAdapter = generatedAdapter; &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; mGeneratedAdapter.callMethods(source, event, false, null); mGeneratedAdapter.callMethods(source, event, true, null); &#125;&#125; 这里面就可以看到，它调用了内部包裹的类的callMethods(...)方法，也就是我们上面提到的LifecyclePresenter_LifecycleAdapter的callMethonds(...)方法。 综上，再看Lifecycling.getCallback(observer)方法就比较容易理解了。 如果传进来的的参数 object 是 FullLifecycleObserver 类型，就把它构造成FullLifecycleObserverAdapter 对象，并返回 如果传进来的的参数 object 是GenericLifecycleObserver类型，直接返回该对象 如果1，2都不满足，就解析该类的的构造器的Type（该类是反射获取的，还是通过注解处理器生成的）。如果是通过注解处理器生成的类来调用回调函数，就返回一个SingleGeneratedAdapterObserver/CompositeGeneratedAdaptersObserver 对象 如果以上条件都不满足，就通过反射来调用各回调函数。返回一个 ReflectiveGenericLifecycleObserver 对象 生命周期注册者 (LifecycleRegistry)我们再回到LifecycleRegistry 前面已经说过LifecycleRegistry是Lifecycle的直接子类 12345678910111213141516171819/** * An implementation of &#123;@link Lifecycle&#125; that can handle multiple observers. * &lt;p&gt; * It is used by Fragments and Support Library Activities. You can also directly use it if you have * a custom LifecycleOwner. */public class LifecycleRegistry extends Lifecycle &#123; //添加一个生命周期观察者(下文简称观察者),当生命周期所有者状态改变时将会进行通知. public void addObserver(@NonNull LifecycleObserver observer) &#123;&#125; //获取生命周期的当前状态. public State getCurrentState() &#123;&#125; //返回观察者的个数. public int getObserverCount() &#123;&#125; //设置当前状态并通知观察者. public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123;...&#125; //从观察者列表中移除指定的观察者. public void removeObserver(@NonNull LifecycleObserver observer) &#123;...&#125;&#125; 看注释知道LifecycleRegistry 本身就是一个成熟的 Lifecycle 实现类，它被实例化在Activity和Fragment中使用，如果我们需要自定义LifecycleOwner 并实现接口需要返回一个Lifecycle实例，完全可以直接在自定义LifecycleOwner中new一个LifecycleRegistry成员并返回它（简而言之就是：直接拿来用即可，上文分析普通Activity中如何实现时，就是直接用的，各位可以回头看下）。 我们先看下关于事件和状态的几个方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class LifecycleRegistry extends Lifecycle &#123; static State getStateAfter(Event event) &#123; //这个方法定义了Lifecycle.Event和这个方法定义了Lifecycle.State状态间的转化关系： switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException("Unexpected event value " + event); &#125; private static Event downEvent(State state) &#123; switch (state) &#123; case INITIALIZED: throw new IllegalArgumentException(); case CREATED: return ON_DESTROY; case STARTED: return ON_STOP; case RESUMED: return ON_PAUSE; case DESTROYED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException("Unexpected state value " + state); &#125; private static Event upEvent(State state) &#123; switch (state) &#123; case INITIALIZED: case DESTROYED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; case RESUMED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException("Unexpected state value " + state); &#125; &#125; 官方说请将 State 想象成一个图（graph）的节点（node），而 Event 就是这些节点之间的边（edge）。 状态之间的比较是根据Enum类的ordinal()值，即变量的声明顺序。值按照声明顺序递增。上图所示，左侧的INITIALIZED状态值为1，DESTROYED为0（因为这两个状态属于起始和结束时的状态，可以看作平级）；右侧RESUMED状态值为4。 由左向右状态改变为状态提升，即upEvent；由右向左状态改变为状态下降，即downEvent。通过事件传递来改变状态，从而调用生命周期回调，完成了对生命周期的控制。 接下来看下前面遗留的最关键点 handleLifecycleEvent()方法 handleLifecycleEvent()1234public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125; 123456789101112131415161718192021222324private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; // 当我们在 LifecycleRegistry 回调 LifecycleObserver 的时候触发状态变化时， // mHandlingEvent 为 true； // 添加 observer 的时候，也可能会执行回调方法，这时候如果触发了状态变化， // 则 mAddingObserverCounter != 0 if (mHandlingEvent || mAddingObserverCounter != 0) &#123; // 正在处理事件中或者正在处理添加 Observer 中 mNewEventOccurred = true; // 不需要执行 sync。 // 执行到这里的情况是：sync() -&gt; LifecycleObserver -&gt; moveToState() // 这里直接返回后，还是会回到 sync()，然后继续同步状态给 observer // we will figure out what to do on upper level. return; &#125; // 标记正在处理事件 mHandlingEvent = true; // sync() 会把状态的变化转化为生命周期事件，然后转发给 LifecycleObserver sync(); mHandlingEvent = false; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Custom list that keeps observers and can handle removals / additions during traversal. * Invariant: at any moment of time for observer1 &amp; observer2: * if addition_order(observer1) &lt; addition_order(observer2), then * state(observer1) &gt;= state(observer2), * * Invariant的规定：无论何时，先加入的observer的state值要大于后加入的observer的状态值 * 这个规定影响了sync的实现 */ private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;();private void sync() &#123; // 使用弱应用持有 LifecycleOwner，也是为了防止 Activity/Fragment 内存泄漏 LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; Log.w(LOG_TAG, "LifecycleOwner is garbage collected, you shouldn't try dispatch new events from it."); return; &#125; while (!isSynced()) &#123; // mNewEventOccurred 是为了在 observer 触发状态变化时让 backwardPass/forwardPass() // 提前返回用的。我们刚准备调他们，这里设置为 false 即可。 mNewEventOccurred = false; //参照上文Invariant的规定，先加入的observer的state值一定要大于或等于后加入的observer的state值 //那么在mObserverMap中，eldest(即队头)的state最大，newest(即队尾)的state最小。如果当前mState小于eldest的state值，说明mObserverMap中的值需要更新 // 为了维持 mObserverMap 的 Invariant，这里我们需要从队尾往前更新元素的状态 if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; // 最先添加的 observer 的状态大于当前状态，回退 backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); // 如果 mNewEventOccurred，说明在上面调用 backwardPass() 时，客户触发了状态修改 // 有新的事件发生，则放弃这次同步，延迟到下一次 if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; // 最新添加的 observer 如果状态一致，则可以乐观地表示在它之前添加的 observer 状态也是一致的 forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false; &#125; 1234567891011 // 如果所有的 observer 的状态都已经同步完，则返回 trueprivate boolean isSynced() &#123; if (mObserverMap.size() == 0) &#123; return true; &#125; // eldest 最先添加的，newest 最新添加的 State eldestObserverState = mObserverMap.eldest().getValue().mState; State newestObserverState = mObserverMap.newest().getValue().mState; // 因为我们保证队头的 state &gt;= 后面的元素的 state，所以只要判断头尾就够了 return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState; &#125; sync() 的主要作用就是把 mObserverMap 里所有元素的状态都同步为 mState。 这里分为两种情况，一种是需要回退状态（backward），另外一种则是需要前进（forward），其中 backward 代码如下： 123456789101112131415161718192021222324252627private void backwardPass(LifecycleOwner lifecycleOwner) &#123; // 使用 eldest(start) 判断是否需要回退 // 降序迭代，end -&gt; start Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; // mNewEventOccurred 判断是否有新事件分发 Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; // 回退 // 举个例子：observer.state 为 RESUMED // mState 为 CREATED // downEvent(observer.state) 为 ON_PAUSE Event event = downEvent(observer.mState); // getStateAfter(event) 为 STARTED // 最终：RESUMED -&gt; STARTED，在下一次同步中再同步为 CREATED // pushParentState 和 popParentState 则是将 state 暂存在 List 中 // 这个作用我们会在 addObserver 中讲 pushParentState(getStateAfter(event)); // 分发事件 observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125; &#125; 在看这个方法时，可以参考上面的状态图。比方说，假设当前队列里的元素都处于 CREATED。接着收到了一个 ON_START 事件，从图里面可以看出，接下来应该是要到 STARTED 状态。由于 STARTED 大于 CREATED，所以会执行 forwardPass()。forwardPass() 里面调用 upEvent(observer.mState)，返回从 CREATED 往上到 STARTED 需要发送的事件，也就是 ON_START，于是 ON_START 事件发送给了客户。 还有注意下 backwardPass() 的逻辑是将较大的状态逐步回退。为什么说是逐步呢？比如 observer.state 是 RESUMED，当前状态是 CREATED，那这里会分两次回退，分别为：RESUMED -&gt; STARTED 和 STARTED -&gt; CREATED forwardPass() 逻辑类似，则不分析了。 上图可以看到，通过 mObserverMap 最终获取到一个 ObserverWithState 类型的 observer 对象，并调用它的dispatchEvent进行事件分发 继续看ObserverWithState 它是 LifecycleRegistry 的一个静态内部类。 1234567891011121314151617static class ObserverWithState &#123; State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; //getCallback就是用来转换LifecycleObserver的 详细分析见上文 mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125; &#125; 从名称上就能看出，该类封装了 Observer 对象和 State 对象（具体就是 State 和 GenericLifecycleObserver，GenericLifecycleObserver 是个接口，继承自 LifecycleObserver），在其 dispatchEvent 方法中，最终会回调 mLifecycleObserver 的 onStateChanged(...)方法。 追踪到这里，我们知道了，Lifecycle在监听到生命周期变化之后，最终会回调 GenericLifecycleObserver# onStateChanged()方法。 到这里我们先梳理一遍流程（以Fragment为例）， Fragment实现LifecycleOwner接口，提供一个LifecycleRegistry实例 在Fragment的各个生命周期内，调用LifecycleRegistry.handleLifecycleEvent(event)方法分发生命周期event LifecycleRegistry.handleLifecycleEvent(event)会从mObserverMap取出ObserverWithState进行各种同步操作，在同步过程中，会调用ObserverWithState#dispatchEvent方法将生命周期event分发出去 handleLifecycleEvent方法会通过 getStateAfter获取当前应处的状态的下一状态，然后通过moveToState方法修改当前状态值，然后调用sync方法通知了生命周期观察者,也就是我们实现了LifecycleObserver接口的类 在sync方法中,通过对比当前状态和上一状态来完成当前State的状态更新,在forwardPass和backwardPass方法中会从mObserverMap取出ObserverWithState 元素，一个一个的同步，同步中就可以看到事件派发方法了,ObserverWithState内部类的dispatchEvent方法。 现在就剩一个问题了，mObserverMap中的元素是怎么存进去的，我有查看下mObserverMap的调用之处，发现只有一个地方，那就是addObserver方法中 123456@Override public void addObserver(@NonNull LifecycleObserver observer) &#123; // ... ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); // ... &#125; 而这个方法正好就是我们在Fragment中调用的 getLifecycle().addObserver(mObserver); 至此，总算跟我们的 MyObserver 关联上了，整个流程就连通啦。 最后再看下addObserver方法 addObserver1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public void addObserver(@NonNull LifecycleObserver observer) &#123; //todo 这段注释要再理解下 // 上文在dispatchEvent前后进行的pushParentState和popParentState就是为了解决这个问题： // 如果在onStart中注销了observer又重新注册，这时重新注册的observer初始的状态为INITIALIZED； // 而如果想执行ON_START的对应回调，需要newObserver处于CREATED状态（之前的状态因为removeObserver，不存在于mObserverMap中） // mParentStates的作用就是为newObserver提供了CREATED这个状态 // 如果不是 DESTROYED，则从 INITIALIZED 开始分发 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; // ObserverWithState 用于分发事件给 observer // ObserverWithState 里会做 Observer 的转换 ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); // 放入 map 中 ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; // isReentrance 表示是否在分发事件时新添加了 observer // 举个例子：在 observer 在 onStart() 中又调用了 addObserver() boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; // 引入 parentState, targetState 等都是为了保证列表中后加的 Observer 的状态不能大于前面的， 这样做之后，如果列表第一个和最后一个的状态和 LifecycleRegistry.mState 相等时，就说明状态同步完成了。 // 计算需要分发的状态 State targetState = calculateTargetState(observer); mAddingObserverCounter++; // 将事件逐步分发到 targetState while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; // 如果 statefulObserver.state 小于 targetState pushParentState(statefulObserver.mState); // 如果 state 为 STARTED，则 upEvent(state) 则为 ON_RESUME statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; //addObserver()主要考虑了 Reentrance 的情况，即在observer的事件分发中，又添加了新的 observer的情况。 if (!isReentrance) &#123; // we do sync only on the top level. // 当前为重入，则不进行同步 sync(); &#125; mAddingObserverCounter--; &#125; 12345678910111213private State calculateTargetState(LifecycleObserver observer) &#123; // 获取上一个添加的 observer Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer); State siblingState = previous != null ? previous.getValue().mState : null; // mParentStates 是个 List，它的添加和删除分别由 pushParentState() 和 popParentState()，它们是成对出现的，在 dispatchEvent 的前后 // 在这种 case 下，会存在 parentState：在 dispatchEvent 时，又调用了 addObserver()，即上面说的 isReentrance State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1) : null; // 这里的计算是获取更合适的状态 // 考虑以下这种 case：某个 observer 在 onStart() 中再调用 addObserver，那这个 observer 理应使用 STARTED 状态分发，而当前状态即 mState 可能是 RESUMED，再在 sync() 中进行同步 return min(min(mState, siblingState), parentState); &#125; addObserver 并不是简单的将 Observer 加入 map 中， 首先它会做上文提到的 Observer 转换。 其次需要考虑“重入问题”。 所谓的“重入问题”，就是 addObserver 会触发 Observer 生命周期函数的调用，而 Observer 在生命周期函数中又调用了 addObserver 等方法。 因此， LifecycleRegistry 用变量 mAddingObserverCounter 和 mHandlingEvent 来判断是否处于重入状态。 其他 LifecycleOnwerLifecycleServiceServiceLifecycleDispatcher 将事件派发重新推到主线程消息队列，用于保证确保回调在 Service 生命周期回调后再调用。 ProcessLifecycleOwner用于监听整个应用的前后台切换。也是利用 ActivityLifecycleCallback 监听每个 Activity 的生命周期，如果 onStop 事件后，没有监听到任意的 onStart 事件，那么 ProcessLifecycleOwner 就会认为整个应用切换到后台，同时留下一个标志。如果监听到 onStart 事件，同时检查有标志那么就会认为应用回到前台。 https://juejin.im/post/5d15bbb86fb9a07f03574e56#heading-9 https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/#ProcessLifecycleOwner] todo 其他todo 下面这段可以放到其他文章去 能感知生命周期的组件的最佳实践 尽量让您的 UI 控制器（activity 和 fragment）别什么都自己扛着。它们不应试图获取自身的数据，而是应该通过 ViewModel，并观察一个 LiveData 对象来在视图上针对变动做出反应。 尝试编写数据驱动的 UI，并让您的 UI 控制器负责在数据变化的时候更新视图、或者把用户的行为通知给 ViewModel。 将您的数据逻辑放入 ViewModel 类。ViewModel 应当充作您的 UI 控制器和应用其余部分的连接。请小心注意：获取数据（比如从网络下载）并不是 ViewModel 的责任，恰恰相反，ViewModel 应当调用合适的组件去获取数据，再将结果提供给 UI 控制器。 使用数据绑定来在您的视图和 UI 控制器之间维持整洁的接口。这有利于让您的视图更具陈述性，而且让您在 UI 控制器中只需添加最少的更新逻辑。如果您更愿意使用 Java 语言来进行数据绑定，使用诸如 Butter Knife 的库可以避免八股代码而获得更好的抽象。 如果您的 UI 很复杂，请考虑创建一个 presenter 类来处理 UI 修改。这可能会比较累人，但可以让您的 UI 组件更易于测试。 避免在您的 ViewModel 中直接引用 View 或 Activity 等 context。如果 ViewModel 比其 activity 还活得长久（比如配置变更），您的 activity 就内存泄漏了，很难被 GC 得当回收。 能感知生命周期的组件的用例能感知生命周期的组件能让许多用例中的生命周期管理变得简单。以下是几个例子： 切换地理位置更新的精度。当您的应用可见时，启动高精度的地理位置更新；当您的应用进入后台时，切换成低精度的更新。LiveData 就是一个能感知生命周期的组件，让您的应用在用户移动的时候自动更新 UI。 开始和停止视频缓冲。尽快开始视频缓冲，但把回放延迟到应用完全启动之后。您还可以使用这样的组件来在应用被销毁时停止视频缓冲。 开始和停止网络连接。当应用在前台时，开启使用网络连接的流媒体；当应用在后台时自动暂停。 暂停和恢复动画 drawable。当应用进入后台时，处理动画 drawable 的暂停；当应用回到前台时，恢复动画。 处理 onStop 事件当 Lifecycle 属于一个 AppCompatActivity 或 Fragment，Lifecycle 的状态会变为 CREATED，而 ON_STOP 事件会在 AppCompatActivity 或 Fragment 的 onSaveInstanceState() 被调用时分发。 当一个 Fragment 或 AppCompatActivity 的状态在 onSaveInstanceState() 中保存时，直到 ON_START 触发之前，其 UI 被认为是不可变动的。试图在状态保存后更改 UI 可能会导致您的应用产生不一致的导航状态，这就是为什么当应用在状态保存之后试图执行 FragmentTransaction 时，FragmentManager 会抛出异常。欲了解更多信息，请参阅 commit()。 LiveData 提供了对这种边缘情况的开箱即用的支持：如果观察者所联系的 Lifecycle 连 STARTED 都不是的话，它就不会调用该观察者。其内部实现是先调用 isAtLeast() 来决定是否要触发其观察者。 悲剧的是，AppCompatActivity 的 onStop() 是在 onSaveInstanceState() 之后调用的，这导致了一段 UI 不允许改动、但 Lifecycle 还没进入 CREATED 状态的间隙。 为了防止这样的悲剧，beta2 及更低版本的 Lifecycle 将状态标记为 CREATED 但并不分发事件，这样一来任何检查当前状态的代码都会得到真正的值，尽管直到系统调用 onStop() 之前事件都没被分发。 二次悲剧的是，这种解决方案有两个主要的问题： 在 23 及更低的 API 版本上，一个 activity 即使被另一个 activity 部分遮挡，Android 系统实际上也会保存其状态。换言之，Android 系统调用了 onSaveInstanceState()，但并不一定调用 onStop()。这导致了一个可能很长的间隙，期间观察者仍然认为生命周期是活动的，但其实 UI 状态不能改动。 任何想要把类似行为暴露给 LiveData 的类都需要实现 beta2 或更低版本的 Lifecycle 所提供的变通方案。 注意：为了让上述流程更简单、向后兼容性更好，从 1.0.0-rc1 版本开始，Lifecycle 对象会被标记为 CREATED，而 ON_STOP 会在 onSaveInstanceState() 被调用时分发、毋须等待 onStop 方法被调用。这应该不太会影响您的代码，但您仍然需要了解，因为它和 26 及更高版本的 API 中 Activity 方法的调用顺序并不一致。 以上是来自官方文档的翻译，翻译地址见参考一。 参考使用能感知生命周期的组件来处理生命周期 初学 Android 架构组件之 Lifecycle Android官方架构组件Lifecycle:生命周期组件详解&amp;原理分析 Jetpack中的Lifecycle Android arch components 源码分析（2）—— Lifecycle Android Architecture Component – Lifecycle 浅析 生命周期组件 Lifecycle 源码解析（一） 生命周期组件 Lifecycle 源码解析（二） Android架构之美-Lifecycle]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack 之 ViewModel]]></title>
    <url>%2Fposts%2Fba81e3d7.html</url>
    <content type="text"><![CDATA[ViewModel 概览简介ViewModel是一种被设计为通过能感知生命周期的方式来存储和管理 UI 相关的数据的类。它让数据能存活过配置变更（如屏幕旋转）而不被杀死。 定义ViewModel 是一个抽象类，类中只定义了一个空实现的 onCleared() 方法。 1234567891011public abstract class ViewModel &#123; /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings("WeakerAccess") protected void onCleared() &#123; &#125;&#125; ViewModel 里面不要引用 View、或者任何持有 Activity 类的 context , 否则会引发内存泄漏问题。 当 ViewModel需要 Application 类的 context 来获取资源、查找系统服务等，可以继承 AndroidViewModel类。 1234567891011121314151617public class AndroidViewModel extends ViewModel &#123; @SuppressLint("StaticFieldLeak") private Application mApplication; public AndroidViewModel(@NonNull Application application) &#123; mApplication = application; &#125; /** * Return the application. */ @NonNull public &lt;T extends Application&gt; T getApplication() &#123; //noinspection unchecked return (T) mApplication; &#125;&#125; ViewModel 使用demo看下源码中的一个例子 1234567891011121314151617181920public class UserActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.user_activity_layout); final UserModel viewModel = ViewModelProviders.of(this).get(UserModel.class); viewModel.userLiveData.observer(this, new Observer&lt;User&gt;() &#123; @Override public void onChanged(@Nullable User data) &#123; // update ui. &#125; &#125;); findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; viewModel.doAction(); &#125; &#125;); &#125;&#125; 12345678910public class UserModel extends ViewModel &#123; public final LiveData&lt;User&gt; userLiveData = new LiveData&lt;&gt;(); public UserModel() &#123; // trigger user load. &#125; void doAction() &#123; // depending on the action, do necessary business logic calls and update the // userLiveData. &#125;&#125; 源码分析上面已经看过了ViewModel的源码，很简单，就是一个抽象类，还有一个onCleared()方法 接下来看下获取ViewModel的代码 ViewModelProviders.of(this).get(UserModel.class) ViewModelProvidersViewModelProviders 类提供了4个静态工厂方法 of() 创建新的 ViewModelProvider 对象。 1234ViewModelProviders.of(Fragment) ViewModelProviders.of(FragmentActivity)ViewModelProviders.of(Fragment, Factory) ViewModelProviders.of(FragmentActivity, Factory) 12345678@MainThreadpublic static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) &#123; Application application = checkApplication(checkActivity(fragment)); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(fragment.getViewModelStore(), factory);&#125; 123456789@MainThreadpublic static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(activity.getViewModelStore(), factory);&#125; ViewModelProviderViewModelProvider 负责提供 ViewModel 对象 123456789101112public class ViewModelProvider &#123; public interface Factory &#123; &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass); &#125; private final Factory mFactory; private final ViewModelStore mViewModelStore; //...省略其他无关代码&#125; Factory 接口定义了一个创建 ViewModel 的接口 create()，ViewModelProvider 在需要时调用该方法新建 ViewModel 对象。 Android 已经内置了2个 Factory 实现类，分别是： AndroidViewModelFactory 实现类，可以创建 ViewModel 和 AndroidViewModel 子类对象。 NewInstanceFactory 类，只可以创建 ViewModel 子类对象。 它们的实现都是通过反射机制调用 ViewModel 子类的构造方法创建对象。 12345678910111213public static class NewInstanceFactory implements Factory &#123; @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.newInstance(); &#125; catch (InstantiationException e) &#123; throw new RuntimeException("Cannot create an instance of " + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException("Cannot create an instance of " + modelClass, e); &#125; &#125;&#125; AndroidViewModelFactory 继承 NewInstanceFactory 类，是个单例，支持创建 AndroidViewModel 子类对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory &#123; private static AndroidViewModelFactory sInstance; /** * Retrieve a singleton instance of AndroidViewModelFactory. * * @param application an application to pass in &#123;@link AndroidViewModel&#125; * @return A valid &#123;@link AndroidViewModelFactory&#125; */ @NonNull public static AndroidViewModelFactory getInstance(@NonNull Application application) &#123; if (sInstance == null) &#123; sInstance = new AndroidViewModelFactory(application); &#125; return sInstance; &#125; private Application mApplication; /** * Creates a &#123;@code AndroidViewModelFactory&#125; * * @param application an application to pass in &#123;@link AndroidViewModel&#125; */ public AndroidViewModelFactory(@NonNull Application application) &#123; mApplication = application; &#125; @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; if (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.getConstructor(Application.class).newInstance(mApplication); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException("Cannot create an instance of " + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException("Cannot create an instance of " + modelClass, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException("Cannot create an instance of " + modelClass, e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException("Cannot create an instance of " + modelClass, e); &#125; &#125; return super.create(modelClass); &#125;&#125; ViewModelStore再看下实例化ViewModelProvider中还需要的ViewModelStore对象 ViewModelStore 类中维护一个 Map&lt;String, ViewModel&gt; 对象存储已创建的 ViewModel 对象，并提供 put() 和 get() 方法。 12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear(); &#125;&#125; 而这个ViewModelStore通过之前的代码知道，是通过传入的Fragment/FragmentActivity中拿,这2个类都实现了ViewModelStoreOwner 接口，返回当前 UI 作用域里的 ViewModelStore 对象。 ViewModelStoreOwner123456789public interface ViewModelStoreOwner &#123; /** * Returns owned &#123;@link ViewModelStore&#125; * * @return a &#123;@code ViewModelStore&#125; */ @NonNull ViewModelStore getViewModelStore();&#125; 实现如下： androidx.fragment.app.Fragment#getViewModelStore 12345678910@Overridepublic ViewModelStore getViewModelStore() &#123; if (getContext() == null) &#123; throw new IllegalStateException("Can't access ViewModels from detached fragment"); &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; return mViewModelStore;&#125; androidx.fragment.app.FragmentActivity#getViewModelStore 1234567891011121314151617181920private ViewModelStore mViewModelStore;public ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException("Your activity is not yet attached to the " + "Application instance. You can't request ViewModel before onCreate call."); &#125; if (mViewModelStore == null) &#123; NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; &#125; return mViewModelStore;&#125; 获取ViewModel1final UserModel viewModel = ViewModelProviders.of(this).get(UserModel.class); ViewModelProviders.of(this)上面已经分析过了，这个方法返回一个ViewModelProvider实例，然后通过get()方法获取ViewModel 12345678@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels"); &#125; return get(DEFAULT_KEY + ":" + canonicalName, modelClass);&#125; 12345678910111213141516171819@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 如果在 ViewModelStore 里不存在，则使用 Factory 创建一个新的对象并存放到 ViewModelStore 里。 以上便是 ViewModel 创建和获取的主要过程 通过 ViewModelProviders 创建 ViewModelProvider 对象，调用该对象的 get() 方法获取 ViewModel 对象。 当 ViewModelStore 里不存在想要的对象，ViewModelProvider 会使用 Factory 新建一个对象并存放到 ViewModelStore 里。 注：老版本的实现源码分析参见Android Jetpack之ViewModel ViewModel 总结Configuration Changes 存活原理https://juejin.im/post/5beccf0a5188251e1f50c574#heading-12 总结里还有一段 销毁过程 androidx.fragment.app.FragmentActivity#onDestroy 12345678910@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (mViewModelStore != null &amp;&amp; !isChangingConfigurations()) &#123; mViewModelStore.clear(); &#125; mFragments.dispatchDestroy();&#125; androidx.fragment.app.Fragment#onDestroy 123456789@CallSuperpublic void onDestroy() &#123; mCalled = true; FragmentActivity activity = getActivity(); boolean isChangingConfigurations = activity != null &amp;&amp; activity.isChangingConfigurations(); if (mViewModelStore != null &amp;&amp; !isChangingConfigurations) &#123; mViewModelStore.clear(); &#125;&#125; 先判断是否有发生 Configuration Changes，如果没有则会调用 ViewModelStore 的 clear() 方法，再一一调用每一个 ViewModel 的 onCleared() 方法。 123456public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear();&#125; 生命周期ViewModel 对象被限定为在获取自己时传入 ViewModelProvider的 Lifecycle。在这个 Lifecycle 永久死去之前，ViewModel 都将留存在内存中：比如 activity 的 finish，或者 fragment 的 detach。 下图展示了一个 activity 在旋转和结束的过程中所经历的各种生命周期状态，以及与其关联的 ViewModel的生命周期。而同样的基本状态也适用于 fragment 的生命周期。 一般而言，您可以在系统第一次调用某个 activity 对象的 onCreate() 方法时请求特定的 ViewModel。系统可能会在整个 activity 的生命中多次调用 onCreate() 方法，例如当设备的屏幕旋转时。ViewModel 从您第一次请求它开始存在，直到 activity 被结束并销毁。 用途 在 Android 中，Activity 和 Fragment 这类 UI 组件会被系统销毁或重建，未特殊处理的 UI 数据将会丢失。以往处理这类问题时，会使用 onSaveInstanceState() 保存 UI 数据，在 onCreate() 方法里恢复 UI 数据（通常还要保证其正确的序列化），但是数据的大小和类型有限制(比如：List、Bitmap…) 当发生 Configuration Changes 时,可利用ViewModel恢复数据 Activity/Fragment经常需要进行一些异步操作。一旦涉及到异步，我们都明白这里存在内存泄漏的可能性。因此我们保证Activity/Fragment在销毁后及时清理异步操作，以避免潜在的内存泄漏。 ViewModel并没有自动帮我们解决这个问题，而是通过onCleared()交给我们业务自己重写去处理。 当 ViewModel 所在的 UI 组件被真正销毁时，它的 onCleared() 方法会被调用，可以覆盖该方法清理资源。 Fragment可以通过宿主Activity共享ViewModel来处理通信问题。 在FragmentActivity中ViewModelStore 提供的 ViewModel可以存活至 FragmentActivity销毁。 因此不同的Fragment实例，可以直接通过传入FragmentActivity，拿到同样的ViewModel实例，进而实现数据通讯。 其他生命周期管理库 (Lifecycles) 由三个组件构成，包括 Lifecycle、LiveData 和 ViewModel。它可以用来解决常见的生命周期问题，同时使您的应用程序易于测试且可维护。 推荐开发者同时使用 ViewModel 和另一个生命周期组件 LiveData 来实现响应式的 UI 界面。 注意事项：不要在 ViewModel 中引用 View，使用 LiveData 来通知界面更新；不要混淆 ViewModel 和 onSaveInstanceState 方法的用途。 配合Dagger/Koin参见当Koin撞上ViewModel 参考ViewModel Overview 剖析 Android 架构组件之 ViewModel 一点点入坑JetPack：ViewModel篇]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstrainLayout 基础教程]]></title>
    <url>%2Fposts%2F1352bf96.html</url>
    <content type="text"><![CDATA[简介继承关系 java.lang.Object ↳ ViewGroup ↳ androidx.constraintlayout.widget.ConstraintLayout ConstraintLayout继承自ViewGroup,是一个Support库，意味着向前兼容，它可以兼容至API 9，也就是Android 2.3，鉴于现在市场上手机基本都是2.3及以上的，所以如果不是特殊情况，开发者可以不用考虑版本问题。 特性详解Relative positioning (相对定位)相对定位是在ConstraintLayout中创建布局的最基本构建块，也就是一个控件相对于另一个控件进行定位，可以从横向、纵向添加约束关系，用到的边分别有： 横向：Left、Right、Start、End 纵向：Top、Bottom、Baseline（文本底部的基准线） 根据布局中的其他元素或视图, 确定View在屏幕中的位置, 受到三类约束, 即其他视图, 父容器(parent), 基准线(Guideline). 1layout_constraint[本源位置]_[目标位置]=&quot;[目标ID]&quot; 例如: 1app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot; 约束当前View的底部至目标View的底部, 目标View是constraintLayout. 即, 把当前View的底部对齐到constraintLayout的底部. eg: 通常是一条边向另一条边添加约束，就像下面按钮B要定位在按钮A的右边一样： 12345&lt;Button android:id="@+id/buttonA" ... /&gt; &lt;Button android:id="@+id/buttonB" ... app:layout_constraintLeft_toRightOf="@+id/buttonA" /&gt; 这样系统就会知道按钮B的左侧被约束在按钮A的右侧，这里的约束可以理解为边的对齐。 上图是相对定位的约束，图中每一条边（top、bottom、baseline、left、start、right、end）都可以与其他控件形成约束，罗列这些边形成的相对定位关系如下： layout_constraintLeft_toLeftOf // 左边左对齐 layout_constraintLeft_toRightOf // 左边右对齐 layout_constraintRight_toLeftOf // 右边左对齐 layout_constraintRight_toRightOf // 右边右对齐 layout_constraintTop_toTopOf // 上边顶部对齐 layout_constraintTop_toBottomOf // 上边底部对齐 layout_constraintBottom_toTopOf // 下边顶部对齐 layout_constraintBottom_toBottomOf // 下边底部对齐 layout_constraintBaseline_toBaselineOf // 文本内容基准线对齐 layout_constraintStart_toEndOf // 起始边向尾部对齐 layout_constraintStart_toStartOf // 起始边向起始边对齐 layout_constraintEnd_toStartOf // 尾部向起始边对齐 layout_constraintEnd_toEndOf // 尾部向尾部对齐 上面的这些属性需要结合id才能进行约束，这些id可以指向控件也可以指向父容器（也就是ConstraintLayout），比如： 12&lt;Button android:id="@+id/buttonB" ... app:layout_constraintLeft_toLeftOf="parent" /&gt; Margins (外边距) 写过RelativeLayout 的朋友应该都能理解这个margin的意思, 这里就不赘述, 罗列外边距的属性如下： android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom 请注意，边距只能是正数或等于零，并设置Dimension。 goneMargin当位置约束目标的可见性为View.GONE时，您还可以使用以下属性指示要使用的不同边距值： 以上图为例，这里的goneMargin指的是B向A添加约束后，如果A的可见性变为GONE，这时候B的外边距可以改变，也就是B的外边距根据A的可见性分为两种状态。 具体值参考以下: layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom Centering positioning (居中定位)ConstraintLayout的一个有用方面是它如何处理“不可能”的约束。例如，如果我们有类似的代码： 12345&lt;androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;Button android:id="@+id/button" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 除非ConstraintLayout恰好具有与Button完全相同的大小，否则两个约束不能同时满足（双方都不能成为我们希望它们的位置）。(谷歌翻译- -) 这种情况就感觉像是控件两边有两个反向相等大小的力在拉动它一样，所以才会产生控件居中的效果。 这里说明一下：如果在居中方向上（横向或纵向）控件的尺寸和ConstraintLayout的尺寸一样，那么就无所谓居中了，此时约束的存在是没有意义的。 bias (倾向)在上面那种同向相反的约束时,效果是默认设置是使控件居中;但是您可以使用偏差属性调整定位以支持一侧而不是另一侧(像拔河一样，让两个约束的力大小不等，这样就产生了倾向), 其属性是： layout_constraintHorizontal_bias layout_constraintVertical_bias eg: 123456&lt;androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;Button android:id="@+id/button" app:layout_constraintHorizontal_bias="0.3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="paret/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 这段代码就是让左边占30%，右边占70%（默认两边各占50%），这样左边就会短一些，效果如下图所示 使用偏差，您可以制作更好地适应屏幕尺寸变化的用户界面。(百分比布局的概念) Circular positioning (圆形定位)你可以以角度和距离约束控件相对于另一个控件的中心。这允许您将控件放在圆上（参见下图）。可以使用以下属性： layout_constraintCircle : 引用另一个控件的 id layout_constraintCircleRadius : 到另一个控件中心的距离 layout_constraintCircleAngle : 控件的角度（顺时针，0 - 360 度） 12345&lt;Button android:id="@+id/buttonA" ... /&gt; &lt;Button android:id="@+id/buttonB" ... app:layout_constraintCircle="@+id/buttonA" app:layout_constraintCircleRadius="100dp" app:layout_constraintCircleAngle="45" /&gt; Visibility behavior (可见性的表现)ConstraintLayout对可见性被标记View.GONE的控件（后称“GONE控件”）有特殊的处理。一般情况下，GONG控件是不可见的，且不再是布局的一部分，但是在布局计算上，ConstraintLayout与传统布局有一个很重要的区别： 传统布局下，GONE控件的尺寸会被认为是0（当做点来处理） 在ConstraintLayout中，GONE控件尺寸仍然按其可见时的大小计算，但是其外边距大小按0计算 这种特殊的行为让我们在无需打乱布局情况下，在标记GONE控件的地方构建布局(如上图)，这样的做法对于做简单的布局动画很有用。 注意:使用的边距将是B在连接到A时定义的边距（见上图）。在某些情况下，这可能不是您想要的余量（例如A在其容器侧面有100dp的边距，B只有16dp到A，A标记为已消失，B对容器的边距为16dp）。因此，您可以指定在连接到标记为已删除的窗口小部件时要使用的备用边距值 layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom Dimensions constraints (尺寸约束)Minimum and maximum dimensions on ConstraintLayout (最大最小尺寸)ConstraintLayout本身可以定义自己的最大/最小尺寸： android:minWidth 设置布局的最小宽度 android:minHeight 设置布局的最小高度 android:maxWidth 设置布局的最大宽度 android:maxHeight 设置布局的最大高度 这些最小尺寸当ConstraintLayout被设置为WRAP_CONTENT时有效。 Widgets dimension constraints (控件尺寸约束)控件的尺寸可以通过android:layout_width和android:layout_height来设置，有三种方式： 使用固定值(文字值如123dp或 Dimension reference) 使用WRAP_CONTENT 使用0dp（相当于MATCH_CONSTRAINT） 前两种方式和其他布局的用法相同，最后一种是通过填充约束来重新设置控件的尺寸（如上图 ，(a)是wrap_content，(b)是0dp。代码案例如下： 1234&lt;Button android:layout_width="0dp" // 这里对宽度设置MATCH_CONSTRAINT，结合3、4两行实现约束 android:layout_height="wrap_content" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent"/&gt; 如果设置了边距，那么外边距就会在尺寸计算中被考虑进去 如上图（c）中的0dp） 划重点:0dp并不是类似于以前的MATCH_PARENT,它match的是约束。 如上图(b) 他的左右约束是parent,所以他设置0dp就铺满父宽度,但是(c),他的左边有个约束为margin,右边约束到parent,所以这个0dp就是从左约束(那个margin值)到最右边(parent) 重点：对于ConstraintLayout中包含的控件，不建议使用MATCH_PARENT。可以通过使用MATCH_CONSTRAINT来定义类似的行为，其中相应的左/右或上/下约束被设置为parent。 Enforcing constraints(强制约束) 此属性在1.1版本添加 在 1.1 版本之前，如果将控件的尺寸设置为了 WRAP_CONTENT，那么对控件设置约束（如：minWidth 等）是不起作用的。那么强制约束（Enforcing constraints）的作用就是，在控件被设置 WRAP_CONTENT 的情况下，使约束依然生效。 app:layout_constrainedWidth=”true|false” app:layout_constrainedHeight=”true|false” 下面的例子演示了没有设置强制约束和设置了强制约束的对比： 1234567891011121314151617181920212223&lt;ImageView android:id="@+id/imageViewA" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" android:src="@drawable/demo" app:layout_constraintTop_toTopOf="parent" android:layout_marginTop="96dp" app:layout_constrainedWidth="false" app:layout_constraintWidth_max="80dp" /&gt;&lt;ImageView android:id="@+id/imageViewB" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" android:src="@drawable/demo" app:layout_constraintTop_toBottomOf="@id/imageViewA" android:layout_marginTop="16dp" app:layout_constrainedWidth="true" app:layout_constraintWidth_max="80dp" /&gt; 如图所示,同样设置了最大宽度,imageViewB起作用,imageViewA没有起作用 MATCH_CONSTRAINT dimensions 此属性在1.1版本添加 当尺寸设置为MATCH_CONSTRAINT(０dp,默认行为是使结果大小占用所有可用空间)时。1.1版本之后，还有几个额外的修饰符： layout_constraintWidth_min and layout_constraintHeight_min : 指定当前控件的最小宽度或高度 layout_constraintWidth_max and layout_constraintHeight_max : 指定当前控件的最大宽度或高度 layout_constraintWidth_percent and layout_constraintHeight_percent : 指定当前控件的宽度或高度是父控件的百分之多少。可设置的值在 0 - 1 之间，1 就是 100% 123456789101112131415161718192021222324252627282930313233&lt;ImageView android:id="@+id/imageViewA" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:src="@drawable/demo" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;ImageView android:id="@+id/imageViewB" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:src="@drawable/demo" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/imageViewA" app:layout_constraintWidth_percent="0.5" /&gt;&lt;ImageView android:id="@+id/imageViewC" android:layout_width="0dp" android:layout_height="0dp" android:layout_marginTop="16dp" android:src="@drawable/demo" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/imageViewB" app:layout_constraintWidth_max="100dp" app:layout_constraintHeight_min="80dp" /&gt; A设置为0dp,所以铺满整个宽度 B加了个50%的百分比,所以宽度为一半 C限制了最大宽度和最小高度 效果如下图 Min and Max: 为min和max指示的值可以是dp，也可以是“wrap”(它将使用与WRAP_CONTENT相同的值) Percent dimension: To use percent, you need to set the following: The dimension should be set to MATCH_CONSTRAINT (0dp) The default should be set to percent app:layout_constraintWidth_default=&quot;percent&quot; or app:layout_constraintHeight_default=&quot;percent&quot; Then set the layout_constraintWidth_percent or layout_constraintHeight_percent attributes to a value between 0 and 1 Ratio (比例)这里的比例指的是宽高比，通过设置比例，让宽高的其中一个随另一个变化。为了实现比例，需要让控件宽或高受约束，且尺寸设置为0dp（也可以是MATCH_CONSTRAINT），eg： 1234567891011121314151617181920&lt;ImageView android:id="@+id/imageViewA" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:src="@drawable/demo" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;ImageView android:id="@+id/imageViewB" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:src="@drawable/demo" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/imageViewA" app:layout_constraintDimensionRatio="1:1"/&gt; 上图中，imageViewB的宽度满足受约束且设置为0dp的条件，所以其尺寸会按照比例随高度调整。 比例的设置有两种格式： 宽度与高度的比，可理解为受约束的一方尺寸:另一方尺寸 浮点值，表示宽度和高度之间的比率 如果宽高都设置为MATCH_CONSTRAINT（0dp），您也可以使用比率。在这种情况下，系统设置满足所有约束的最大尺寸并保持指定的纵横比。要根据另一个的尺寸约束一个特定边，可以预先附加W或H，分别约束宽度或高度。例如，如果一个尺寸受两个目标约束（例如，宽度为0dp并且以父对象为中心）你可以通过在比率前添加字母W（用于约束宽度）或H（用于约束高度）来指示哪一边应该被约束，用逗号分隔 (谷歌翻译) 1234567891011121314151617181920&lt;ImageView android:id="@+id/imageViewA" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintDimensionRatio="H,2:1"/&gt; &lt;ImageView android:id="@+id/imageViewB" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/imageViewA" app:layout_constraintBottom_toBottomOf="parent" android:layout_marginTop="32dp" app:layout_constraintDimensionRatio="W,1:3" /&gt; 如上图,imageViewA将按照2:1的宽高比设置按钮的高度，而按钮的宽度将匹配父项的约束(0dp即铺满) imageViewB将按照1:3的宽高比设置按钮的宽度，而按钮的高度将匹配父项的约束(即铺满imageViewA下面32dp到parent底部) Chain（链）链在单个轴（水平或垂直）中提供类似行的行为。另一个轴可以独立约束。 如果一组控件通过双向连接链接在一起，则它们被视为链（如下图，是最小单位的Chain，只具有两个控件）。 Chain头部横向上，Chain头部是Chain最左边的控件；纵向上，Chain头部是Chain最顶部的控件。 Chain外边距如果连接时定义了外边距，Chain就会发生变化。在SPREAD CHAIN中，外边距会从已经分配好的空间中去掉。 Chain Style(样式) 当对Chain的第一个元素设置layout_constraintHorizontal_chainStyle或layout_constraintVertical_chainStyle属性，Chain就会根据特定的样式（默认样式为CHAIN_SPREAD）进行相应变化，样式类型如下： CHAIN_SPREAD 元素被分散开（默认样式） 在CHAIN_SPREAD模式下，如果一些控件被设置为MATCH_CONSTRAINT，那么控件将会把所有剩余的空间均分后“吃掉” CHAIN_SPREAD_INSIDE Chain两边的元素贴着父容器，其他元素在剩余的空间中采用CHAIN_SPREAD模式 CHAIN_PACKED Chain中的所有控件合并在一起后在剩余的空间中居中 *Weighted chains (带权重的Chain) * 默认的Chain是在可用空间中平均分布元素。如果其中有一个或多个元素使用了MATCH_CONSTRAINT属性，那么他们会将剩余的空间平均填满。属性layout_constraintHorizontal_weight和layout_constraintVertical_weight控制使用MATCH_CONSTRAINT的元素如何均分空间。例如，一个Chain中包含两个使用MATCH_CONSTRAINT的元素，第一个元素使用的权重为2，第二个元素使用的权重为1，那么被第一个元素占用的空间是第二个元素的2倍。 When using margins on elements in a chain, the margins are additive. For example, on a horizontal chain, if one element defines a right margin of 10dp and the next element defines a left margin of 5dp, the resulting margin between those two elements is 15dp. *Margins and chains * 此属性在1.1版本添加 在链中的元素上使用边距时，边距是相加的。 例如，在水平链上，如果一个元素定义了10dp的右边距，而下一个元素定义了5dp的左边距，则这两个元素之间产生的边距为15dp。 在计算链用于定位项目的剩余空间时，会同时考虑项目及其边距。剩余空间不包含边距。 Virtual Helper objects(辅助工具)除了前面详述的内在功能之外，您还可以使用ConstraintLayout中的辅助工具来帮助您进行布局。目前，Guideline对象允许您创建相对于ConstraintLayout容器定位的水平和垂直指南。然后可以通过将小部件限制为这样的指导来定位小部件。在1.1中，也增加了Barrier和Group。 GuidelineGuideline 不会显示在设备上（它们标记为View.GONE），仅用于布局目的。它们仅在ConstraintLayout中工作。用处是帮助我们的控件增加约束。就如同Photoshop中参考线的概念一样。如下图，创建一个垂直方向的参考线，可以切换百分比，或者是实际的距离。具体用哪种还是得根据实际情况来。 Barrier很多时候我们都会遇到控件的大小随着其包含的数据的多少而改变的情况，而此时如果有多个控件之间是相互约束的话，就比较难来设定各个控件间的约束关系了 而 Barrier（屏障）就是用于这种情况，Barrier 和 GuideLine 一样是一个虚拟的 View，对界面是不可见的，只是用于辅助布局，而 Barrier 和 GuideLine 的区别在于它可以由多个 View 来决定其属性 Barrier 可以使用的属性有： rrierDirection：用于设置 Barrier 的位置，属性值有：bottom、top、start、end、left、right constraint_referenced_ids：用于设置 Barrier 所引用的控件的 ID，可同时设置多个 barrierAllowsGoneWidgets：默认为 true，当 Barrier 所引用的控件为 Gone 时，则 Barrier 的创建行为是在已 Gone 的控件已解析的位置上进行创建。如果设置为 false，则不会将 Gone 的控件考虑在内 下面是一个非常简单的例子： 我们有三个TextViews： 左边 textView1 和 textView2 ，右边 textView3。textView3 约束在 textView1 的右边，效果也符合我们的预期。 但是当需要支持多语言的时候事情就变得复杂了。如果我们添加德语就出现了问题，因为在英语里面textView1的文字是长于textView2的，但是在德语中却是textView2的文字比textView1长： 这里的问题在于textView3仍然是相对于textView1的，所以textView2直接插入了textView3中。在设计视图里看起来更明显（白色背景的那个）。 View只能设置一个View作为锚点，设置了一个就顾不了另一个,所以传统方法是使用TableLayout，或者把 textView1 &amp; textView2 包裹在一个垂直的LinearLayout中,然后让textView3约束在这个LinearLayout的后面。所以就诞生了Barrier，他可以设置N个View作为锚点。 Barrier 是一个虚拟视图，类似于 Guideline，用来约束对象。Barrier 和 Guideline 的区别在于它是由多个 view 的大小决定的。在这个例子中，我们不知道 textView1 和 textView2 哪个长些，因此我们可以 基于这两个 view 的宽度创建一个Barrier。我们可以让 textView3 约束在 Barrier 后面。 在编辑器中创建Barriers 首先选择上下文菜单的create a vertical barrier，创建一个垂直的barrier： 注：Android Studio2.3貌似没有这个菜单，Android Studio3.0有，但是在help菜单组的下级菜单，跟下面的演示图有些区别。 你可以在组建树（component tree）中看到Barrier（左边靠近底部的面板）。 我们可以通过拖动改变它的位置（可选项）： 接下来我们需要设置Barrier 方向（direction）。这里我们是想让Barrier根据textView1 和 textView2 的大小确定是在谁的后面，因此我们需要把 direction 设置为 end： 最后一步是告诉Barrier它是相对于哪些view。我不用约束来形容是因为约束一般指一对一的，而这里是多个view。我们需要为 Barrier 指定引用的view的 ID ， 可以通过在 component tree 中把view拖动到 Barrier 来完成： 一旦定义好之后，这些引用将被列为 Barrier 的 children。而且你还会在蓝色面板中看到Barrier跳到了新的位置（垂直的虚线）。 现在 Barrier 就已经定义好了，只剩下把textView3的约束从相对于 textView1 改为 相对于 Barrier 了： 完了之后 textView3 就到了 textView2 的后面了。 为了看到整体的效果，可以切换语言，此时你会看到 Barrier 会自动位于较宽的那个 textView 后面，也就间接让 textView3 也位于了正确的位置： 在XML中创建Barriers XML代码其实也非常简单： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/textView1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="16dp" android:layout_marginTop="16dp" android:text="@string/warehouse" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/textView2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="16dp" android:layout_marginTop="8dp" android:text="@string/hospital" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/textView1" /&gt; &lt;androidx.constraintlayout.widget.Barrier android:id="@+id/barrier7" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="end" app:constraint_referenced_ids="textView2,textView1" /&gt; &lt;TextView android:id="@+id/textView3" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginStart="8dp" android:text="@string/lorem_ipsum" app:layout_constraintStart_toEndOf="@+id/barrier7" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; barrierAllowsGoneWidgets 目前button3和button1 button2的top对齐，此时如果button1 Gone了呢？ 如上图效果,button1 gone之后，会变为一个点，所以button3顶齐父布局也没问题。但有的时候这不符合我们的需求，我们希望Barrier不要关注Gone的View了，所以谷歌提供了属性barrierAllowsGoneWidgets,设为false后，就不在关注Gone的View了，效果如上图,button1 gone之后,button3 不再和父布局顶齐,而是和button2顶齐。 Barrier特别的地方就在于Barrier元素自身。app:barrierDirection 属性决定 Barrier 的方向 － 这里把它放在被引用view的后面。被引用的view 是布局中的view的id列表，用逗号隔开。 借用一张图 来自https://medium.com/androiddevelopers/introducing-constraint-layout-1-1-d07fc02406bc Group使用组，您可以将某些视图分组在一起。不要把这与Android中的普通ViewGroups混淆。ConstraintLayout中的一个组仅包含对视图ID的引用，而不将组合中的视图嵌套。这样一来，您可以设置组中控件的可见性仅通过设置组的可见性就行了，而无需设置每个视图的可见性。这对于诸如错误屏幕或加载屏幕的事情是有用的，其中一些元素需要一次更改其可见性 其可使用到的属性为： constraint_referenced_ids：指定所引用控件的 id。 12345&lt;androidx.constraintlayout.widget.Group android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="gone" app:constraint_referenced_ids="title, desc" /&gt; 如果有多个 Group，是可以同时指定相同的控件的，最终是以 XML 中最后声明的 Group 为准。 PlaceholderPlaceholder顾名思义，就是用来一个占位的东西，它可以通过 setContentId() 方法将占位符变为有效的视图。如果视图已经存在于屏幕上，那么视图将会从原有位置消失。 除此之外，还可以通过 setEmptyVisibility() 方法设置当视图不存在时占位符的可见性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/constraintLayout" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;androidx.constraintlayout.widget.Placeholder android:id="@+id/placeholder" android:layout_width="96dp" android:layout_height="96dp" android:layout_marginStart="8dp" android:layout_marginTop="8dp" android:layout_marginEnd="8dp" android:layout_marginBottom="8dp" android:scaleType="centerInside" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="@+id/mail" /&gt; &lt;ImageButton android:id="@+id/favorite" android:layout_width="48dp" android:layout_height="48dp" android:layout_marginTop="16dp" android:background="#00000000" android:scaleType="centerInside" android:src="@drawable/favorite" android:tint="#E64A19" app:layout_constraintEnd_toStartOf="@id/mail" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;ImageButton android:id="@+id/mail" android:layout_width="48dp" android:layout_height="48dp" android:layout_marginTop="16dp" android:background="#00000000" android:scaleType="centerInside" android:src="@drawable/checked" android:tint="#512DA8" app:layout_constraintEnd_toStartOf="@id/save" app:layout_constraintStart_toEndOf="@id/favorite" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;ImageButton android:id="@+id/save" android:layout_width="48dp" android:layout_height="48dp" android:layout_marginTop="16dp" android:background="#00000000" android:scaleType="centerInside" android:src="@drawable/star" android:tint="#D32F2F" app:layout_constraintEnd_toStartOf="@id/play" app:layout_constraintStart_toEndOf="@id/mail" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;ImageButton android:id="@+id/play" android:layout_width="48dp" android:layout_height="48dp" android:layout_marginTop="16dp" android:background="#00000000" android:scaleType="centerInside" android:src="@drawable/delete" android:tint="#FFA000" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toEndOf="@id/save" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637class DemoFragment : Fragment(), View.OnClickListener &#123; override fun onClick(v: View) &#123; //call TransitionManager so and pass ConstraintLayout to perform smooth animation TransitionManager.beginDelayedTransition(mConstraintLayout); //finally set clicked view at placeholder mPlaceholder.setContentId(v.id) &#125; private lateinit var dashboardViewModel: DashboardViewModel private lateinit var mConstraintLayout: ConstraintLayout private lateinit var mPlaceholder: Placeholder override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? &#123; dashboardViewModel = ViewModelProviders.of(this).get(DashboardViewModel::class.java) val root = inflater.inflate(R.layout.fragment_dashboard, container, false) val favorite: ImageButton = root.findViewById(R.id.favorite) favorite.setOnClickListener(this) val star : ImageButton = root.findViewById(R.id.star) star.setOnClickListener(this) val checked : ImageButton = root.findViewById(R.id.checked) checked.setOnClickListener(this) val delete : ImageButton = root.findViewById(R.id.delete) delete.setOnClickListener(this) mConstraintLayout = root.findViewById(R.id.constraintLayout) mPlaceholder = root.findViewById(R.id.placeholder) return root &#125;&#125; Optimizer (优化器)需要知道的是，当我们使用 MATCH_CONSTRAINT 时，ConstraintLayout 将不得不对控件进行 2 次测量，而测量的操作是昂贵的。 而优化器（Optimizer）的作用就是对 ConstraintLayout 进行优化，对应设置给 ConstraintLauyout 的属性是： layout_optimizationLevel。 可设置的值有： none：不应用优化。 standard：仅优化直接约束和屏障约束（默认的）。 direct：优化直接约束。 barrier：优化屏障约束。 chain：优化链约束（实验）。 dimensions：优化尺寸测量（实验）。 在设置值时，可以设置多个，如： 1app:layout_optimizationLevel="direct|barrier|dimensions" 可视化编辑器这部分可以参考以下文章 使用布局编辑器构建界面 [译文]使用ConstraintLayout构建一个响应式的UI 自律给你自由——设计布局的新姿势 Android新特性介绍，ConstraintLayout完全解析 未来布局之星——ConstraintLayout demo http://quanqi.org/2016/05/20/code-labs-constraint-layout/ https://juejin.im/post/592655630ce46300574be298 https://juejin.im/post/5c74f2546fb9a049ef273ceb https://www.jianshu.com/p/b3cd72524b11 动画 https://juejin.im/post/59258f97a0bb9f005f84f7dd https://www.jianshu.com/p/9c7503f4717e 高级https://developer.android.com/reference/android/support/constraint/ConstraintsChangedListener https://developer.android.com/reference/android/support/constraint/ConstraintSet Barriers clone() in ConstraintSet 1.1.3 约束集与动画 您可以将 ConstraintLayout 随同 ConstraintSet (约束集)一起使用来一次实现多个元素的动画效果。 一个 ConstraintSet 仅持有一个 ConstraintLayout 的约束。你可以在代码中创建一个ConstraintSet，或者从一个布局文件中加载它。然后，您可以将 ConstraintSet 应用于 ConstraintLayout，更新所有约束以匹配 ConstraintSet 中的约束。 要使其具有动画效果，请使用 support library 中的 TransitionManager.beginDelayedTransition() 方法。此功能将使您的 ConstraintSet 中的所有布局的更新都通过动画来呈现。 这是一个更深入地涵盖了这个话题的视频： YouTube 视频链接：https://youtu.be/OHcfs6rStRo motionlaytout https://github.com/googlesamples/android-ConstraintLayoutExamples 性能分析https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ https://android.jlelse.eu/constraint-layout-performance-870e5f238100 https://www.cnblogs.com/liujingg/p/7161319.html 参考官方文档 细细品读！深入浅出，官方文档看ConstraintLayout 为什么ConstraintLayout代替其他布局? Android 约束布局（ConstraintLayout）1.1.0 版详解 Android 约束布局（ConstraintLayout）详解 未来布局之星——ConstraintLayout ConstraintLayout之Barrier ConstraintLayout 之 Guideline、Barrier、Chains和Groups 约束布局（ConstraintLayout）1.1.2 版本的新特性 Constraint Layout 1.1.x带来了哪些新东西？ ConstraintLayout 用法全解析]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>ConstrainLayout</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask 源码分析]]></title>
    <url>%2Fposts%2F96014b68.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 1framework/base/core/java/andorid/os/AsyncTask.java 简介之前讲解了能够在后台工作线程中执行耗时任务的IntentService框架，在这里我们继续学习Android提供的另外一个异步执行任务的框架AsyncTask，它和IntentService既有相似点也有不同点，其相似之处在于都能在新的线程中执行耗时任务防止阻塞主线程，不同之处在于AsyncTask能够追踪任务的执行过程和结果并在主线程中显示出来。 知识储备LinkedBlockingQueue 链阻塞队列阻塞队列BlockingQueue被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。LinkedBlockingQueue 类实现了BlockingQueue 接口。LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 ArrayDeque数组队列 ArrayDeque的特点 大小自增长的队列 内部使用数组存储数据 线程不安全 内部数组长度为8、16、32….. 2的n次方 头指针head从内部数组的末尾开始，尾指针tail从0开始，在头部插入数据时，head减一，在尾部插入数据时，tail加一。当head==tail时说明数组的容量满足不了当前的情况，此时需要扩大容量为原来的二倍。 ExecutorService 执行器服务java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。 ExecutorService 简单实现 123456789ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println("Asynchronous task"); &#125; &#125;); executorService.shutdown(); 首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService。这里创建了一个十个线程执行任务的线程池。然后，将一个 Runnable 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。 ThreadPoolExecutor 线程池执行者ava.util.concurrent.ThreadPoolExecutor 是 ExecutorService 接口的一个实现。ThreadPoolExecutor 使用其内部池中的线程执行给定任务(Callable 或者 Runnable)。 构造方法： 12345678910111213141516171819202122//构造方法public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 下面看看几个参数的含义及作用 corePoolSize — 核心线程数，即允许闲置的线程数目 maximumPoolSize — 最大线程数，即这个线程池的容量 keepAliveTime — 非核心线程的闲置存活时间 unit — 上一个参数的单位 workQueue — 任务队列（阻塞队列） threadFacotry — 线程创建工厂 handler — 当线程池或者任务队列容量已满时用于 reject Callable&amp;&amp;Future 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 1234567891011121314public interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 简单来讲，Callable接口等价于Runable，call()等价于run()，区别在于它是有返回值的。我们可以通过ExecutorService调用Callable，执行后将返回Future对象，比如:Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable); 1234567891011121314 public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future接口两个方法着重理解下，一是cancel(boolean mayInterruptIfRunning)，顾名思义就是终止线程，二是get()，它会阻塞线程，直到Callable的call()返回对象，并以此作为返回值。至于mayInterruptIfRunning这个boolean值的含义，大家看看FutureTask中相应的源码就直到了，其实只是多了thread.interrupt()的逻辑而已。结合Callable的代码，Future的使用如下： 123Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable);//阻塞线程，等待Callable.call()的返回值String result = future.get(); FutureTask 123456789public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647从`FutureTask`的继承关系来看，它既是`Runable`也是Future，所以我们可以把当做Runable来使用，同时它也具备Future的能力，可以终止线程，可以阻塞线程，等待Callable的执行，并获取返回值。另外要注意的是，它的构造函数是public FutureTask(Callable&lt;V&gt; callable)，因此实例化FutureTask时需要Callable对象作为参数。## AsyncTask 的使用方式### 使用示例```javaprivate class DownloadFileTask extends AsyncTask&lt;String, Integer, Long&gt; &#123; @Override public void onPreExecute() &#123; mProgress.setVisibility(View.VISIBLE); mProgress.setMax(100); mProgress.setProgress(0); &#125; @Override public Long doInBackground(String... uris) &#123; int count = uris.length; long size = 0; for (int i = 1; i &lt;= count; i ++) &#123; try &#123; // 休眠5秒模拟下载过程 Thread.sleep(5 * 1000); // 假设每个下载文件的大小为（序号*100） size += i * 100; // 发布进度更新 publishProgress( (100* i )/count); &#125; catch (InterruptedException ie) &#123; ie.printStackTrace(); &#125; &#125; return size; &#125; @Override public void onProgressUpdate(Integer... progress) &#123; mProgress.setProgress(progress[0]); &#125; @Override public void onPostExecute(Long result) &#123; mText.setText(String.valueOf(result)); &#125;&#125; 通过这段代码可以看到要使用AsyncTask实行异步任务是非常容易的，只需要做两件事: 确定在整个处理过程中需要的参数类型，包括Params,Progress和Result,分别对应着输入参数、进度参数和结果参数。 实现必要的回调方法，其中必须是实现的是doInBackground，耗时任务正是在这里进行处理的，可以想象doInBackground一定是在子线程里进行的；其他可选实现方法包括onPreExecute,onProgressUpdate和onPostExecute，这些在示例中都参与了UI的更新，所以一定是在主线程中进行的。 参数介绍public abstract class AsyncTask&lt;Params, Progress, Result&gt; { ... } 可以发现AsyncTask中使用的都是泛型参数，在使用过程中要根据需求选择合适的参数类型，在示例中使用的参数类型分别是String,Integer和Long,如果某一个参数是不需要的，可以用Void来表示，下面通过一个表格来对每个参数进行说明： 参数声明 含义 作用 产生处/调用处 注意事项 Params 输入参数 任务开始执行时客户端发送开始参数 execute()中发送，在doInBackground()中调用。 可变参类型 Progress 过程参数 任务后台执行过程中服务端发布的当前执行进度 在doInBackground()中产生并通过publishProgess()发送，在onProgressUpdate()调用。 可变参类型 Result 结果参数 任务执行完成后服务端发送的执行结果 在doInBackground()中产生并在onPostExecute()中调用。 参数类型不能是基本数据类型，要使用对应的封装类型，例如示例的Progress和Result参数使用的Integer和Long而不是int和long。 回调接口 回调方法 运行线程 作用 执行顺序 是否需要重新实现 onPreExecute 主线程 在开始执行后台任务前进行初始化 首先开始执行 可选 doInBackground 后台线程 执行后台耗时任务完成后返回结果 onPreExecute 执行完成后执行 必须实现 publishProgress 后台线程 在执行任务过程中发布执行进度 在 doInBackground 中执行 无须实现，直接调用。 onProgressUpdate 主线程 接收进度并在主线程处理 在 publishProgress 之后执行 可选 onPostExecute 主线程 接收执行结果并在主线程处理 在 doInBackground 执行完成后执行 可选 AsyncTask 源码分析回到我们一开始提到的那个示例代码，当我们定义了好自己的AsyncTask之后，要开始运行这个任务时非常简单，只需要一行代码： new DownloadFileTask().execute(url1, url2, url3); 我们就以这个为切入点来分析，首先看下execute()做了什么 首先，new DownloadFileTask() ，执行DownloadFileTask的构造方法，因此必然会执行DownloadFileTask的父类AsyncTask的构造方法，也就是 AsyncTask() ： 123456/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */public AsyncTask() &#123; this((Looper) null);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; //设置当前任务已被执行 mTaskInvoked.set(true); Result result = null; try &#123; //设置线程执行的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 构造方法的工作很简单，就是完成了mWorker 和 mFuture 的初始化工作，也就是Callable和Future 的初始化，并关联他们，让mFuture 可以获取mWorker 的执行结果，或者停止mWorker 的执行。 这里主要由两个方法call()和done()，总的来说当mFuture 开始被执行的时候，call() 就会执行，当这个任务执行完毕后done()方法就会执行。 那么这个mFuture 什么 时候会被执行呢？继续往下看execute(Params... params) 1234@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 12345678910111213141516171819202122232425@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; // 回调方法中首先被调用的方法，由于"execute()"是在主线程中执行的, // 目前为止也没有进行线程的切换，所以"onPreExecute"也是在主线程中执行的。 onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 到这里就很清楚了，mStatus 默认状态为PENDING，因此任务开始执行后首先将其状态改为RUNNING；同时从异常判断我们也可以看出一个AsyncTask的execute方法不能同时执行两次。 接下来，onPreExecute()，我们是在onCreate 中开启了AsyncTask的任务，因此这个时候，依旧属于主线程，onPreExecute()方法也会工作在主线程，我们可以在这个方法中执行一些预备操作，初始相关内容。 mWorker，前面已经说过他就是实现了Callable接口，并添加了一个参数属性，在这里我们把executor中传入的参数赋给了这个属性。exec=sDefaultExecutor=SerialExecutor ，这里任务就开始真正的执行了；按照之前所说就会开始执行mFuture这个任务，因此就会开始执行mWorker的call方法。 123456789101112131415161718192021&gt; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;&gt; public Result call() throws Exception &#123;&gt; //设置当前任务已被执行&gt; mTaskInvoked.set(true);&gt; Result result = null;&gt; try &#123;&gt; //设置线程执行的优先级&gt; &gt; &gt; &gt;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);&gt; //noinspection unchecked&gt; result = doInBackground(mParams);&gt; Binder.flushPendingCommands();&gt; &#125; catch (Throwable tr) &#123;&gt; mCancelled.set(true);&gt; throw tr;&gt; &#125; finally &#123;&gt; postResult(result);&gt; &#125;&gt; return result;&gt; &#125;&gt; &#125;;&gt; 到这里，我们终于看到了熟悉的 doInBackground，这是我们必须实现的一个方法，在其中完成耗时操作，并返回结果。由于已经设置了Process的优先级，因此这个方法会处于后台进程。在 doInBackground 里，我们还可以返回当前执行进度 12345678910111213141516171819&gt; @Override&gt; public Long doInBackground(String... uris) &#123;&gt; int count = uris.length;&gt; long size = 0;&gt; for (int i = 1; i &lt;= count; i ++) &#123;&gt; try &#123;&gt; // 休眠5秒模拟下载过程&gt; Thread.sleep(5 * 1000);&gt; // 假设每个下载文件的大小为（序号*100）&gt; size += i * 100;&gt; // 发布进度更新&gt; publishProgress( (100* i )/count);&gt; &#125; catch (InterruptedException ie) &#123;&gt; ie.printStackTrace();&gt; &#125;&gt; &#125;&gt; return size;&gt; &#125;&gt; 我们调用了 publishProgress 可以将 doInBackground中耗时任务的进度发送出去，大家都知道这个进度会发送到onProgressUpdate() 方法中，在onProgressUpdate我们可以方便的进行UI 更新，比如进度条进度更新等。那么他是怎么实现的呢？这就要看publishProgress这个方法的实现了。 1234567@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; AsyncTaskResult 顾名思义，很好理解了，就是AsyncTask的执行结果，这是一个静态的内部类，包括两个属性mTask和mData 。 1234567891011@SuppressWarnings(&#123;"RawUseOfParameterizedType"&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125;&#125; 因此publishProgress中 new AsyncTaskResult 就是创建了一个AsyncTaskResult,他的两个两个属性为当前的AsyncTask和任务任务执行进度。 到这里的逻辑很清楚了，如果当前任务没有被取消， 那么就从消息池中获取一个Message的实例，同时设置这个Message对象的msg.what=MESSAGE_POST_PROGRESS, msg.obj为一个AsyncTaskResult对象，最后执行sendToTarget方法，通过之前对Handler实现机制的了解，我们知道sendXXX方法殊途同归，所完成的任务都是将Message对象插入到MessageQueue当中，等着Looper的loop方法一个个取出。由于我们是在主线程开启了AsyncTask任务的执行，因此，一旦我们将一个消息插入到队列，那么就会执行Handler的handleMessage方法。下面就来看看你这个InternalHandler 的实现。 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 很简单,在handleMessage中首先取出结果，并强制转换为AsyncTaskResult对象，在msg.what=MESSAGE_POST_PROGRESS时，就会执行result.mTask.onProgressUpdate(result.mData);mTask 就是当前AsyncTask，因此就会执行AsyncTask中声明的onProgressUpdate方法。这样，就把参数从一个子线程传递到了UI 线程，非常方便开发人员用这个完成相关业务。 我们再回到mWorker 的call() 方法中，当doInBackground执行完毕后，最后就会执行postResult。 1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 这个方法和publishProgress逻辑一样，懂事把result 封装到一个AsyncTaskResult 对象中，做为一个Message对象的obj属性插入到MessageQueue中，只不过msg.what=MESSAGE_POST_RESULT. 这样就会来到InternalHandler 的handleMessage中，这一次msg.what=MESSAGE_POST_RESULT.时执行result.mTask.finish(result.mData[0]); 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 这个方法也很简单，任务未取消时，onPostExecute(result) 方法被执行。这个onPostExecute(result)就是我们最后要执行的方法，在这个方法中得到最终的执行结果；并将任务状态标记为FINISHED。 其他串行or并行？在SimpleAsyncTask中，我们使用private static final Executor EXECUTOR = Executors.newCachedThreadPool()作为线程池，而实际上，源码中的默认线程池是自定义的，这个类是SerialExecutor，从类的命名上看，Serial是串行的意思，所以很明显，AsyncTask默认是串行的。除此之外，AsyncTask里还有个线程池 THREAD_POOL_EXECUTOR，实在需要并行的话我们就用这个线程池。 如果都些都不满足要求，我们也可以自定义符合自己业务要求的线程池，并通过setDefaultExecutor(Executor exec)改变默认的线程池。 在executeOnExecutor中我们还可以传入自己自定义的线程池： 123456//跟默认一样的按顺序执行asyncTask.executeOnExecutor(Executors.newSingleThreadExecutor());//无限制的ExecutorasyncTask.executeOnExecutor(Executors.newCachedThreadPool());//同时执行数目为10的ExecutorasyncTask.executeOnExecutor(Executors.newFixedThreadPool(10)); postResultIfNotInvoked的作用是什么？AsyncTask有很多逻辑干扰了我们解读源码，postResultIfNotInvoked便是其中一个。它实际上是Google解决的一个bug，确保如果cancel()方法过早调用的场景下，onCancelled()仍然能顺利的执行，参考stackoverflow这篇文章。 用这个玩意 退出页面必须取消运行 否则你下个页面用的时候就知道问题了 串行坑了我一次参考理解 AsyncTask 原理 关于AsyncTask的一次深度解析 AsyncTask:一只命途多舛的小麻雀]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Bound Service 知识总结]]></title>
    <url>%2Fposts%2Fccf7cf3d.html</url>
    <content type="text"><![CDATA[基础知识绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。 本文向您介绍如何创建绑定服务，包括如何绑定到来自其他应用组件的服务。 不过，您还应参阅Android Service 知识总结，了解有关一般服务的更多信息，例如：如何利用服务传送通知、如何将服务设置为在前台运行等等。 绑定服务是 Service 类的实现，可让其他应用与其绑定和交互。要提供服务绑定，您必须实现 onBind() 回调方法。该方法返回的 IBinder 对象定义了客户端用来与服务进行交互的编程接口。 绑定到已启动服务 正如Android Service 知识总结中所述，可以创建同时具有已启动和绑定两种状态的服务。 也就是说，可通过调用startService() 启动该服务，让服务无限期运行；此外，还可通过调用 bindService() 使客户端绑定到服务。 如果您确实允许服务同时具有已启动和绑定状态，则服务启动后，系统“不会”在所有客户端都取消绑定时销毁服务。 为此，您必须通过调用 stopSelf() 或 stopService() 显式停止服务。 尽管您通常应该实现 onBind() 或 onStartCommand()，但有时需要同时实现这两者。例如，音乐播放器可能发现让其服务无限期运行并同时提供绑定很有用处。 这样一来，Activity 便可启动服务进行音乐播放，即使用户离开应用，音乐播放也不会停止。 然后，当用户返回应用时，Activity 可绑定到服务，重新获得回放控制权。 请务必阅读管理绑定服务的生命周期部分，详细了解有关为已启动服务添加绑定时该服务的生命周期信息。 客户端可通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。bindService() 方法会立即无值返回，但当 Android 系统创建客户端与服务之间的连接时，会对 ServiceConnection 调用 onServiceConnected()，向客户端传递用来与服务通信的 IBinder。 多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。 当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 startService() 也启动了该服务）。 当您实现绑定服务时，最重要的环节是定义您的 onBind() 回调方法返回的接口。您可以通过几种不同的方法定义服务的IBinder 接口，下文对这些方法逐一做了阐述。 创建绑定服务创建提供绑定的服务时，您必须提供 IBinder，用以提供客户端用来与服务进行交互的编程接口。 您可以通过三种方法定义接口： 扩展 Binder 类如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service中可用的公共方法。如果服务只是您的自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的服务被其他应用或不同的进程占用。 使用 Messenger如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。 使用 AIDLAIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 注：大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用，本文也不会阐述如何将其用于您的服务。如果您确定自己需要直接使用 AIDL，请参阅 AIDL 文档。 在Android系统中，一个进程是不能直接访问另一个进程的内存的，需要提供一些机制在不同的进程之间进行通信，Android官方推出了AIDL(Android Interface Definition Language)，它是基于Binder机制的，至于官方为什么要采用Binder，查看为什么Android要采用Binder作为IPC机制，分析很全面。如果组件与服务通信是在同一进程，就使用第一种方式；如果是跨进程通信，使用第二种和第三种，两者不同在于，Messenger不能处理多线程并发请求。 扩展 Binder 类 如果您的服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让您的客户端通过该类直接访问服务中的公共方法。 注：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。 以下是具体的设置方法： 在您的服务中，创建一个可满足下列任一要求的Binder 实例： 包含客户端可调用的公共方法 返回当前 Service 实例，其中包含客户端可调用的公共方法 或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法 从 onBind() 回调方法返回此 Binder 实例。 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。 注：之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组。 例如，以下这个服务可让客户端通过 Binder 实现访问服务中的方法： 123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; LocalBinder 为客户端提供 getService() 方法，以检索 LocalService 的当前实例。这样，客户端便可调用服务中的公共方法。 例如，客户端可调用服务中的 getRandomNumber()。 点击按钮时，以下这个 Activity 会绑定到 LocalService 并调用 getRandomNumber() ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 上例说明了客户端如何使用 ServiceConnection 的实现和 onServiceConnected() 回调绑定到服务。下文更详细介绍了绑定到服务的过程。 注：在上例中，onStop() 方法将客户端与服务取消绑定。 客户端应在适当时机与服务取消绑定，如附加说明中所述。 使用 Messenger 与 AIDL 比较 当您需要执行 IPC 时，为您的接口使用 Messenger 要比使用 AIDL 实现它更加简单，因为 Messenger 会将所有服务调用排入队列，而纯粹的 AIDL 接口会同时向服务发送多个请求，服务随后必须应对多线程处理。 对于大多数应用，服务不需要执行多线程处理，因此使用 Messenger 可让服务一次处理一个调用。如果您的服务必须执行多线程处理，则应使用 AIDL 来定义接口。 如需让服务与远程进程通信，则可使用 Messenger 为您的服务提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。 以下是 Messenger 的使用方法摘要： 服务实现一个 Handler，由其接收来自客户端的每个调用的回调 Handler 用于创建 Messenger 对象（对 Handler 的引用） Messenger 创建一个 IBinder，服务通过 onBind() 使其返回客户端 客户端使用 IBinder 将 Messenger（引用服务的 Handler）实例化，然后使用后者将 Message 对象发送给服务 服务在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message。 这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message 对象）是服务在其 Handler 中接收的。以下是一个使用 Messenger 接口的简单服务示例： 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 请注意，服务就是在 Handler#handleMessage() 方法中接收传入的 Message，并根据 what 成员决定下一步操作。 客户端只需根据服务返回的IBinder 创建一个 Messenger，然后利用 send() 发送一条消息。例如，以下就是一个绑定到服务并向服务传递 MSG_SAY_HELLO 消息的简单 Activity： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 请注意，此示例并未说明服务如何对客户端作出响应。如果您想让服务作出响应，则还需要在客户端中创建一个Messenger。然后，当客户端收到 onServiceConnected() 回调时，会向服务发送一条 Message，并在其 send() 方法的 replyTo 参数中包含客户端的 Messenger。 使用 AIDLAIDL，即Android Interface Definition Language，Android接口定义语言。它是一种IDL语言，可以拿来生成用于IPC的代码。在我看来，它其实就是一个模板。为什么这样说呢？在我们的使用中，实际上起作用的并不是我们写的AIDL代码，而是系统根据它生成的一个IInterface实例的代码。而如果大家多生成几个这样的实例，然后把它们拿来比较，你会发现它们都是有套路的——都是一样的流程，一样的结构，只是根据具体的AIDL文件的不同有细微的变动。所以其实AIDL就是为了避免我们一遍遍的写一些千篇一律的代码而出现的一个模板。 使用Messenger也是基于AIDL的，Messenger把所有请求都放在一个线程中，service每次处理一个。然而对于AIDL实现来说。service可以同时处理多个请求（应该是并发处理）。这种情况下，你的服务必须拥有多线程处理能力，并且是以线程安全的方式编写的。要直接使用AIDL，你必须创建一个.aidl文件，其中定义了编程接口。 Android SDK 工具使用此文件来自动生成一个抽象类，其中实现了接口及对IPC的处理，然后我们就可以在自己的服务中继承该类。 那么如何使用AIDL来通过bindService()进行线程间通信呢？基本上有下面这些步骤： 服务端创建一个AIDL文件，将暴露给客户端的接口在里面声明在service中实现这些接口客户端绑定服务端，并将onServiceConnected()得到的IBinder转为AIDL生成的IInterface实例通过得到的实例调用其暴露的方法上面的描述其实比较抽象，基本上是那种看了也不知道怎么做的类型——这个如果要展开讲的话就又是长篇大论的了。基于这种考虑，这里只是简单的介绍一下AIDL这个东西，它的具体的语法，到底怎么来实现IPC，参考Android进程通信之Messenger&amp;AIDL使用详解。 绑定到服务 应用组件（客户端）可通过调用 `bindService()` 绑定到服务。Android 系统随后调用服务的 `onBind()` 方法，该方法返回用于与服务交互的` IBinder`。 绑定是异步的。bindService() 会立即返回，“不会”使IBinder返回客户端。要接收 IBinder，客户端必须创建一个 ServiceConnection 实例，并将其传递给 bindService()。ServiceConnection 包括一个回调方法，系统通过调用它来传递IBinder。 注：只有 Activity、服务和内容提供程序可以绑定到服务 — 您无法从广播接收器绑定到服务。 因此，要想从您的客户端绑定到服务，您必须：1.实现ServiceConnection。 您的实现必须重写两个回调方法： onServiceConnected() 系统会调用该方法以传递服务的 onBind() 方法返回的 IBinder。 onServiceDisconnected() Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。 2.调用 bindService()，传递 ServiceConnection 实现。3.当系统调用您的 onServiceConnected() 回调方法时，您可以使用接口定义的方法开始调用服务。4.要断开与服务的连接，请调用 unbindService()。 如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。 更好的做法是在客户端与服务交互完成后立即取消绑定客户端。 这样可以关闭空闲服务。如需了解有关绑定和取消绑定的适当时机的详细信息，请参阅附加说明。 例如，以下代码段通过扩展 Binder 类将客户端与上面创建的服务相连，因此它只需将返回的 IBinder转换为 LocalService类并请求 LocalService 实例： 123456789101112131415161718LocalService mService;private ServiceConnection mConnection = new ServiceConnection() &#123; // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) &#123; // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) &#123; Log.e(TAG, "onServiceDisconnected"); mBound = false; &#125;&#125;; 客户端可通过将此 ServiceConnection 传递至 bindService() 绑定到服务。例如： 12Intent intent = new Intent(this, LocalService.class);bindService(intent, mConnection, Context.BIND_AUTO_CREATE); bindService() 的第一个参数是一个 Intent，用于显式命名要绑定的服务（但 Intent 可能是隐式的） 第二个参数是 ServiceConnection 对象 第三个参数是一个指示绑定选项的标志。它通常应该是 BIND_AUTO_CREATE，以便创建尚未激活的服务。其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或 0（表示无）。 附加说明 以下是一些有关绑定到服务的重要说明： - 您应该始终捕获 `DeadObjectException` 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。 - 对象是跨进程计数的引用。 - 您通常应该在客户端生命周期的匹配引入 (bring-up) 和退出 (tear-down) 时刻期间配对绑定和取消绑定。 例如： - 如果您只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。 - 如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。 注：通常情况下，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的处理保持在最低水平。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （Activity文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。） 管理绑定服务的生命周期当服务与所有客户端之间的绑定全部取消时，Android 系统便会销毁服务（除非还使用 onStartCommand() 启动了该服务）。因此，如果您的服务是纯粹的绑定服务，则无需对其生命周期进行管理 — Android 系统会根据它是否绑定到任何客户端代您管理。 不过，如果您选择实现 onStartCommand() 回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过 stopSelf() 自行停止，或其他组件调用 stopService() 为止，无论其是否绑定到任何客户端。 此外，如果您的服务已启动并接受绑定，则当系统调用您的 onUnbind() 方法时，如果您想在客户端下一次绑定到服务时接收 onRebind() 调用，则可选择返回 true。onRebind() 返回空值，但客户端仍在其 onServiceConnected() 回调中接收 IBinder。下图说明了这种生命周期的逻辑。 其他知识Messenger与AIDL的比较首先，在实现的难度上，肯定是Messenger要简单的多——至少不需要写AIDL文件了(虽然如果认真的究其本质，会发现它的底层实现还是AIDL)。另外，使用Messenger还有一个显著的好处是它会把所有的请求排入队列，因此你几乎可以不用担心多线程可能会带来的问题。 但是这样说来，难道AIDL进行IPC就一无是处了么？当然不是，如果是那样的话它早就被淘汰了。一方面是如果项目中有并发处理问题的需求，或者会有大量的并发请求，这个时候Messenger就不适用了——它的特性让它只能串行的解决请求。另外，我们在使用Messenger的时候只能通过Message来传递信息实现交互，但是在有些时候也许我们需要直接跨进程调用服务端的方法，这个时候又怎么办呢？只能使用AIDL。 所以，这两种IPC方式各有各的优点和缺点，具体使用哪种就看具体的需要了——当然，能使用简单的就尽量使用简单的吧。 参考Android Developers/Docs/指南/绑定服务 Android中的Service：Binder，Messenger，AIDL（2）]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service 知识总结]]></title>
    <url>%2Fposts%2F75909e64.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 framework/base/core/java/andorid/app/Service.java 简介引用官方定义: Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 注意：服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。 Service是一个可以在后台执行长时间操作而不使用用户界面的应用组件。那么问题来了，既然它不使用用户界面，那么它怎么知道应该什么时候开始执行什么操作呢？答案是——它可以与其他的引用组件形成一些联系，从而可以根据其传来的信息在合适的时候执行合适的操作。 一般来讲，这种联系分为两种：startService()以及bindService()。这两种联系都可以使得一个Service开始运行，但是在其他方面有着诸多不同。 启动service的方式 停止service的方式 service与启动它的组件之间的通信方式 service的生命周期 startService 在其他组件中调用startService()方法后，服务即处于启动状态 service中调用stopSelf()方法，或者其他组件调用stopService()方法后，service将停止运行 没有提供默认的通信方式，启动service后该service就处于独立运行状态 一旦启动，service即可在后台无限期运行，即使启动service的组件已被销毁也不受其影响，直到其被停止 bindService 在其他组件中调用bindService()方法后，服务即处于启动状态 所有与service绑定的组件都被销毁，或者它们都调用了unbindService()方法后，service将停止运行 可以通过 ServiceConnection进行通信，组件可以与service进行交互、发送请求、获取结果，甚至是利用IPC跨进程执行这些操作 当所有与其绑定的组件都取消绑定(可能是组件被销毁也有可能是其调用了unbindService()方法)后，service将停止 注：1.表格中的“其他组件”不包括Broadcast receiver，其不能bindService,但是可以startService的 2.startService()与bindService()并不冲突，同一个service可能既有组件调用了startService()启动它，又有组件与它进行了绑定。当同一个service与其他组件同时存在这两种联系时，其生命周期会发生变化，必须从两种方法的角度看service均停止才能真正停止。 创建Service创建一个Service一般有下面2个步骤 创建一个类继承自Service(或它的子类，如IntentService)，重写里面的一些键的回调方法，如onStartCommand()，onBind()等 在Manifests文件里面为其声明，并根据需要配置一些其他属性。 讲道理，这一切跟新建一个Activity非常的像。 onCreate()在每个Service的生命周期中这个方法会且仅会调用一次，并且它的调用在onStartCommand()以及onBind()之前，我们可以在这个方法中进行一些一次性的初始化工作。 onStartCommand()当其他组件通过startService()方法启动Service时，此方法将会被调用。 onBind()当其他组件通过bindService()方法与Service相绑定之后，此方法将会被调用。这个方法有一个IBinder的返回值，这意味着在重写它的时候必须返回一个IBinder对象，它是用来支撑其他组件与Service之间的通信的——另外，如果你不想让这个Service被其他组件所绑定，可以通过在这个方法返回一个null值来实现。 onDestroy()这是Service一生中调用的最后一个方法，当这个方法被调用之后，Service就会被销毁。所以我们应当在这个方法里面进行一些资源的清理，比如注册的一些监听器什么的。 在Manifests文件里进行声明的时候，只有android:name属性是必须要有的，其他的属性都可以没有。但是有的时候适当的配置可以让我们的开发进行地更加顺利，所以了解一下注册一个Service可以声明哪些属性也是很有必要的。 12345678910&lt;service android:enabled=["true" | "false"] android:exported=["true" | "false"] android:icon="drawable resource" android:isolatedProcess=["true" | "false"] android:label="string resource" android:name="string" android:permission="string" android:process="string" &gt;&lt;/service&gt; 具体含义可参考官网 android:enabled : 如果为true，则这个Service可以被系统实例化，如果为false，则不行。默认为true android:exported : 如果为true，则其他应用的组件也可以调用这个Service并且可以与它进行互动，如果为false，则只有与Service同一个应用或者相同user ID的应用可以开启或绑定此Service。它的默认值取决于Service是否有intent filters。如果一个filter都没有，就意味着只有指定了Service的准确的类名才能调用，也就是说这个Service只能应用内部使用——其他的应用不知道它的类名。这种情况下exported的默认值就为false。反之，只要有了一个filter，就意味着Service是考虑到外界使用的情况的，这时exported的默认值就为true android:icon : 一个象征着这个Service的icon android:isolatedProcess : 如果设置为true，这个Service将运行在一个从系统中其他部分分离出来的特殊进程中，我们只能通过Service API来与它进行交流。默认为false。 android:label : 显示给用户的这个Service的名字。如果不设置，将会默认使用的label属性。 android:name : 这个Service的路径名，例如“com.lingdage.demo.ServiceDemo”。这个属性是唯一一个必须填的属性。 android:permission : 其他组件必须具有所填的权限才能启动这个Service。 android:process : Service运行的进程的name。默认启动的Service是运行在主进程中的。 Demo123456789101112131415161718192021222324252627282930313233343536public class ServiceDemo extends Service &#123; private static final String TAG = "ServiceDome"; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate"); //只在service创建的时候调用一次，可以在此进行一些一次性的初始化操作 &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand"); //当其他组件调用startService()方法时，此方法将会被调用 //在这里进行这个service主要的操作 return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind"); //当其他组件调用bindService()方法时，此方法将会被调用 //如果不想让这个service被绑定，在此返回null即可 return null; &#125; @Override public void onDestroy() &#123; Log.d(TAG, "onDestroy"); //service调用的最后一个方法 //在此进行资源的回收 super.onDestroy(); &#125;&#125; 注意:每个Service必须在manifest中 通过来声明 1234&gt; &lt;service android:name="com.example.servicetest.ServiceDemo" &gt; &gt; ... &gt; &lt;/service&gt;&gt; 现在我们通过继承Service的方式定义了我们自己的ServiceDemo类,并且在manifest中声明了我们的ServiceDemo,接下来我们应该启动我们自己的服务. 请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 启动Service另一个组件通过调用startService()方法，就可以启动一个特定的Service，并且这将导致Service中的onStartCommand()方法被调用。在调用startService()方法的时候，其他组件需要在方法中传递一个Intent参数，然后Service将会在onStartCommand()中接收这个Intent，并获取一些数据。比如此时某个Activity要将一些数据存入数据库中，我就可以通过Intent把数据传入Service，然后让Service去进行连接数据库，存储数据等操作，而此时用户可以执行其他的任何操作——甚至包括销毁那个Activity——这并不会影响Service存储数据这件事。 当一个Service通过这种方式启动之后，它的生命周期就已经不受启动它的组件影响了，它可以在后台无限期的运行下去，只要Service自身没有调用stopSelf()并且其他的组件没有调用针对它的stopService()。 另外，如果确定了使用这种方式启动Service并且不希望这个Service被绑定的话，那么也许除了传统的创建一个类继承Service之外我们有一个更好的选择——IntentService。 相比Service，IntentService要简单许多。但是要注意的是，如果你有让Service同时处理多个请求的需求，这个时候就只能去继承Service了。这个时候就要自己去处理工作线 demo 我们通过一个Intent对象，并调用startService()方法来启动ServiceDemo 12Intent startIntent = new Intent(this, ServiceDemo.class); startService(startIntent); 注意,假如我们是通过点击Button执行上面的代码,那么第一次点击的时候回执行其中的onCreate()和onStartCommand()方法,但是当我们第二次点击的时候就只会执行onStartCommand()方法了. 为什么会这样呢？这是由于onCreate()方法只会在Service第一次被创建的时候调用，如果当前Service已经被创建过了(第一次点击创建了ServiceDemo)，不管怎样调用startService()方法，onCreate()方法都不会再执行。 启动了之后,当我们想停止服务的时候该怎么做呢? 我们也是通过一个Intent对象，并调用stopService()方法来停止ServiceDemo 12Intent stopIntent = new Intent(this, ServiceDemo.class);stopService(stopIntent); 停止Service启动服务必须管理自己的生命周期。也就是说，除非系统必须回收内存资源，否则系统不会停止或销毁服务，而且服务在onStartCommand() 返回后会继续运行。因此，服务必须通过调用 stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 一旦请求使用 stopSelf() 或 stopService() 停止服务，系统就会尽快销毁服务。 但是，如果服务同时处理多个 onStartCommand() 请求，则您不应在处理完一个启动请求之后停止服务，因为您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，您可以使用stopSelf(int) 确保服务停止请求始终基于最近的启动请求。也就说，在调用 stopSelf(int) 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果在您能够调用 stopSelf(int) 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。 注意：为了避免浪费系统资源和消耗电池电量，应用必须在工作完成之后停止其服务。 如有必要，其他组件可以通过调用stopService() 来停止服务。即使为服务启用了绑定，一旦服务收到对 onStartCommand() 的调用，您始终仍须亲自停止服务。 创建绑定服务绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接（通常不允许组件通过调用startService() 来启动它）。 如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。 要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（您不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。 要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 bindService这是一种比startService更复杂的启动方式，同时使用这种方式启动的service也能完成更多的事情，比如其他组件可向其发送请求，接受来自它的响应，甚至通过它来进行IPC等等。我们通常将绑定它的组件成为客户端，而称它为服务器。 如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式 继承Binder类 使用Messenger类(AIDL的简化版) 使用AIDL 这一块比较复杂,我们新开一篇讲解。Android Bound Service 知识总结 在前台运行服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。 例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 要请求让服务运行于前台，请调用 startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的Notification。例如： 1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。 要从前台移除服务，请调用stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。 管理服务生命周期 服务的生命周期比 Activity的生命周期要简单得多。但是，密切关注如何创建和销毁服务反而更加重要，因为服务可以在用户没有意识到的情况下运行于后台。 服务生命周期（从创建到销毁）可以遵循两条不同的路径： 启动服务 该服务在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用 stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止服务。服务停止后，系统会将其销毁。 绑定服务 该服务在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过 IBinder 接口与服务进行通信。客户端可以通过调用 unbindService() 关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统即会销毁该服务。 （服务不必自行停止运行。） 这两条路径并非完全独立。也就是说，您可以绑定到已经使用 startService() 启动的服务。例如，可以通过使用Intent（标识要播放的音乐）调用 startService() 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 bindService() 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 stopService() 或 stopSelf() 不会实际停止服务。 实现生命周期回调与 Activity 类似，服务也拥有生命周期回调方法，您可以实现这些方法来监控服务状态的变化并适时执行工作。 以下框架服务展示了每种生命周期方法： 12345678910111213141516171819202122232425262728293031323334public class ExampleService extends Service &#123; int mStartMode; // indicates how to behave if the service is killed IBinder mBinder; // interface for clients that bind boolean mAllowRebind; // indicates whether onRebind should be used @Override public void onCreate() &#123; // The service is being created &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // The service is starting, due to a call to startService() return mStartMode; &#125; @Override public IBinder onBind(Intent intent) &#123; // A client is binding to the service with bindService() return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; // All clients have unbound with unbindService() return mAllowRebind; &#125; @Override public void onRebind(Intent intent) &#123; // A client is binding to the service with bindService(), // after onUnbind() has already been called &#125; @Override public void onDestroy() &#123; // The service is no longer used and is being destroyed &#125;&#125; 注：与 Activity 生命周期回调方法不同，您不需要调用这些回调方法的超类实现。 通过实现这些方法，您可以监控服务生命周期的两个嵌套循环： 服务的整个生命周期从调用onCreate() 开始起，到onDestroy()返回时结束。与 Activity 类似，服务也在onCreate()中完成初始设置，并在onDestroy()中释放所有剩余资源。例如，音乐播放服务可以在onCreate()中创建用于播放音乐的线程，然后在onDestroy()中停止该线程。 无论服务是通过 startService() 还是 bindService() 创建，都会为所有服务调用 onCreate() 和 onDestroy() 方法。 服务的有效生命周期从调用onStartCommand()或onBind()方法开始。每种方法均有Intent对象，该对象分别传递到startService()或bindService() 。 对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 onUnbind() 返回时结束。 注：尽管启动服务是通过调用 stopSelf() 或 stopService() 来停止，但是该服务并无相应的回调（没有 onStop() 回调）。因此，除非服务绑定到客户端，否则在服务停止时，系统会将其销毁 — onDestroy() 是接收到的唯一回调。 其他知识点Service和Thread的关系答案：Service和Thread之间没有任何关系！ 两者概念的迥异 Thread 是程序执行的最小单元，它是分配CPU的基本单位，Android系统中UI线程也是线程的一种，当然Thread还可以用于执行一些耗时异步的操作。 Service是Android的一种机制，服务是运行在主线程上的，它是由系统进程托管。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是Binder，它是在linux层交换信息的一种IPC，而所谓的Service后台任务只不过是指没有UI的组件罢了。 两者的执行任务迥异 在Android系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作。如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。 Service 则是Android系统中的组件，一般情况下它运行于主线程中，因此在Service中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称Service为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让Service执行耗时任务，可在Service中开启单独线程去执行。 两者使用场景 当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程Thread，这样才能保证UI线程不被占用而影响用户体验。 在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过Service+Notification方式在后台执行同时在通知栏显示着。 两者的最佳使用方式在大部分情况下，Thread和Service都会结合着使用，比如下载文件，一般会通过Service在后台执行+Notification在通知栏显示+Thread异步下载，再如应用程序会维持一个Service来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个Thread与Service的结合来方便我们执行后台耗时任务，它就是IntentService，(深入了解IntentService，可以看IntentService)，当然IntentService并不适用于所有的场景，但它的优点是使用方便、代码简洁，不需要我们创建Service实例并同时也创建线程，某些场景下还是非常赞的！由于IntentService是单个worker thread，所以任务需要排队，因此不适合大多数的多任务情况。还有为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联(通过绑定)，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 Service的种类按运行地点分类 类别 区别 优点 缺点 应用 本地服务(Local) 该服务依附在主进程上 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。 主进程被Kill后，服务便会终止。 非常常见的应用如：音乐播放服务。 远程服务(Remote) 该服务是独立的进程 服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 一些提供系统服务的Service，这种Service是常驻的。 按运行类型分类 类别 区别 应用 前台服务 会在通知一栏显示 ONGOING 的 Notification， 当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。 后台服务 默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。 当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。 有同学可能会问，后台服务我们可以自己创建ONGOING的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground（ android 2.0 及其以后版本 ）或 setForeground（android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification任然会移除掉。 #### 按使用方式分类 类别 区别 startService 启动的服务 主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService bindService 启动的服务 该方法启动的服务要进行通信。停止服务使用unbindService startService 同时也 bindService 启动的服务 停止服务应同时使用stepService与unbindService 特别注意:1、你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService 解除绑定（尽管 Activity被 finish 的时候绑定会自动解除，并且Service会自动停止）；2、你应当注意 使用startService启动服务之后，一定要使用 stopService停止服务，不管你是否使用bindService； 3、同时使用 startService 与 bindService 要注意到，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context不存在了（如Activity被finish 的时候）之后服务才会自动停止；4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context不存在了），对应服务的生命周期与上述相同。5、在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用onStartCommand而不是 onStart。 这两种启动方式生命周期可以参考Android Service本地服务详解 onStartCommand详解第一次调用startService方法时，onCreate方法、onStartCommand``方法将依次被调用，而多次调用startService时，只有onStartCommand方法被调用，最后我们调用stopService方法停止服务时onDestory方法被回调，这就是启动状态下Service的执行周期。接着我们重新回过头来进一步分析onStartCommand（Intent intent, int flags, int startId），这个方法有3个传入参数，它们的含义如下： intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下： START_FLAG_REDELIVERY这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。 START_FLAG_RETRY该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。 startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。 另外，我们注意到onStartCommand()的返回值是一个很奇怪的值START_STICKY，这是个什么呢？或者说这个方法的返回值是用来干嘛的呢？事实上，它的返回值是用来指定系统对当前线程的行为的。它的返回值必须是以下常量之一： START_NOT_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但绝对不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 关于启动服务与绑定服务间的转换问题虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个Service创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个Service实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况： 先绑定服务后启动服务如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主Activity被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。 先启动服务后绑定服务如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法抑或内存不足时才会销毁服务。 以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论Service是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用Activity那样通过调用Intent 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。 参考Android中的Service：默默的奉献者 (1) Android Developers/Docs/指南/服务 全面了解 Service 关于Android Service真正的完全详解，你需要知道的一切]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal 源码分析]]></title>
    <url>%2Fposts%2F26c77b42.html</url>
    <content type="text"><![CDATA[基本介绍ThreadLocal类是java.lang包下的一个类，用于线程内部的数据存储，通过它可以在指定的线程中存储数据，本文针对该类进行原理分析。 使用场景我们一般用ThreadLocal来提供线程局部变量。线程局部变量会在每个Thread内拥有一个副本，Thread只能访问自己的那个副本。 用例1234567891011121314151617181920public class ThreadLocalTest &#123; private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;()&#123; protected Integer initialValue()&#123; return 0; &#125; &#125;; // 值传递 @Test public void testValue()&#123; for (int i = 0; i &lt; 5; i++)&#123; new Thread(() -&gt; &#123; Integer temp = threadLocal.get(); threadLocal.set(temp + 5); System.out.println("current thread is " + Thread.currentThread().getName() + " num is " + threadLocal.get()); &#125;, "thread-" + i).start(); &#125; &#125;&#125; 以上程序的输出结果是: 12345current thread is thread-1 num is 5current thread is thread-3 num is 5current thread is thread-0 num is 5current thread is thread-4 num is 5current thread is thread-2 num is 5 我们可以看到，每一个线程打印出来的都是5，哪怕我是先通过ThreadLocal.get()方法获取变量，然后再set进去，依然不会进行重复叠加。 这就是线程隔离。 源码分析ThreadLocalset123456789101112131415161718192021/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; //获得当前线程 Thread t = Thread.currentThread(); //获取该线程的ThreadLocalMap对象 ThreadLocalMap map = getMap(t); if (map != null) //将数据放入ThreadLocalMap中，key是当前ThreadLocal对象，值是我们传入的value。 map.set(this, value); else //初始化ThreadLocalMap，并以当前ThreadLocal对象为Key，value为值存入map中。 createMap(t, value);&#125; ThreadLocal#set()方法主要是通过当前线程的ThreadLocalMap实现的。ThreadLocalMap是一个Map，它的key是ThreadLoacl，value是Object。 get1234567891011121314151617181920212223/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); //获取当前线程的ThreadLocalMap对象 ThreadLocalMap map = getMap(t); //若该线程的ThreadLocalMap对象已存在，则直接获取该Map里的值；否则则通过初始化函数创建1个ThreadLocalMap对象 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 大体上与set方法类似，就是先获取到当前线程的ThreadLocalMap，然后以this为key可以取得value remove12345678910111213141516/** * Removes the current thread's value for this thread-local * variable. If this thread-local variable is subsequently * &#123;@linkplain #get read&#125; by the current thread, its value will be * reinitialized by invoking its &#123;@link #initialValue&#125; method, * unless its value is &#123;@linkplain #set set&#125; by the current thread * in the interim. This may result in multiple invocations of the * &#123;@code initialValue&#125; method in the current thread. * * @since 1.5 */ public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; 到这里我们基本上明白了ThreadLocal的工作原理，我们总结一下 每个Thread实例内部都有一个ThreadLocalMap，ThreadLocalMap是一种Map，它的key是ThreadLocal，value是Object。 ThreadLocal#set()方法其实是往当前线程的ThreadLocalMap中存入数据，其key是当前ThreadLocal对象，value是set方法中传入的值。 使用数据时，以当前ThreadLocal为key，从当前线程的ThreadLocalMap中取出数据。 ThreadLocalMapThreadLocal的核心就是ThreadLocalMap,它是维护我们线程与变量之间关系的一个类。 Entry内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The initial capacity -- MUST be a power of two. * Entry数组的初始化大小 */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. * &lt;ThreadLocal, 保存的泛型值&gt;数组 * 长度必须是2的N次幂 * 这个可以参考为什么HashMap里维护的数组也必须是2的N次幂 * 主要是为了减少碰撞，能够让保存的元素尽量的分散 * 关键代码还是hashcode &amp; table.length - 1 */ private Entry[] table; /** * The number of entries in the table. * table里的元素个数 */ private int size = 0; /** * The next size value at which to resize. * 扩容的阈值 */ private int threshold; // Default to 0 /** * Set the resize threshold to maintain at worst a 2/3 load factor. * 根据长度计算扩容的阈值 */ private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; /** * Increment i modulo len. * 获取下一个索引，超出长度则返回0 */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * Decrement i modulo len. * 返回上一个索引 */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; /** * Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it. */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; // 初始化table的大小为16 table = new Entry[INITIAL_CAPACITY]; // 通过hashcode &amp; （长度-1）的位运算，确定键值对的位置 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); // 创建一个新节点保存在table当中 table[i] = new Entry(firstKey, firstValue); // 设置table内元素为1 size = 1; // 设置扩容阈值 setThreshold(INITIAL_CAPACITY); &#125; /** * Construct a new map including all Inheritable ThreadLocals * from given parent map. Called only by createInheritedMap. * * ThreadLocal本身是线程隔离的，按道理是不会出现数据共享和传递的行为的 * 这是InheritableThreadLocal提供了了一种父子间数据共享的机制 * @param parentMap the map associated with parent thread. */ private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings("unchecked") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125;&#125; 我们可以看到，在ThreadLocalMap这个内部类当中，又定义了一个Entry内部类，它是一个WeakReference准去的说继承自弱引用 ThreadLocal对象的引用被传到WeakReference的reference中，entry.get()被当作map元素的key，而Entry还多了一个字段value，用来存放ThreadLocal变量实际的值。 至于为什么要用弱引用呢？我想我源码上面的注释其实也写得很明白了，这ThreadLocal实际上就是个线程本地变量隔离作用的工具类而已，当线程走完了，肯定希望能回收这部分产生的资源，所以就用了弱引用。 由于是弱引用，若ThreadLocal对象不再有普通引用，GC发生时会将ThreadLocal对象清除。而Entry的key，即entry.get()会变为null。然而，GC只会清除被引用对象，Entry还被线程的ThreadLocalMap引用着，因而不会被清除。因而，value对象就不会被清除。除非线程退出，造成该线程的ThreadLocalMap整体释放，否则value的内存就无法释放，内存泄漏！ JDK的作者自然想到了这一点，因此在ThreadLocalMap的很多方法中，调用expungeStaleEntries()清除entry.get() == null 的元素，将Entry的value释放。所以，只要线程还在使用其他ThreadLocal，已经无效的ThreadLocal内存就会被清除。 然而，我们大部分的使用场景是，ThreadLocal是一个静态变量，因此永远有普通引用指向每个线程中的ThreadLocalMap的该entry。因此该ThreadLocal的Entry永远不会被释放，自然expungeStaleEntries()就无能为力，value的内存也不会被释放。所以在我们确实用完了ThreadLocal后，可以主动调用remove()方法，主动删掉entry。 我相信有人会有疑问，如果在我要用的时候，被回收了怎么办？下面的代码会一步步地让你明白，你考虑到的问题，这些大牛都已经想到并且解决了。接着看 getEntry &amp;&amp; getEntryAfterMiss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; // 通过hashcode确定下标 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; // 如果找到则直接返回 if (e != null &amp;&amp; e.get() == key) return e; else // 找不到的话接着从i位置开始向后遍历，基于线性探测法，是有可能在i之后的位置找到的 return getEntryAfterMiss(key, i, e);&#125;/** * Version of getEntry method for use when key is not found in * its direct hash slot. * * @param key the thread local object * @param i the table index for key's hash code * @param e the entry at table[i] * @return the entry associated with key, or null if no such */private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; // 循环向后遍历 while (e != null) &#123; // 获取节点对应的k ThreadLocal&lt;?&gt; k = e.get(); // 相等则返回 if (k == key) return e; // 如果为null，触发一次连续段清理 if (k == null) expungeStaleEntry(i); else // 获取下一个下标接着进行判断 i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; expungeStaleEntry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). * 这个函数可以看做是ThreadLocal里的核心清理函数，它主要做的事情就是 * 1、从staleSlot开始，向后遍历将ThreadLocal对象被回收所在Entry节点的value和Entry节点本身设置null，方便GC，并且size自减1 * 2、并且会对非null的Entry节点进行rehash，只要不是在当前位置，就会将Entry挪到下一个为null的位置上 * 所以实际上是对从staleSlot开始做一个连续段的清理和rehash操作 */private int expungeStaleEntry(int staleSlot) &#123; // 新的引用指向table Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot // 先将传过来的下标置null tab[staleSlot].value = null; tab[staleSlot] = null; size--;// table的size-1 // Rehash until we encounter null Entry e; int i; // 遍历删除指定节点所有后续节点当中，ThreadLocal被回收的节点 for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; // 获取entry当中的key ThreadLocal&lt;?&gt; k = e.get(); // 如果ThreadLocal为null，则将value以及数组下标所在位置设置null，方便GC if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; // 重新计算key的下标 int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // 如果是当前位置则遍历下一个 // 不是当前位置，则重新从i开始找到下一个为null的坐标进行赋值 // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 这可以说是ThreadLocal非常核心的一个清理方法，为什么会需要清理呢？或许很多人想不明白，我们用List或者是Map也好，都没有说要清理里面的内容。 但是这里是对于线程来说的隔离的本地变量，并且使用的是弱引用，那便有可能在GC的时候就被回收了。 如果有很多Entry节点已经被回收了，但是在table数组中还留着位置，这时候不清理就会浪费资源 在清理节点的同时，可以将后续非空的Entry节点重新计算下标进行排放，这样子在get的时候就能快速定位资源，加快效率。 set1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Set the value associated with key. * ThreadLocalMap的set方法，这个方法还是挺关键的 * 通过这个方法，我们可以看出该哈希表是用线性探测法来解决冲突的 * @param key the thread local object * @param value the value to be set */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. // 新开一个引用指向table Entry[] tab = table; // 获取table的长度 int len = tab.length; // 获取对应ThreadLocal在table当中的下标 int i = key.threadLocalHashCode &amp; (len-1); /** * 从该下标开始循环遍历 * 1、如遇相同key，则直接替换value * 2、如果该key已经被回收失效，则替换该失效的key */ for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; // 如果 k 为null，则替换当前失效的k所在Entry节点 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 找到空的位置，创建Entry对象并插入 tab[i] = new Entry(key, value); // table内元素size自增 int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; // 新开一个引用指向table Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). // 记录当前失效的节点下标 int slotToExpunge = staleSlot; /** * 通过这个for循环的prevIndex(staleSlot, len)可以看出 * 这是由staleSlot下标开始向前扫描 * 查找并记录最前位置value为null的下标 */ for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first /** * 通过for循环nextIndex(staleSlot, len)可以看出 * 这是由staleSlot下标开始向后扫描 */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. /** * 如果与新的key对应，直接赋值value * 则直接替换i与staleSlot两个下标 */ if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists // 通过注释看出，i之前的节点里，没有value为null的情况 if (slotToExpunge == staleSlot) slotToExpunge = i; /** * 在调用cleanSomeSlots进行启发式清理之前 * 会先调用expungeStaleEntry方法从slotToExpunge到table下标所在为null的连续段进行一次清理 * 返回值便是table[]为null的下标 * 然后以该下标--len进行一次启发式清理 * 最终里面的方法实际上还是调用了expungeStaleEntry * 可以看出expungeStaleEntry方法是ThreadLocal核心的清理函数 */ cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. /** * 如果当前下标所在已经失效，并且向后扫描过程当中没有找到失效的Entry节点 * 则slotToExpunge赋值为当前位置 */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot // 如果并没有在table当中找到该key，则直接在当前位置new一个Entry tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); /** * 在上面的for循环探测过程当中 * 如果发现任何无效的Entry节点，则slotToExpunge会被重新赋值 * 就会触发连续段清理和启发式清理 */ // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; 12345678910111213141516171819202122232425262728/** * 启发式地清理被回收的Entry * i对应的Entry是非无效的，有可能是失效被回收了，也有可能是null * 会有两个地方调用到这个方法 * 1、set方法，在判断是否需要resize之前，会清理并rehash一遍 * 2、替换失效的节点时候，也会进行一次清理 */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; // Entry对象不为空，但是ThreadLocal这个key已经为null if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; /** * 调用该方法进行回收 * 实际上不是只回收 i 这一个节点而已 * 而是对 i 开始到table所在下标为null的范围内，对那些节点都进行一次清理和rehash */ i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * Double the capacity of the table. */private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; /** * 从下标0开始，逐个向后遍历插入到新的table当中 * 1、如遇到key已经为null，则value设置null，方便GC回收 * 2、通过hashcode &amp; len - 1计算下标，如果该位置已经有Entry数组，则通过线性探测向后探测插入 */ for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; // 重新设置扩容的阈值 setThreshold(newLen); // 更新size size = count; // 指向新的Entry数组 table = newTab;&#125; 以上的代码就是调用set方法往ThreadLocalMap当中保存K-V关系的一系列代码，我就不分开再一个个讲了，这样大家看起来估计也比较方便，有连续性。 ​ 我们可以来看看一整个的set流程： ​ 1、先通过hashcode &amp; (len - 1)来定位该ThreadLocal在table当中的下标i ​ 2、从i开始for循环向后遍历 ​ 1）如果获取Entry节点的key与我们需要操作的ThreadLocal相等，则直接替换value ​ 2）如果遍历的时候拿到了key为null的情况，则调用replaceStaleEntry方法进行与之替换。 ​ 3、如果上述两个情况都是，则直接在计算的出来的下标当中new一个Entry阶段插入。 ​ 4、进行一次启发式地清理并且如果插入节点后的size大于扩容的阈值，则调用resize方法进行扩容。 remove12345678910111213141516private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; // 将引用设置null，方便GC e.clear(); // 从该位置开始进行一次连续段清理 expungeStaleEntry(i); return; &#125; &#125;&#125; 我们可以看到，remove节点的时候，也会使用线性探测的方式，当找到对应key的时候，就会调用clear将引用指向null，并且会触发一次连续段清理。 总结借用张流程图，来自https://juejin.im/post/5ca225adf265da30cd1847f3 内存分析不知从何时起，网上开始流传ThreadLocal有内存泄漏的问题。下面我们从ThreadLocal的内存入手，分析一下这种说法是否正确。话不多说直接上图。 现在，我们假设ThreadLocal完成了自己的使命，与ThreadLocalRef断开了引用关系。此时内存图变成了这样。 系统GC发生时，由于Heap中的ThreadLocal只有来自key的弱引用，因此ThreadLocal内存会被回收到。 到这里，value被留在了Heap中，而我们没办法通过引用访问它。value这块内存将会持续到线程结束。导致内存泄漏。 其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。这样就能 一定情况下避免内存泄漏。 123456789101112131415private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); ... if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125;&#125; ThreadLocal get方法获取时，有一段如果Entry的key为null，移除Entry和Entry.value的代码 1234567891011121314151617181920212223242526private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; ... &#125; return i;&#125; 但是这些被动的预防措施并不能保证不会内存泄漏： 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。 如果不想依赖线程的生命周期,那就调用remove方法来释放value的内存吧。个人认为，这种设计应该也是JDK开发大佬的无奈之举。 还可以参考Java进阶（七）正确理解Thread Local的原理与适用场景 其他知识点为什么使用弱引用从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？ 我们先来看看官方文档的说法： To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. 为了应对非常大和长时间的用途，哈希表使用弱引用的 key。** 下面我们分两种情况讨论： key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。 key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。 ThreadLocal 最佳实践综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？ 每次使用完ThreadLocal，都调用它的remove()方法，清除数据。 在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。 跨线程传递参考揭开ThreadLocal的面纱#跨线程传递 ThreadLocal 如何解决 Hash 冲突？我们知道，HashMap是一种get、set都非常高效的集合，它的时间复杂度只有O(1)。但是如果存在严重的Hash冲突，那HashMap的效率就会降低很多。 与 HashMap 不同，ThreadLocalMap 结构非常简单，没有 next 引用，也就是说 ThreadLocalMap 中解决 Hash 冲突的方式并非链表的方式，而是采用线性探测的方式。所谓线性探测，就是根据初始 key 的 hashcode 值( key.threadLocalHashCode &amp; (len-1))确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。len是当前Entry[]的长度，这没什么好说的。那看来秘密就在threadLocalHashCode中了。我们来看一下threadLocalHashCode是如何产生的。 123456789101112 public class ThreadLocal&lt;T&gt; &#123; private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125;&#125; 这段代码非常简单。有个全局的计数器nextHashCode，每有一个ThreadLocal产生这个计数器就会加0x61c88647，然后把当前值赋给threadLocalHashCode。关于0x61c88647这个神奇的常量，可以点这里。 为什么ThreadLocal类内部的ThreadLocalMap要用Entry数组实现？set方法只会设置一个值，直接用一个Entry不就解决问题了？为什么会涉及到数组，还会有数组扩容的问题？ 首先明确一下ThreadLocal的set和get的过程 调用get() 获取当前线程Thread对象，进而获取此线程对象中维护的ThreadLocalMap对象。 判断当前的ThreadLocalMap是否存在,如果存在，则以当前的ThreadLocal 为 key，调用ThreadLocalMap中的getEntry方法获取对应的存储实体 e。找到对应的存储实体 e，获取存储实体 e 对应的 value值，即为我们想要的当前线程对应此ThreadLocal的值，返回结果值。 如果不存在，则证明此线程没有维护的ThreadLocalMap对象，调用setInitialValue方法进行初始化。返回setInitialValue初始化的值。 调用set(T value) 获取当前线程Thread对象，进而获取此线程对象中维护的ThreadLocalMap对象。 判断当前的ThreadLocalMap是否存在： 如果存在，则调用map.set设置此实体entry。 如果不存在，则调用createMap进行ThreadLocalMap对象的初始化，并将此实体entry作为第一个值存放至ThreadLocalMap中。 总结起来就是ThreadLocal#get() 方法中首先取当前线程然后从当前线程对象中获取 threadLocals 属性这个属性就是 ThreadLocalMap 的一个对象既然一个线程只对应一个 Thread 对象那么一个线程中也就只有一个 ThreadLocalMap 对象而一个程序中可以创建多个 ThreadLocal 对象在同一个线程中都会访问到这个 Mapkey就是一个指向threadLocal实例的一个弱引用多个ThreadLocal实例的话，那么就key必然是不同的那么这个 Map 就必须存储多个 value 值并考虑扩容 此题来自知乎https://www.zhihu.com/question/279007680 ThreadLocal实现原理是什么通常，如果我不去看源代码的话，我猜ThreadLocal是这样子设计的：每个ThreadLocal类都创建一个Map，然后用线程的ID threadID作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的值隔离的效果。这是最简单的设计方法，JDK最早期的ThreadLocal就是这样设计的。 但是，JDK后面优化了设计方案，现时JDK8 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。 这个设计与我们一开始说的设计刚好相反，这样设计有如下几点优势： 这样设计之后每个Map存储的Entry数量就会变小，因为之前的存储数量由Thread的数量决定，现在是由ThreadLocal的数量决定。 当Thread销毁之后，对应的ThreadLocalMap也会随之销毁，能减少内存的使用。 与同步机制区别 类型 实现机制 同步共享 应用场景 ThreadLocal 为每个线程都提供一个变量的副本，从而实现同时访问，而互不影响。(以空间换时间) 无需对该变量进行同步(每个线程都拥有自己的变量副本) 隔离多个线程的数据共享 同步机制 提供一个变量，让不同的线程排队访问(以时间换空间) 被作用”锁机制”的变量是多个线程共享的- 通过对象的锁机制保证同一时间只有一个线程访问变量- synchronized = 1个保留字，依靠JVM的锁机制来实现临界区的函数or变量的访问中的原子性 同步多个线程对相同资源的并发访问，防止并发冲突 更多参考ThreadLocal和synchronized的区别? 参考ThreadLocal用法及原理 Java多线程：神秘的线程变量 ThreadLocal 你了解吗？ 深入理解ThreadLocal ThreadLocal和ThreadLocalMap源码分析 揭开ThreadLocal的面纱 ThreadLocal内存泄漏问题及如何解决 Java 200+ 面试题补充 ThreadLocal 模块 JAVA并发-自问自答学ThreadLocal]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService 源码分析]]></title>
    <url>%2Fposts%2Fe4e64342.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 framework/base/core/java/andorid/app/IntentService.java IntentService简介IntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题： Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中 Service 也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。 Service主要用来在后台进行任务处理，例如后台播放音乐、下载文件、上传文件等等。由于Service是运行在主线程中的，也有一定的时间限制，如果在主线程中对一个任务的处理时间超过了限制，进程就会出现“应用不响应”,即ANR, Application Not Responding。为了避免这样情况,一般都会在Service里用新的thread处理一些可能需要更多处理时间的任务。 其实Android早就替我们设计了一种更方便的Service + Thread模式，就是本文要讲的IntentService，通过它可以很方便地实现在Service中使用Thread进行耗时任务的处理。 基础用法扩展 IntentService 类以下是 IntentService 的实现示例： 123456789101112131415161718192021222324252627public class HelloIntentService extends IntentService &#123; /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() &#123; super("HelloIntentService"); &#125; /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; &#125;&#125; 您只需要一个构造函数和一个 onHandleIntent() 实现即可。 如果您决定还重写其他回调方法（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现，以便 IntentService 能够妥善处理工作线程的生命周期。 例如，onStartCommand() 必须返回默认实现（即，如何将 Intent 传递给 onHandleIntent()）： 12345@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId);&#125; 除 onHandleIntent() 之外，您无需从中调用超类的唯一方法就是 onBind()（仅当服务允许绑定时，才需要实现该方法）。 在下一部分中，您将了解如何在扩展 Service 基类时实现同类服务。该基类包含更多代码，但如需同时处理多个启动请求，则更适合使用该基类。 扩展服务类正如上一部分中所述，使用 IntentService 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 Service 类来处理每个 Intent。 为了便于比较，以下提供了 Service 类实现的代码示例，该类执行的工作与上述使用 IntentService 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HelloService extends Service &#123; private Looper mServiceLooper; private ServiceHandler mServiceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread thread = new HandlerThread("ServiceStartArguments", Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread's Looper and use it for our Handler mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; mServiceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // We don't provide binding, so return null return null; &#125; @Override public void onDestroy() &#123; Toast.makeText(this, "service done", Toast.LENGTH_SHORT).show(); &#125;&#125; 正如您所见，与使用 IntentService 相比，这需要执行更多工作。 但是，因为是由您自己处理对 onStartCommand() 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。 请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。以上大部分来自官方文档 源码分析创建工作线程123456789101112public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 当IntentService第一次启动的时候会调用其onCreate来完成一些初始化操作： 首先创建了一个HandlerThread对象，这就是前面一直提到的Worker线程。大家对Handler和Thread都很了解，那这个HandlerThread是什么呢？简单来说，它就是内部有一个消息循环队列的线程，我们知道默认的线程内部是没有消息循环队列的，这就导致我们无法直接在其内部使用Handler。Android为了方便使用，直接提供了一个含有消息循环队列的HandlerThread。具体见HandlerThread 源码分析 利用已创建的HandlerThread内部的消息循环创建一个 ServiceHandler对象，这样它的消息处理函数handleMessage就会在对应的线程中执行了。 接收和处理请求我们其他组件通过startService来发送请求的，结合service的生命周期，会执行onStartCommand回调 1234public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125; 1234567@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; 从这段代码看到，onStartCommand会直接调用onStart，在这里对发送过来的请求接收并通过mServiceHandler进行处理。 1234567891011private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125; 在handleMessage中对接收到的请求用onHandleIntent进行实际处理，而onHandleIntent就是我们在使用过程中必须实现的处理逻辑。 销毁Worker线程前面提到：当所有请求都被处理完成后，service就会被销毁，这是如何实现的呢？在上面看到handleMessage方法里在处理完当前请求时会调用stopSelf(msg.arg1)来尝试停止当前服务，之所以说“尝试”，是因为它不一定能真正停止服务。还是来看下stopSelf(int)的实现代码： 123456789101112131415/** * Old version of &#123;@link #stopSelfResult&#125; that doesn't return a result. * * @see #stopSelfResult */public final void stopSelf(int startId) &#123; if (mActivityManager == null) &#123; return; &#125; try &#123; mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125;&#125; 1234567891011public final boolean stopSelfResult(int startId) &#123; if (mActivityManager == null) &#123; return false; &#125; try &#123; return mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125; return false;&#125; 在stopSelf(int)的声明里提到它是stopSelfResult(int)的老版本，唯一的区别就是没有返回值。那我们直接看stopSelfResult(int)的声明，其中提到只有在当前的service的最近一次启动是startId发起的才会被停止。我们把这句话放在IntentService的场景里去理解，如果说当前接收到3个请求，在处理第一个请求后打算去停止服务，但是调用stopSelf(int)的时候发现最后一次启动是第三个请求发生的，并不会停止服务；处理完第二个请求后是类似的，只有在处理完第三个请求后，去尝试停止服务，这时发现最近一次启动就是它发起的，可以去停止服务了。 停止服务时，其onDestroy会得到调用： 1234@Overridepublic void onDestroy() &#123; mServiceLooper.quit();&#125; 具体的用法例子可以参考IntentService 示例与详解 总结IntentService相比父类Service而言，最大特点是其回调函数onHandleIntent中可以直接进行耗时操作，不必再开线程。其原理是IntentService的成员变量 Handler在初始化时已属于工作线程，之后handleMessage，包括onHandleIntent等函数都运行在工作线程中。 如果对IntentService的了解仅限于此，会有种IntentService很鸡肋的观点，因为在Service中开线程进行耗时操作也不麻烦。我当初也是这个观点，所以很少用IntentService。 但是IntentService还有一个特点，就是多次调用onHandleIntent函数（也就是有多个耗时任务要执行），多个耗时任务会按顺序依次执行。原理是其内置的Handler关联了任务队列，Handler通过Looper取任务执行是顺序执行的。 这个特点就能解决多个耗时任务需要顺序依次执行的问题。而如果仅用Service，开多个线程去执行耗时操作，就很难管理。 由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。 IntentService特征 会创建独立的worker线程用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。 创建worker队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。 所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service 为Service的onBind()提供默认实现，返回null 为Service的onStartCommand提供默认实现，可将Intent 依次发送到工作队列和 onHandleIntent() 实现。 IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常 可以启动IntentService 多次，而每一个耗时操作会以工作队列的方式在IntentService 的 onHandleIntent 回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推` 参考IntentService的实际应用场景理解 IntentService 原理]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread 源码分析]]></title>
    <url>%2Fposts%2Fb4da2c1c.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码 framework/base/core/java/andorid/os/HandlerThread.java 使用简介在Handler源码分析中我们提到,在子线程中创建Handler,要手动调用Looper.prepare(),创建的过程大致如下 123456789101112Handler mHandler;private void createManualThreadWithHandler() &#123; new Thread() &#123; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler(Looper.myLooper()); Looper.loop(); &#125; &#125;.start();&#125; Android为了简化Handler的创建过程提供了一个便捷的类，使用它我们可以快速的创建一个带有Looper的线程，有了Looper这个线程，我们就可以生成Handler。 如何使用1234567891011121314// Step 1: 创建并启动HandlerThread线程，内部包含LooperHandlerThread handlerThread = new HandlerThread("lingdage");handlerThread.start();// Step 2: 创建HandlerHandler handler = new Handler(handlerThread.getLooper());// Step 3: 发送消息handler.post(new Runnable() &#123; @Override public void run() &#123; System.out.println("thread id="+Thread.currentThread().getId()); &#125;&#125;); 源码分析创建HandlerThread对象12345678910public HandlerThread(String name) &#123; super(name); //HandlerThread的默认优先级是Process.THREAD_PRIORITY_DEFAULT,具体值为0。 mPriority = Process.THREAD_PRIORITY_DEFAULT;&#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority;&#125; 线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。注意！是Process里的优先级而不是Thread的。 可控制的优先级 THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。 THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。 THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。 THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。 THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。 以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。 常见的加入优先级的方法如下 123456Runnable run = new Runnable() &#123; @Override public void run() &#123; android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); &#125;&#125;; 关于Android中线程的调度详情，请参考剖析Android中进程与线程调度之nice 获取Looper1234567891011121314151617181920212223/** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */public Looper getLooper() &#123; //使用handlerThread 要先start if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; // 进入同步块，当条件不满足时无限等待， try &#123; // 直到mLooper被设置成有效值了才退出while（当然也可能是线程状态不满足）； wait(); // run方法里的notifyAll就是用来唤醒这里的 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; 这个方法比较简单，直接看官方的注释就明白了。 执行HandlerThread的run()123456789101112public void run() &#123; mTid = Process.myTid(); //获取线程的tid Looper.prepare(); // 创建Looper对象 synchronized (this) &#123; mLooper = Looper.myLooper(); //获取looper对象 notifyAll(); //唤醒等待线程 &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); // 重写 onLooperPrepared，做一些初始化工作 Looper.loop(); //loop方法是阻塞的 在未执行quit()或quitSafely()的时候后面代码是不执行的 mTid = -1;&#125; Looper退出12345678 public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125; 12345678public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false;&#125; quit()与quitSafely()的区别，仅仅在于是否移除当前正在处理的消息。移除当前正在处理的消息可能会出现不安全的行为。 使用场景总结之前，我们先想一个场景，如果我们现在需要请求网络数据(假设需要请求一张图片,图片请求返回后需要更新UI),我们都知道UI线程中不允许进行耗时的网络请求。那么，我们通常会开启一个子线程来进行请求,如果你不用网络请求的三方库，一般会通过new Thread(),然后start()来完成吧！这样的话，如果有多次请求图片，那么我们就得new 很多个Thread。所以这是个问题！！！ 问题解决分析通过上面代码我们知道：HandlerThread一个子线程，并且含有一个Looper。 再来看看那个问题：我们之所以需要new Thread(),然后start().是因为UI线程无法进行网络请求，但是，HandlerThread可是一个子线程，所以，在它里面可以直接请求网络，于是上面的new Thread()然后start()问题就解决了。当然，就凭他是个子线程还没法说服我，虽然它是一个子线程不需要new Thread()，但是它自己也可能需要多次创建啊！只不过是从new一个Thread变成了new HanderThread()而已。这还不是没卵用。 那么如何解释它不需要重复创建呢？其实也不难，只需要子线程不结束不就行了。(run方法中加个while(true)啊)，不过，它这里并不是while(true),而是用到了调用了一个loop()方法。 loop方法是阻塞的，所以它后面的语句在它未退出的（可以通过quit()方法和quitSafely()方法退出）时候是没办法执行的。再加上它可以通过在外部实现一个Handler，然后，通过这个Handler给Looper发送message，近而源源不断的实现网络请求。所以，这就真正的解决了上面提出的那个问题。这里给一个连接，里面介绍了如何在外部创建一个Handler,然后源源不断进行网络请求。Android 多线程之HandlerThread 完全详解 总结HandlerThread所做的就是在新开的子线程中创建了 Looper，那它的使用场景就是 Thread+Looper使用场景的结合，即：在子线程中执行耗时的、可能有多个任务的操作。 HandlerThread比较适用于单线程+异步队列的场景，比如IO读写操作，耗时不多而且也不会产生较大的阻塞。对于网络IO操作，HandlerThread并不适合，因为它只有一个线程，还得排队一个一个等着。 对于本地IO读取操作，我们可以使用postAtFrontOfQueue方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。 使用 HandlerThread 的典型例子就是 IntentService，参考另一篇文章。IntentService 源码分析 参考Android消息机制3-Handler(实战) HandlerThread 对HandlerThread的理解 Android 进阶15：HandlerThread 使用场景及源码解析]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler源码分析]]></title>
    <url>%2Fposts%2F20470e2e.html</url>
    <content type="text"><![CDATA[本文基于Android 9.0.0的源代码，来分析Handler的用法 12345framework/base/core/java/andorid/os/ - Handler.java - Looper.java - Message.java - MessageQueue.java Handler作用 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行 线程切换：执行耗时的操作，比如网络请求，IO操作等，需要在子线程中运行，不然会阻塞主线程。而执行完网络请求等耗时操作后通常需要更新UI，如果在子线程中更新UI，那么程序会崩溃。因为Android的UI是线程不安全的。 在Android中使用Rxjava，还要配合RxAndroid来使用，RxAndroid 内部就使用 Handler 来实现线程切换。 常见错误常见的子线程中更新UI,复现代码,更具体见 Android子线程和更新UI问题 1234567textView = (TextView) findViewById(R.id.txt); new Thread(new Runnable() &#123; public void run() &#123; SystemClock.sleep(3000);//这句不加不会报错，具体分析见上面链接 textView.setText("from来自子线程"); &#125; &#125;).start(); 运行异常信息 1234567891011121314ErrorInfo: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6903) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1050) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.view.View.requestLayout(View.java:19785) at android.widget.TextView.checkForRelayout(TextView.java:7368) at android.widget.TextView.setText(TextView.java:4480) at android.widget.TextView.setText(TextView.java:4337) at android.widget.TextView.setText(TextView.java:4312) 可以看到错误发生在android.view.ViewRootImpl#checkThread 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 可见此处会判断mThread是不是等于当前线程看下mThread到底是啥，在何处赋值的 12345public ViewRootImpl(Context context, Display display) &#123; ... mThread = Thread.currentThread(); ...&#125; 在构造方法中被赋值的，也就是说是创建ViewRootImpl时所在的线程ViewRootImpl又是在哪里被创建的呢?这里不深入讲了，是在main线程更具体的异常分析可以参考这个 基础用法1234567891011121314151617181920212223242526android.os.Handler handler = new Handler()&#123;//在主线程中获取handler @Override public void handleMessage(final Message msg) &#123; //这里接受并处理消息 &#125;&#125;;new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000);//子线程中执行耗时操作 //发送消息 Message message = Message.obtain(); message.what=1; message.obj=new Object(); handler.sendMessage(message); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start();new Handler().post(new Runnable() &#123; @Override public void run() &#123; //doSomething &#125;&#125;); 实例化一个 Handler 重写handleMessage方法 ，然后在需要的时候调用它的 send 以及 post系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档） 但是我们并没有看到Handler是如何与MessageQueue以及Looper关联起来的，下面我们进入源码分析下 Handler 源码分析Handler 实例化从构造函数开始,我们通常从主线程中创建,先看下Handler的构造函数有哪些 Handler() Handler(Callback callback) Handler(Looper looper) Handler(Looper looper, Callback callback) Handler(boolean async) Handler(Callback callback, boolean async) Handler(Looper looper, Callback callback, boolean async) 看最后两个构造方法就行，因为前面的几个也是依次调用到后的方法 先看Handler(Callback callback, boolean async) 123456789101112public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; Handler(Looper looper, Callback callback, boolean async)与上面的区别就是Looper是赋值进去的。 Looper 实例化由上面可以看到调用Looper#myLooper方法获取到Looper对象， 如果mLooper == null的话，会抛出异常 Can’t create handler inside thread that has not called Looper.prepare() 这个错误我们应该也见过。实际上我们在实例化 Handler 的时候 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 Looper 。我们平时一般不会遇到这个错，因为我们大多数都是在主线程创建Handler的，而为什么在主线程就不要自己创建Looper，我们待会再看，目前只需要知道如果Looper.myLooper()没有获取到Looper对象的话就会报这个错。 我们跟踪Looper#myLooper方法进去，解决为什么会抛出这个异常。 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 只有一行代码，从线程中取出Looper对象，那么我们有理由相信，这个ThreadLocal是通过set方法把Looper对象设置进去的。关于ThreadLocal，参考ThreadLocal 源码分析。 想一想ThreadLocal在哪里把Looper对象设置进去了呢。回到刚才想要解决的问题：Can’t create handler inside thread that has not called Looper.prepare() 。那会不会是Looper的prepare方法呢？ 12345678910public static void prepare() &#123; prepare(true); &#125;//调用私有构造方法 private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; ThreadLocal确实是在Looper#prepare方法里把Looper对象设置进去的，而且从第一行的判断可以知道，一个线程只有一个Looper对象。 所以，要创建Handler,那么Looper.myLooper()就必须非空，上面分析得出要非空，要先调用Looper.prepare()。 到了这里，Looper与ThreadLocal建立起了关联。 MessageQueue 实例化接着上面继续看下Looper的构造方法 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个MessageQueue，相比于 Looper 和Handler，MessageQueue就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。可以在 android_os_MessageQueue 查看其源码的定义。更多参考MessageQueue 的实例化 我们接着看Handle构造函数里的 mQueue = mLooper.mQueue 我们知道消息是存放在MessageQueue消息队列中的,而MessageQueue就是在上面Looper构造函数中new出来的，至此Handler通过Looper与MessageQueue也建立起了关联。 总结一下，创建Handler,他的构造函数中会先调用Looper.myLooper()获取Looper，也即是从ThreadLocal中获取，而ThreadLocal中要想获取到，要先调用Looper.prepare()来set值，那么问题又来了，我们写程序时好像没有手动调用Looper.prepare()吧，也不会抛出异常。其实这是一个特殊情况，我们通常都是在主线程，也就是UI线程中创建handler的。而在主线程中，系统已经为我们创建了一个Looper对象，所以不会抛出异常了,而那些会抛出异常报错的情况，是在子线程中创建的Handler，但是又没有调用Looper.prepare()去创建Looper对象。继续看，主线程在什么时候创建了Looper对象吧。 在ActivityThread的main方法，这个方法是应用程序的入口。 123456789101112131415161718public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; Looper.prepareMainLooper(); 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; 可以看到第一行还是调用了prepar(false）方法的(false代表不可退出)。所以主线程是已经创建了一个Looper对象的。 Handler的创建过程分析完毕，现在总算搞明白了。 Handler、MessageQueue 和 Looper 之间的关系最后再总结一下，Handler的创建是依赖于Looper的。而主线程是默认创建了一个Looper对象的。每一个Looper会关联一个线程（ThreadLocal中封装了Looper)。每一个Looper中又会封装一个消息队列。这样一来，Handler，Looper，MessageQueue，Thread四个角色就关联了起来。Handler在主线程中创建，是因为要和主线程的消息队列关联起来，那样Handler#handleMessage方法才会在主线程中执行，那么这样在更新UI就是线程安全的了。 Handler 发送消息过程回想开头我们基础用法里提到 Handler一般是通过一下2个方法发送的 handler.sendMessage(message);handler.post(runnable); 发送过程我们先从第一个开始分析 handler.sendMessage(message) 123456789101112131415161718192021public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; sendMessage会调用sendMessageDelayed方法并将message对象传进去，第二个参数是延时时间，使用sendMessage方法时默认为0的,最后都会调用sendMessageAtTime。 上面分析了，在创建Looper对象的时候，会创建一个MessageQueue，所以只要Looper是正常创建的话，消息队列是不为空的。那么到最后一行的enqueueMessage方法，源码如下 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 将handler本身赋值给msg.target msg.setAsynchronous(true设置message是否是异步的，这是message的一个属性。同一个Thread只有一个Looper，一个MessageQueue，但是可以有很多个Handler，如果Handler初始化的时候async参数是true，那么这个Handler所post的所有的message都会带上异步的属性。可以通过MessageQueue``的postSyncBarrier(long when)来向队列中插入一个同步分割栏，同步分割栏是一个特殊的message，这种message的target=null，就像一个卡子，当他被插入时，会卡住在这之后的所有的同步的message，只会摘取异步的message。当然也可以通过MessageQueue的removeSyncBarrier(int token)来移除这个同步分割栏，token就是postSyncBarrier方法的返回值。但是目前这两个方法都被hide了。所以大家一般用到的都只是普通的Message。(注:摘自从源码去理解Handler) 然后最终调用queue.enqueueMessage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; //消息是否正在使用 msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //很明显enqueueMessage需要同步,因为存在多个线程往一个Loop线程的MessageQueue中插入消息的场景。 //这里其实是将Message根据延时插入到特定的地方，先看下关键点1，mMessages其实代表消息队列的头部，如果mMessages为空，说明还没有消息，如果当前插入的消息不需要延时，或者说延时比mMessages头消息的延时要小，那么当前要插入的消息就需要放在头部 //至于是否需要唤醒队列，则需要根据当前的Loop线程的状态来判断，后面讲Loop线程的时候再回过头说； // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; //再来看下关键点2，这个时候需要将消息插入到队列中间，其实就是找到第一个Delay事件小于当前Message的非空Message，并插入到它的前面，往队列中插入消息时，如果Loop线程在睡眠，是不应该唤醒的，异步消息的处理会更加特殊一些，先不讨论。 //最后看关键点3，如果需要唤醒Loop线程，通过nativeWake唤醒，以上，就是普通消息的插入。 // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; Messagequeue中有一个对象mMessage用于指向当前传进的msg，即最新的消息。而刚才的sendMessageAtTime(Message msg, long uptimeMillis)方法，第二个参数指定了时间，然后在这里按照这个uptimeMillis来进行消息的排序，这样每一个消息都是按照时间的排序关联了起来，排在前面的消息指向了排在后面的消息。 以上是进入消息队列的分析，Handler调用sendMessage方法的最终将message对象传进Messagequeue。 取出消息那么消息是怎么从消息队列出来的呢？这时我们要回看ActiviryThread的main方法，去寻找点线索。源码在上面已贴出。发现了倒数第二行的Looper.loop()，简单理解就是消息执行循环操作。android.os.Looper#loop 1234567891011121314151617181920212223242526272829303132public static void loop() &#123; //确保MessageQueue准备好 final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; //for 无限循环，阻塞于消息队列的 next() 方法； //不断从队列中读取消息并移除，如果队列为空，阻塞等待 Message msg = queue.next(); // might block if (msg == null) &#123;//跳出循环，looper退出就是利用了这点 // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); ... &#125; finally &#123; ... &#125; ... //清理，回收到缓存池 msg.recycleUnchecked(); &#125; &#125; loop方法是个死循环，但是为什么不会卡死主线程呢，参考 Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ Handler后传篇一: 为什么Looper中的Loop()方法不能导致主线程卡死? 深入理解 MessageQueue loop内容有点复杂，借用一张图来看下 当我们调用 Looper#loop() 方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue#next()`` 方法来获取下一个消息的时候，会调用 nativePollOnce() 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper的作用就是通过阻塞消息队列获取消息的过程阻塞Looper。 再看下关键的Message msg = queue.next() 深入分析参见MessageQueue中Message消息的执行以及 MessageQueue 的消息管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109Message next() &#123; ... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //是否需要阻塞等待，第一次一定不阻塞 // 调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。 // 在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。 // 如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123;//互斥同步 // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //是否存在barier if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. //存在同步分隔栏，找到后面异步属性的msg do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; //第一个消息是否需要阻塞等待，并计算出阻塞等待时间 if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. //需要无限等待 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //没有可以即刻执行的Message，查看是否存在需要处理的IdleHandler，如果不存在，则返回，阻塞等待，如果存在则执行IdleHandler if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // 如果目前没有消息，已经处在空闲状态，则执行 idler.queueIdle for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. //处理完IdleHandler ，需要重新判断Message队列 nextPollTimeoutMillis赋值为0 pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 上面分析过msg.target就是handler，所以loop循环的时候又把消息取出扔给handler#dispatchMessage方法了，我们来看下 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 由于这种方法没有传callback，所以最终调用handleMessage，我们来看下 12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125; 看到这里，相信大家应该很熟悉了，这就是我们重写的方法。 我们再看看另一个发送消息的方法 handler.post(runnable) 123public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 接收一个实现了Runable接口的对象，然后将其传进getPostMessage()方法。跟进getPostMessage()方法看看 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 其实就是将Runable包装成message的callback嘛。所以，如果我们使用post方法发送消息，在执行dispatchMessage的时候,callback字段是不为空的，那么就会执行handleCallback()方法，而不是执行handleMessage方法了。 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 空闲处理者的添加与处理什么是空闲处理者通过上面的分析可知 MessageQueue通过 next方法通过死循环获取下一个要处理的 Message, 若当前时刻不存在要处理的消息, 下次循环会进行睡眠操作 在没有取到可执行消息 —&gt; 下次 for 循环进行睡眠 之间的时间间隔, 称之为空闲时间 在空闲时间处理事务的对象, 称之为空闲处理者 空闲处理者的添加123456789101112131415161718192021 public static interface IdleHandler &#123; /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ boolean queueIdle();&#125;private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();public void addIdleHandler(@NonNull IdleHandler handler) &#123; if (handler == null) &#123; throw new NullPointerException("Can't add a null IdleHandler"); &#125; synchronized (this) &#123; mIdleHandlers.add(handler); &#125;&#125; 通过上述代码可以得到以下的信息 空闲处理者使用 IdleHandler 接口描述 空闲处理者通过 MessageQueue.addIdleHandler() 添加 空闲处理者使用 MessageQueue.mIdleHandlers 维护 空闲消息的处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class MessageQueue &#123; // 空闲消息集合 private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;(); // 空闲消息处理者的数组 private IdleHandler[] mPendingIdleHandlers; Message next() &#123; ...... for (;;) &#123; ...... synchronized (this) &#123; // 省略获取 msg 的代码 ...... // 1. 从空闲消息集合 mIdleHandlers 中获取 空闲处理者 数量 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; // 2 若无空闲处理者, 则进行下一次 for 循环 if (pendingIdleHandlerCount &lt;= 0) &#123; mBlocked = true; continue; &#125; ...... // 3. 将空闲消息处理者集合转为数组 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // 4. 处理空闲消息 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i];// 获取第 i 给位置的空闲处理者 mPendingIdleHandlers[i] = null; // 置空 boolean keep = false; try &#123; // 4.1 处理空闲消息 keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; ...... &#125; if (!keep) &#123; synchronized (this) &#123; // 4.2 走到这里表示它是一次性的处理者, 从 mIdleHandlers 移除 mIdleHandlers.remove(idler); &#125; &#125; &#125; ...... &#125; &#125;&#125; 好的, 可以看到 MessageQueue.next 在获取不到 msg 时, 会进行一些空闲消息的处理 从空闲消息集合 mIdleHandlers 中获取 空闲处理者 数量 若无空闲处理者, 则进行下一次 for 循环 若存在空闲处理者, 则空闲消息处理者集合转为数组 mPendingIdleHandlers for 循环处理空闲消息 调用 IdleHandler.queueIdle 处理空闲消息 返回 true, 下次再 MessageQueue.next 获取不到 msg 的空闲时间会继续处理 返回 false 表示它是一次性的处理者, 从 mIdleHandlers 移除 总结我们发现不管是使用post方法还是sendMessage方法来发送消息，最终都会调用sendMessageDelayed方法。handler将消息追加到消息队列中的过程都是一样的，然后Looper不断的从MessageQueue中取出消息，并由handler去分发消息，处理消息，这样就构成了完善的Android消息机制体系。 Handler扩展Handler 虽然简单易用，但是要用好它还是需要注意一点。 由于Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。 常见内存泄漏Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity会泄露。 这个泄露是因为Message会持有Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。 解决该问题的最有效的方法是：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息。 示例代码如下： 12345678910111213141516private static class SafeHandler extends Handler &#123; private WeakReference&lt;HandlerActivity&gt; ref; public SafeHandler(HandlerActivity activity) &#123; this.ref = new WeakReference(activity); &#125; @Override public void handleMessage(final Message msg) &#123; HandlerActivity activity = ref.get(); if (activity != null) &#123; activity.handleMessage(msg); &#125; &#125;&#125; 并且再在 Activity.onDestroy() 前移除消息，加一层保障： 12345@Overrideprotected void onDestroy() &#123; safeHandler.removeCallbacksAndMessages(null); super.onDestroy();&#125; 这样双重保障，就能完全避免内存泄露了。 注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。 Handler 里的 Callback 用处在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？ 来看看 Handler.dispatchMessage(msg) 方法： 1234567891011121314public void dispatchMessage(Message msg) &#123; //这里的 callback 是 Runnable if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 可以看到 Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。 这个就很有意思了，这有什么作用呢？ 我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！ 场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。 创建 Message 实例的最佳方式由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。 方法有二： 通过 Message 的静态方法 Message.obtain(); 获取； 通过 Handler 的公有方法 handler.obtainMessage(); 。 妙用 Looper 机制我们可以利用 Looper 的机制来帮助我们做一些事情： 将 Runnable post 到主线程执行 Activity.runOnUiThread(Runnable) 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125; View.post(Runnable) 12345678910public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; //直接通过handler发送Post消息 return attachInfo.mHandler.post(action); &#125; //先加入队列,等attachInfo被赋值时,会通过handler发送消息. getRunQueue().post(action); return true;&#125; 利用 Looper 判断当前线程是否是主线程 123456789101112131415161718public final class MainThread &#123; private MainThread() &#123; &#125; private static final Handler HANDLER = new Handler(Looper.getMainLooper()); public static void run(@NonNull Runnable runnable) &#123; if (isMainThread()) &#123; runnable.run(); &#125;else&#123; HANDLER.post(runnable); &#125; &#125; public static boolean isMainThread() &#123; return Looper.myLooper() == Looper.getMainLooper(); &#125;&#125; Looper 和 Handler 一定要处于一个线程吗？子线程中可以用 MainLooper 去创建 Handler吗？Looper 和Handler 不需要再一个线程中，默认的情况下会从ThreadLocal中取当前线程对应的 Looper，但我们可以通过显式地指定一个 Looper的方式来创建Handler. 比如，当我们想要在子线程中发送消息到主线程中，那么我们可以 1Handler handler = new Handler(Looper.getMainLooper()); 子线程中进行UI操作的方法 Handler的post()方法 View的post()方法 Activity的runOnUiThread()方法 如何理解Handler的异步参见Handler后传篇二: 该如何理解Handler的”异步”？ MessageQueue.next() 会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？ MessageQueue.next() 方法内部的原理？调用 MessageQueue.next() 方法的时候会调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。 当我们加入消息的时候，会调用 MessageQueue.enqueueMessage() 方法，添加完 Message 后，如果消息队列被阻塞，则会调用 Native 层的 nativeWake() 方法去唤醒。它通过向管道中写入一个消息，结束上述阻塞，触发上面提到的 nativePollOnce() 方法返回，好让加入的 Message 得到分发处理。 MessageQueue.enqueueMessage() 使用 synchronized 代码块去进行同步。 资料：Android 中的 Handler 的 Native 层研究 Looper 的退出方法？ quit() 和 quitSafely() 有什么区别子线程中创建了 Looper，在使用完毕后，终止消息循环的方法？quit() 和 quitSafely() 的本质是什么？ quit() 和 quitSafely()的本质就是让消息队列的 next() 返回 null，以此来退出Looper.loop()。 quit() 调用后直接终止 Looper，不在处理任何 Message，所有尝试把Message 放进消息队列的操作都会失败，比如 Handler.sendMessage() 会返回 false，但是存在不安全性，因为有可能有Message 还在消息队列中没来的及处理就终止Looper了。quitSafely() 调用后会在所有消息都处理后再终止 Looper，所有尝试把 Message放进消息队列的操作也都会失败。 知识点汇总由前文可得出一些知识点，汇总一下，方便记忆。 Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理 在创建 Handler 之前一定需要先创建Looper Looper 有退出的功能，但是主线程的 Looper 不允许退出 异步线程的Looper 需要自己调用 Looper.myLooper().quit(); 退出 Runnable被封装进了 Message，可以说是一个特殊的 Message Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成Looper所在的线程，并不是创建 Handler 的线程 使用内部类的方式使用Handler可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类 参考Android中的消息机制Android点将台：烽火狼烟[-Handler-]Handler 都没搞懂，拿什么去跳槽啊？Android 高级面试-1：Handler 相关Android 消息机制：Handler、MessageQueue 和 LooperAndroid 消息机制详解(Android P)]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOSP 源码导入 Android Studio]]></title>
    <url>%2Fposts%2Ffa96240a.html</url>
    <content type="text"><![CDATA[前言前一篇文章AOSP 源码环境搭建我们已经将AOSP整个源码down到了我们硬盘。接下来我们就要Read The Fucking Source Code ! 准备工作原理 idegen专门为IDE环境调试源码而设计的工具，所以我们要将工程导入AS需要下面三个步骤 获取到idegen.jar 获取idegen.sh 执行生成android.ipr/android.iml Android sutdio 选择android.ipr导入 不想编译整个AOSP源码的，对于idegen.jar以及idegen.sh 获取可以参考AOSP frameworks 源码环境搭建 下面讲下完整版的 12345678910cd ～/aosp //具体的源码根目录//用于初始化环境变量source build/envsetup.sh //生成文件out/host/linux-x86/framework/idegen.jarmmm development/tools/idegen/ //源码根目录生成文件android.ipr(工程相关设置), android.iml(模块相关配置)./development/tools/idegen/idegen.sh m/mm/mmm/make 相关参考Android源代码编译命令m/mm/mmm/make分析 导入源码打开Android Studio， 点击File -&gt; Open，选中前面生成的android.ipr文件即可， 该过程较耗时 加载前配置文件提速打开android.iml文件，有大量excludeFolder，是指不会导入到AS的模块，默认除了以下14个文件夹之外的所有文件都会导致到AS工程， 这显然还会非常庞大的，那么我们可以有选择的导入 如下： 12345&lt;excludeFolder url="file://$MODULE_DIR$/.repo"/&gt;&lt;excludeFolder url="file://$MODULE_DIR$/external/bluetooth"/&gt;&lt;excludeFolder url="file://$MODULE_DIR$/frameworks/base/docs"/&gt;&lt;excludeFolder url="file://$MODULE_DIR$/out/host"/&gt;&lt;excludeFolder url="file://$MODULE_DIR$/prebuilt"/&gt; 加载后提速如果已经把全部项目导入到Android Studio，又想删除怎么办，其实有一个简单的方法就是进入目录Project Structure -&gt; Modules， 可快速去除某些模块, 其中红色代码Exclueded选项(即代表已删除的目录), 如下图: 配置源码正确跳转这里的配置JDK/SDK，是用于解决在分析和调试源码的过程，能正确地跳转到目标源码，而非SDK中的代码。 点击File菜单下的Project Structure. 新建JDK(No Libraries) 新建JDK(No Libraries),路径可选择之前的一样的 删除JDK(No Libraries)中的ClassPath和SourcePath 配置SDKProject Structure -&gt; SDKs, 选中Android API 28 Platform, 然后选择其Java SDK为前面新建的JDK(No Libraries) 选择SDK 建立依赖Project Structure -&gt; Modules -&gt; android -&gt; Dependencies: 先删除Android API 25 Platform之外的所有依赖, 然后点击下图绿色的+号来选择Jars or directories，将frameworks添加进来, 也可添加其他所关注的源码； 调试前面已搭建好了Android的源码调试环境, 接下来可以在线调试源码. 首先,需要一台具有debug版的手机, 打开开发者选项, 允许USB调试. frameworks各大核心服务运行在system_server进程, 在调试器上名字为system_process,通过attach到我们要调试的目标进程, 同理, 要调试其他app进程也是这个方式. 参考AndroidStudio源码开发环境搭建]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOSP 源码环境搭建]]></title>
    <url>%2Fposts%2F8c9d1837.html</url>
    <content type="text"><![CDATA[准备工作配置Android Studio*调整内存大小: * Android Studio需要大量的内存来加载Android源码，所以经常会遇到内存不足的问题, 需要加大内存. 点击Help-&gt; Edit Custom VM Options, 比如 “-Xms4096m -Xmx4096m” 更多资料: Android Studio官网 配置 Android Studio 配置repo下载repo工具 1234mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 或者使用tuna的git-repo镜像 然后建立一个工作目录（名字任意） 12mkdir ~/aosp //创建目录，可自己定义cd ~/aosp 初始化仓库： 1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest 如果提示无法连接到 gerrit.googlesource.com，请参照git-repo的帮助页面的更新一节。 如果需要某个特定的 Android 版本（Android 版本列表）： 1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r1 同步源码树（以后只需执行这条命令来同步）： 123456#同步所有可用的projectrepo sync#只同步当前初始化的分支repo sync -c -j4#只同步frameworks/base库repo sync platform/frameworks/base -c -j4 repo sync 失败虽然是国内镜像，但同步依然会出错停止，所以我们需要创建一个自动下载脚本，确保出错了之后会自动执行repo sync，在aosp文件夹下创建一个脚本down.sh，(自己在aosp文件夹创建down.sh文件，然后用编辑器打开，copy代码进去保存就行)代码如下，这个-j 8可以自己改，你的CPU总线程数*2： 1234567#!/bin/bash repo sync -j 8 while [ $? = 1 ]; do echo “======sync failed, re-sync again======” sleep 3 repo sync -j 8 done 如果只需要同步部分project 把上面的的两行repo sync -j 8替换成下面的语句 1repo sync platform/development platform/frameworks/base -j 8 repo sync命令后面可以指定要同步的project，上面这行命令就是指定了2个project 打开.repo/manifest.xml,可以看到project的名字和路径。 然后命令行执行，就开始下载啦。（注意：Terminal要在aosp文件夹下) 12chmod a+x down.sh./down.sh 替换已有的 AOSP 源代码的 remote如果你之前已经通过某种途径获得了 AOSP 的源码(或者你只是 init 这一步完成后)， 你希望以后通过 TUNA 同步 AOSP 部分的代码，只需要将.repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 https://android.googlesource.com 改为 https://aosp.tuna.tsinghua.edu.cn/。 12345678&lt;manifest&gt; &lt;remote name="aosp"- fetch="https://android.googlesource.com"+ fetch="https://aosp.tuna.tsinghua.edu.cn" review="android-review.googlesource.com" /&gt; &lt;remote name="github" 同时，修改 .repo/manifests.git/config，将 1url = https://android.googlesource.com/platform/manifest 更改为 1url = https://aosp.tuna.tsinghua.edu.cn/platform/manifest 总结我们分析源码其实是不需要全部代码的，因为AOSP不仅包括系统源码，还有些工具代码，如aapt，adb等，这些我们根本不需要，而且即便是系统源码，也不是所有我们都需要看，如果真的全部看，你这辈子都看不完. 如果只想下载单个目录，比如我们要下载platform/frameworks/base/目录下的代码，我们可以git clone https://android.googlesource.com/platform/frameworks/base ，不过这个还是会遇到翻墙的问题，当然我们也可以用镜像。 镜像地址 https://aosp.tuna.tsinghua.edu.cn/ ，比如我们要下载platform/frameworks/base/目录，就用git clone https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base ，如果你带宽够的话，一般几分钟就可以下载好你想要的单个源码了。 如果你想下载单个文件，或者搜索文件名及代码，可以访问 http://androidxref.com/ ，这里有部分Android的源码 具体可以参考how to read android framework source code in android studio Android 架构简介总体架构Android系统架构分为五层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 Android源码根目录 描述 abi abi相关代码，abi:application binary interface，应用程序二进制接口 art 全新的运行环境，需要和Dalvik VM区分开来 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则及generic等基础开发配置包 cts Android兼容性测试套件标准 dalvik dalvik虚拟机 developers 开发者目录 development 应用程序开发相关 device 设备相关配置 docs 参考文档目录 external Android使用的一些开源的模组 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件适配层HAL代码 libcore 核心库相关文件 libnativehelper 是Support functions for Android’s class libraries的缩写，表示动态库，是实现的JNI库的基础 ndk Android NDK ( Android Native Development Kit )是一系列的开发工具，允许程序开发人员在Android应用程序中嵌入C/C++语言编写的非托管代码 out 编译完成后代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，本地开发套件 platform_testing 平台测试 prebuilts x86和arm架构下预编译的一些资源 sdk sdk和模拟器 system 文件系统和应用及组件，是用C语言实现的 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 ( 通常文件后缀为.mk ) 应用层部分应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都是在应用层。源码根目录中的packages目录对应着系统应用层。 packages目录 描述 apps 核心应用程序 experimental 第三方应用程序 inputmethods 输入法目录 providers 内容提供者目录 screensavers 屏幕保护 services 通信服务 wallpapers 墙纸 应用框架层部分应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与C/C++程序库以及硬件抽象层等进行衔接。 应用框架层的主要实现代码在/frameworks/base和/frameworks/av目录下 其中系统服务部分在frameworks/base/services中，在frameworks/av/services里存放着音频和照相机的服务。 /frameworks/base目录结构如下 /frameworks/base目录 描述 /frameworks/base目录 描述 api 定义API cmds 重要命令：am、app_proce等 core 核心库 data 字体和声音等数据文件 docs 文档 graphics 图形图像相关 include 头文件 keystore 和数据签名证书相关 libs 库 location 地理位置相关库 media 多媒体相关库 native 本地库 nfc-extras NFC相关 obex 蓝牙传输 opengl 2D/3D 图形API packages 设置、TTS、VPN程序 sax XML解析器 services 系统服务 telephony 电话通讯管理 test-runner 测试工具相关 tests 测试相关 tools 工具 wifi wifi无线网络 C/C++程序库部分系统运行库层（Native)中的 C/C++程序库的类型繁多，功能强大，C/C++程序库并不完全在一个目录中，这里给出几个常用且比较重要的C/C++程序库所在的目录位置。 目录位置 描述 bionic/ Google开发的系统C库，以BSD许可形式开源。 /frameworks/av/media 系统媒体库 /frameworks/native/opengl 3D图形库/第三方图形渲染库 /frameworks/native/services/surfaceflinger 图形显示库，主要负责图形的渲染、叠加和绘制等功能 external/sqlite 轻量型关系数据库SQLite的C++实现 external/webp,external/webrtc 网络引擎库 系统运行库部分Dalvik虚拟机的实现: /dalvik，从Android 5.0开始，Android应用程序的默认运行环境为ART ( Android Runtime )，ART模式拥有更快更高的运行效率。ART: /art 硬件抽象层部分hardware/libhardware: audio、nfc、power实现ril: 无线硬件设备与电话的实现 阅读工具vim+ctags+cscopeLinux 平台下阅读源码的工具 Source Insight/Understand【工利其器】工具使用之（一）Source Insight篇 如何阅读Android源码 OpenGrok搭建大型源码阅读环境——使用 OpenGrok 工具使用-Mac上搭建OpenGrok查看Android源码 androidxref Android StudioAOSP 源码导入 Android Studio 参考获取Android源码，初识源码模块架构 Github asop mirror Android系统架构与系统源码目录 下载AOSP android源码（最小最快下载方式，跳过编译直接导入Android Studio） Ubuntu 16.04 AndroidStudio源码开发环境搭建]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOSP frameworks 源码环境搭建]]></title>
    <url>%2Fposts%2Fca9841f5.html</url>
    <content type="text"><![CDATA[本文将记录最快捷的将framework层源码导入android studio进行源码分析的方法 获取framework源码，这里使用清华大学的镜像 123mkdir ~/WorkSpace/AOSPcd ~/WorkSpace/AOSPgit clone -b android-9.0.0_r1 https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base platform/frameworks/ --depth 1 新建out文件夹 和 frameworks 同级 12cd ~/WorkSpace/AOSP/platform/frameworksmkdir -p ./out/host/linux-x86/framework 获取idegen.jar 并复制到 out/host/linux-x86/framework 下idegen.jar 获取idegen.sh clone development 到本地 12git clone https://aosp.tuna.tsinghua.edu.cn/platform/development platform/development platform/development/tools/idegen/idegen.sh 或直接选择别人下好的idegen.shidegen.sh执行idegen.sh将会在～/WorkSpace/AOSP/platform/ 下生成android.iml 和 android.ipr 文件 打开android studio 选择android.ipr 导入工程即可]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划2019]]></title>
    <url>%2Fposts%2F397a8e26.html</url>
    <content type="text"><![CDATA[2015年12月入职的，一直在这家公司，时光如白驹过隙，一晃3年就过去了，从来没有好好静下心来回头看看。今年结了婚，有了十一，压力一下子大了一个级别，生活也瞬间过得捉襟见肘的。3年过去，自己的能力明显没有达到自己的期望，在公司这3年，怎么说呢，虽然不说虚度，但至少没有自己想象的那么努力，技术上广度我自认为还是可以的，深度就不行了，杂而不精。 希望今年不再碌碌无为，能有个质变。 2019年要努力达成的目标 ： 长10斤肉 早睡早起 每周至少运动2次 精读至少10本技术书 尽量阅读英文文档 产出至少10篇技术博客，3篇非技术博客 开源至少1个项目 Android常见组件以及目前流行框架源码至少都过一遍 参加至少1次技术沙龙 有机会去北上广深杭感受下 学会Kotlin/Flutter 并投入生产 了解，并初步使用Go 简单学习一些shell编程 工资翻一番]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
        <tag>计划</tag>
      </tags>
  </entry>
</search>
