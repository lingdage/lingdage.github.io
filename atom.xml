<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌大哥@Android攻城狮</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lingdage.com/"/>
  <updated>2019-06-13T14:37:40.467Z</updated>
  <id>https://lingdage.com/</id>
  
  <author>
    <name>lingdage</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ConstrainLayout 使用详解</title>
    <link href="https://lingdage.com/posts/1352bf96.html"/>
    <id>https://lingdage.com/posts/1352bf96.html</id>
    <published>2019-05-23T01:35:36.000Z</published>
    <updated>2019-06-13T14:37:40.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>继承关系</p><table><thead><tr><th>java.lang.Object</th><th></th><th></th></tr></thead><tbody><tr><td>↳</td><td>ViewGroup</td><td></td></tr><tr><td></td><td>↳</td><td>androidx.constraintlayout.widget.ConstraintLayout</td></tr></tbody></table><p>ConstraintLayout继承自ViewGroup,是一个Support库，意味着向前兼容，它可以兼容至API 9，也就是Android 2.3，鉴于现在市场上手机基本都是2.3及以上的，所以如果不是特殊情况，开发者可以不用考虑版本问题。</p><h2 id="特性详解"><a href="#特性详解" class="headerlink" title="特性详解"></a>特性详解</h2><h3 id="Relative-positioning-相对定位"><a href="#Relative-positioning-相对定位" class="headerlink" title="Relative positioning (相对定位)"></a>Relative positioning (相对定位)</h3><p>相对定位是在ConstraintLayout中创建布局的最基本构建块，也就是一个控件相对于另一个控件进行定位，可以从横向、纵向添加约束关系，用到的边分别有：</p><ul><li><p>横向：Left、Right、Start、End</p></li><li><p>纵向：Top、Bottom、Baseline（文本底部的基准线）</p></li></ul><p>根据布局中的其他元素或视图, 确定View在屏幕中的位置, 受到三类约束, 即其他视图, 父容器(parent), 基准线(Guideline).</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraint[本源位置]_[目标位置]=&quot;[目标ID]&quot;</span><br></pre></td></tr></table></figure><p>例如:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot;</span><br></pre></td></tr></table></figure><p>约束<code>当前View的底部</code>至<code>目标View的底部</code>, 目标View是constraintLayout. 即, 把当前View的底部对齐到constraintLayout的底部.</p><p>eg:</p><p>通常是一条边向另一条边添加约束，就像下面按钮B要定位在按钮A的右边一样：</p><p>  <img src="/posts/1352bf96/relative-positioning.png" alt="relative positioning"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/buttonA"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/buttonB"</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">"@+id/buttonA"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样系统就会知道按钮B的左侧被<strong>约束</strong>在按钮A的右侧，这里的<strong>约束</strong>可以理解为边的对齐。</p><p><img src="/posts/1352bf96/relative-positioning-constraints.png" alt="relative positioning constraints"></p><p>上图是相对定位的约束，图中每一条边（top、bottom、baseline、left、start、right、end）都可以与其他控件形成约束，罗列这些边形成的相对定位关系如下：</p><ul><li>layout_constraintLeft_toLeftOf          // 左边左对齐</li><li>layout_constraintLeft_toRightOf         // 左边右对齐</li><li>layout_constraintRight_toLeftOf         // 右边左对齐</li><li>layout_constraintRight_toRightOf        // 右边右对齐</li><li>layout_constraintTop_toTopOf            // 上边顶部对齐</li><li>layout_constraintTop_toBottomOf         // 上边底部对齐</li><li>layout_constraintBottom_toTopOf         // 下边顶部对齐</li><li>layout_constraintBottom_toBottomOf      // 下边底部对齐</li><li>layout_constraintBaseline_toBaselineOf  // 文本内容基准线对齐</li><li>layout_constraintStart_toEndOf          // 起始边向尾部对齐</li><li>layout_constraintStart_toStartOf        // 起始边向起始边对齐</li><li>layout_constraintEnd_toStartOf          // 尾部向起始边对齐</li><li>layout_constraintEnd_toEndOf            // 尾部向尾部对齐</li></ul><p>上面的这些属性需要结合<code>id</code>才能进行约束，这些<code>id</code>可以指向控件也可以指向父容器（也就是ConstraintLayout），比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/buttonB"</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag"> <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Margins-外边距"><a href="#Margins-外边距" class="headerlink" title="Margins (外边距)"></a>Margins (外边距)</h3><p><img src="/posts/1352bf96/relative-positioning-margin.png" alt="relative positioning margin"></p><p>写过RelativeLayout 的朋友应该都能理解这个margin的意思, 这里就不赘述, 罗列外边距的属性如下：</p><ul><li><code>android:layout_marginStart</code></li><li><code>android:layout_marginEnd</code></li><li><code>android:layout_marginLeft</code></li><li><code>android:layout_marginTop</code></li><li><code>android:layout_marginRight</code></li><li><code>android:layout_marginBottom</code></li></ul><blockquote><p>请注意，边距只能是正数或等于零，并设置<strong>Dimension</strong>。</p></blockquote><h4 id="goneMargin"><a href="#goneMargin" class="headerlink" title="goneMargin"></a>goneMargin</h4><p>当位置约束目标的可见性为View.GONE时，您还可以使用以下属性指示要使用的不同边距值：</p><p>以上图为例，这里的goneMargin指的是B向A添加约束后，如果A的可见性变为GONE，这时候B的外边距可以改变，也就是B的外边距根据A的可见性分为两种状态。</p><p>具体值参考以下:</p><ul><li><code>layout_goneMarginStart</code></li><li><code>layout_goneMarginEnd</code></li><li><code>layout_goneMarginLeft</code></li><li><code>layout_goneMarginTop</code></li><li><code>layout_goneMarginRight</code></li><li><code>layout_goneMarginBottom</code></li></ul><h3 id="Centering-positioning-居中定位"><a href="#Centering-positioning-居中定位" class="headerlink" title="Centering positioning (居中定位)"></a>Centering positioning (居中定位)</h3><p>ConstraintLayout的一个有用方面是它如何处理“不可能”的约束。例如，如果我们有类似的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent/&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span></span></span><br></pre></td></tr></table></figure><p>除非ConstraintLayout恰好具有与Button完全相同的大小，否则两个约束不能同时满足（双方都不能成为我们希望它们的位置）。(谷歌翻译- -)</p><p><img src="/posts/1352bf96/centering-positioning.png" alt="centering positioning"></p><p>这种情况就感觉像是控件两边有两个反向相等大小的力在拉动它一样，所以才会产生控件居中的效果。</p><blockquote><p><strong>这里说明一下：</strong>如果在居中方向上（横向或纵向）控件的尺寸和ConstraintLayout的尺寸一样，那么就无所谓居中了，此时约束的存在是没有意义的。</p></blockquote><h3 id="bias-倾向"><a href="#bias-倾向" class="headerlink" title="bias (倾向)"></a>bias (倾向)</h3><p>在上面那种同向相反的约束时,效果是默认设置是使控件居中;但是您可以使用偏差属性调整定位以支持一侧而不是另一侧(像拔河一样，让两个约束的力大小不等，这样就产生了倾向), 其属性是：</p><ul><li><code>layout_constraintHorizontal_bias</code></li><li><code>layout_constraintVertical_bias</code></li></ul><p>eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">"0.3"</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"paret/&gt; </span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span></span></span><br></pre></td></tr></table></figure><p>这段代码就是让左边占30%，右边占70%（默认两边各占50%），这样左边就会短一些，效果如下图所示</p><p><img src="/posts/1352bf96/centering-positioning-bias.png" alt="centering positioning bias"></p><blockquote><p>使用偏差，您可以制作更好地适应屏幕尺寸变化的用户界面。(百分比布局的概念)</p></blockquote><h3 id="Circular-positioning-圆形定位"><a href="#Circular-positioning-圆形定位" class="headerlink" title="Circular positioning (圆形定位)"></a>Circular positioning (圆形定位)</h3><p>你可以以角度和距离约束控件相对于另一个控件的中心。这允许您将控件放在圆上（参见下图）。可以使用以下属性：</p><ul><li><code>layout_constraintCircle</code> : 引用另一个控件的 id</li><li><code>layout_constraintCircleRadius</code> : 到另一个控件中心的距离</li><li><code>layout_constraintCircleAngle</code> : 控件的角度（顺时针，0 - 360 度）</li></ul><div align="center"><br>   <img style="display:inline-block;margin-right:150px" src="/posts/1352bf96/circle1.png" width="200px" height="200px"><img style="display:inline-block" src="/posts/1352bf96/circle2.png" width="200px" height="200px"><br></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/buttonA"</span> <span class="attr">...</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/buttonB"</span> <span class="attr">...</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintCircle</span>=<span class="string">"@+id/buttonA"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintCircleRadius</span>=<span class="string">"100dp"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintCircleAngle</span>=<span class="string">"45"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Visibility-behavior-可见性的表现"><a href="#Visibility-behavior-可见性的表现" class="headerlink" title="Visibility behavior (可见性的表现)"></a>Visibility behavior (可见性的表现)</h3><p>ConstraintLayout对可见性被标记<code>View.GONE</code>的控件（后称“<code>GONE</code>控件”）有特殊的处理。一般情况下，<code>GONG</code>控件是不可见的，且不再是布局的一部分，但是在<strong>布局计算</strong>上，ConstraintLayout与传统布局有一个很重要的区别：</p><ul><li>传统布局下，<code>GONE</code>控件的尺寸会被认为是0（当做<strong>点</strong>来处理）</li><li>在ConstraintLayout中，<code>GONE</code>控件尺寸仍然按其可见时的大小计算，但是其外边距大小按0计算</li></ul><p><img src="/posts/1352bf96/visibility-behavior.png" alt="visibility behavior"></p><p><em>这种特殊的行为让我们在无需打乱布局情况下，在标记GONE控件的地方构建布局(如上图)，这样的做法对于做简单的布局动画很有用。</em></p><blockquote><p>注意:使用的边距将是B在连接到A时定义的边距（见上图）。在某些情况下，这可能不是您想要的余量（例如A在其容器侧面有100dp的边距，B只有16dp到A，A标记为已消失，B对容器的边距为16dp）。因此，您可以指定在连接到标记为已删除的窗口小部件时要使用的备用边距值</p><ul><li><code>layout_goneMarginStart</code></li><li><code>layout_goneMarginEnd</code></li><li><code>layout_goneMarginLeft</code></li><li><code>layout_goneMarginTop</code></li><li><code>layout_goneMarginRight</code></li><li><code>layout_goneMarginBottom</code></li></ul></blockquote><h3 id="Dimensions-constraints-尺寸约束"><a href="#Dimensions-constraints-尺寸约束" class="headerlink" title="Dimensions constraints (尺寸约束)"></a>Dimensions constraints (尺寸约束)</h3><h4 id="Minimum-and-maximum-dimensions-on-ConstraintLayout-最大最小尺寸"><a href="#Minimum-and-maximum-dimensions-on-ConstraintLayout-最大最小尺寸" class="headerlink" title="Minimum and maximum dimensions on ConstraintLayout (最大最小尺寸)"></a>Minimum and maximum dimensions on ConstraintLayout (最大最小尺寸)</h4><p>ConstraintLayout本身可以定义自己的最大/最小尺寸：</p><ul><li><code>android:minWidth</code> 设置布局的最小宽度</li><li><code>android:minHeight</code> 设置布局的最小高度</li><li><code>android:maxWidth</code> 设置布局的最大宽度</li><li><code>android:maxHeight</code> 设置布局的最大高度</li></ul><p>这些最小尺寸当ConstraintLayout被设置为<strong>WRAP_CONTENT</strong>时有效。</p><h4 id="Widgets-dimension-constraints-控件尺寸约束"><a href="#Widgets-dimension-constraints-控件尺寸约束" class="headerlink" title="Widgets dimension constraints (控件尺寸约束)"></a>Widgets dimension constraints (控件尺寸约束)</h4><p>控件的尺寸可以通过<code>android:layout_width</code>和<code>android:layout_height</code>来设置，有三种方式：</p><ul><li>使用<strong>固定值</strong>(文字值如123dp或 <code>Dimension</code> reference)</li><li>使用<strong>WRAP_CONTENT</strong></li><li>使用<strong>0dp</strong>（相当于<strong>MATCH_CONSTRAINT</strong>）</li></ul><p><img src="/posts/1352bf96/dimension-match-constraints.png" alt="dimension match constraints"></p><p>前两种方式和其他布局的用法相同，最后一种是通过填充约束来重新设置控件的尺寸（如上图 ，(a)是<code>wrap_content</code>，(b)是<code>0dp</code>。代码案例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span> // 这里对宽度设置<span class="attr">MATCH_CONSTRAINT</span>，结合<span class="attr">3</span>、<span class="attr">4</span>两行实现约束</span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果设置了边距，那么外边距就会在尺寸计算中被考虑进去 如上图（c）中的<code>0dp</code>）</p><p><strong>划重点</strong>:0dp并不是类似于以前的<code>MATCH_PARENT</code>,它match的是<strong>约束</strong>。 如上图(b) 他的左右约束是parent,所以他设置0dp就铺满父宽度,但是(c),他的左边有个约束为margin,右边约束到parent,所以这个0dp就是从左约束(那个margin值)到最右边(parent)</p><p><strong>重点：</strong>对于ConstraintLayout中包含的控件，不建议使用MATCH_PARENT。可以通过使用MATCH_CONSTRAINT来定义类似的行为，其中相应的左/右或上/下约束被设置为<code>parent</code>。</p><h4 id="Enforcing-constraints-强制约束"><a href="#Enforcing-constraints-强制约束" class="headerlink" title="Enforcing constraints(强制约束)"></a>Enforcing constraints(强制约束)</h4><blockquote><p>此属性在1.1版本添加</p></blockquote><p>在 1.1 版本之前，如果将控件的尺寸设置为了 WRAP_CONTENT，那么对控件设置约束（如：minWidth 等）是不起作用的。那么强制约束（Enforcing constraints）的作用就是，在控件被设置 WRAP_CONTENT 的情况下，使约束依然生效。</p><ul><li><code>app:layout_constrainedWidth=”true|false”</code></li><li><code>app:layout_constrainedHeight=”true|false”</code></li></ul><p>下面的例子演示了没有设置强制约束和设置了强制约束的对比：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/imageViewA"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"96dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constrainedWidth</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintWidth_max</span>=<span class="string">"80dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/imageViewB"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/imageViewA"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constrainedWidth</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintWidth_max</span>=<span class="string">"80dp"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/1352bf96/Enforcing-constraints.png" alt="Enforcing constraints"></p><p>如图所示,同样设置了最大宽度,imageViewB起作用,imageViewA没有起作用</p><h4 id="MATCH-CONSTRAINT-dimensions"><a href="#MATCH-CONSTRAINT-dimensions" class="headerlink" title="MATCH_CONSTRAINT dimensions"></a>MATCH_CONSTRAINT dimensions</h4><blockquote><p>此属性在1.1版本添加</p></blockquote><p>当尺寸设置为MATCH_CONSTRAINT(０dp,默认行为是使结果大小占用所有可用空间)时。1.1版本之后，还有几个额外的修饰符：</p><ul><li><code>layout_constraintWidth_min</code> and <code>layout_constraintHeight_min</code> : 指定当前控件的最小宽度或高度</li><li><code>layout_constraintWidth_max</code> and <code>layout_constraintHeight_max</code> : 指定当前控件的最大宽度或高度</li><li><code>layout_constraintWidth_percent</code> and <code>layout_constraintHeight_percent</code> : 指定当前控件的宽度或高度是父控件的百分之多少。可设置的值在 0 - 1 之间，1 就是 100%</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/imageViewA"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/imageViewB"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/imageViewA"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_percent</span>=<span class="string">"0.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/imageViewC"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/imageViewB"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_max</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHeight_min</span>=<span class="string">"80dp"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>A设置为0dp,所以铺满整个宽度 B加了个50%的百分比,所以宽度为一半 C限制了最大宽度和最小高度 效果如下图</p><p><img src="/posts/1352bf96/MATCH_CONSTRAINT.png" alt="MATCH CONSTRAINT"></p><blockquote><p><strong>Min and Max</strong>:</p><p>为min和max指示的值可以是dp，也可以是“wrap”(它将使用与WRAP_CONTENT相同的值)</p></blockquote><blockquote><p><strong>Percent dimension:</strong></p><p>To use percent, you need to set the following:</p><ul><li>The dimension should be set to <code>MATCH_CONSTRAINT</code> (0dp)</li><li>The default should be set to percent <code>app:layout_constraintWidth_default=&quot;percent&quot;</code> or <code>app:layout_constraintHeight_default=&quot;percent&quot;</code></li><li>Then set the <code>layout_constraintWidth_percent</code> or <code>layout_constraintHeight_percent</code> attributes to a value between 0 and 1</li></ul></blockquote><h4 id="Ratio-比例"><a href="#Ratio-比例" class="headerlink" title="Ratio (比例)"></a>Ratio (比例)</h4><p>这里的比例指的是宽高比，通过设置比例，让宽高的其中一个随另一个变化。为了实现比例，需要让控件宽或高<strong>受约束</strong>，且尺寸设置为<code>0dp</code>（也可以是<code>MATCH_CONSTRAINT</code>），eg：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/imageViewA"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/imageViewB"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:src</span>=<span class="string">"@drawable/demo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/imageViewA"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">"1:1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/1352bf96/Ratio.png" alt="Ratio"></p><p>上图中，imageViewB的宽度满足<strong>受约束且设置为0dp</strong>的条件，所以其尺寸会按照比例随高度调整。</p><p>比例的设置有两种格式：</p><ul><li>宽度与高度的<strong>比</strong>，可理解为<code>受约束的一方尺寸:另一方尺寸</code> </li><li>浮点值，表示宽度和高度之间的比率 </li></ul><p>如果宽高都设置为MATCH_CONSTRAINT（0dp），您也可以使用比率。<strong>在这种情况下，系统设置满足所有约束的最大尺寸并保持指定的纵横比。</strong>要根据另一个的尺寸约束一个特定边，可以预先附加W或H，分别约束宽度或高度。例如，如果一个尺寸受两个目标约束（例如，宽度为0dp并且以父对象为中心）你可以通过在比率前添加字母W（用于约束宽度）或H（用于约束高度）来指示哪一边应该被约束，用逗号分隔 (谷歌翻译)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/imageViewA"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">"H,2:1"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/imageViewB"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/imageViewA"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">"W,1:3"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/1352bf96/ratio-WH.png" alt="ratio WH"></p><p>如上图,imageViewA将按照2:1的宽高比设置按钮的<strong>高度</strong>，而按钮的<strong>宽度</strong>将匹配父项的约束(0dp即铺满)</p><p>imageViewB将按照1:3的宽高比设置按钮的<strong>宽度</strong>，而按钮的<strong>高度</strong>将匹配父项的约束(即铺满imageViewA下面32dp到parent底部)</p><h3 id="Chain（链）"><a href="#Chain（链）" class="headerlink" title="Chain（链）"></a>Chain（链）</h3><p>链在单个轴（水平或垂直）中提供类似行的行为。另一个轴可以独立约束。</p><p>如果一组控件通过双向连接链接在一起，则它们被视为链（如下图，是最小单位的Chain，只具有两个控件）。</p><p><img src="/posts/1352bf96/chains.png" alt="chains"></p><p><strong>Chain头部</strong><br>横向上，Chain头部是Chain最左边的控件；纵向上，Chain头部是Chain最顶部的控件。</p><p><strong>Chain外边距</strong><br>如果连接时定义了外边距，Chain就会发生变化。在<code>SPREAD CHAIN</code>中，外边距会从已经分配好的空间中去掉。</p><p><strong>Chain Style(样式)</strong></p><p>当对Chain的第一个元素设置<code>layout_constraintHorizontal_chainStyle</code>或<code>layout_constraintVertical_chainStyle</code>属性，Chain就会根据特定的样式（默认样式为<code>CHAIN_SPREAD</code>）进行相应变化，样式类型如下：</p><ul><li><code>CHAIN_SPREAD</code> 元素被分散开（默认样式）</li><li>在<code>CHAIN_SPREAD</code>模式下，如果一些控件被设置为<code>MATCH_CONSTRAINT</code>，那么控件将会把所有剩余的空间均分后“吃掉”</li><li><code>CHAIN_SPREAD_INSIDE</code> Chain两边的元素贴着父容器，其他元素在剩余的空间中采用<code>CHAIN_SPREAD</code>模式</li><li><code>CHAIN_PACKED</code> Chain中的所有控件合并在一起后在剩余的空间中居中</li></ul><p><img src="/posts/1352bf96/chains-styles.png" alt="chains styles"></p><p><strong>Weighted chains (带权重的Chain) </strong></p><p>默认的Chain是在可用空间中平均分布元素。如果其中有一个或多个元素使用了<code>MATCH_CONSTRAINT</code>属性，那么他们会将剩余的空间平均填满。属性<code>layout_constraintHorizontal_weight</code>和<code>layout_constraintVertical_weight</code>控制使用<code>MATCH_CONSTRAINT</code>的元素如何均分空间。<br>例如，一个Chain中包含两个使用<code>MATCH_CONSTRAINT</code>的元素，第一个元素使用的权重为2，第二个元素使用的权重为1，那么被第一个元素占用的空间是第二个元素的2倍。</p><p>When using margins on elements in a chain, the margins are additive.</p><p>For example, on a horizontal chain, if one element defines a right margin of 10dp and the next element defines a left margin of 5dp, the resulting margin between those two elements is 15dp.</p><p><strong>Margins and chains </strong></p><blockquote><p>此属性在1.1版本添加</p></blockquote><p>在链中的元素上使用边距时，边距是相加的。</p><p>例如，在水平链上，如果一个元素定义了10dp的右边距，而下一个元素定义了5dp的左边距，则这两个元素之间产生的边距为15dp。 在计算链用于定位项目的剩余空间时，会同时考虑项目及其边距。剩余空间不包含边距。</p><p><img src="/posts/1352bf96/chian-demo.gif" alt="chian demo"></p><h3 id="Virtual-Helper-objects-辅助工具"><a href="#Virtual-Helper-objects-辅助工具" class="headerlink" title="Virtual Helper objects(辅助工具)"></a>Virtual Helper objects(辅助工具)</h3><p>除了前面详述的内在功能之外，您还可以使用ConstraintLayout中的辅助工具来帮助您进行布局。目前，<code>Guideline</code>对象允许您创建相对于ConstraintLayout容器定位的水平和垂直指南。然后可以通过将小部件限制为这样的指导来定位小部件。在1.1中，也增加了<code>Barrier</code>和<code>Group</code>。</p><h4 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h4><p>Guideline 不会显示在设备上（它们标记为View.GONE），仅用于布局目的。它们仅在ConstraintLayout中工作。用处是帮助我们的控件增加约束。就如同Photoshop中参考线的概念一样。如下图，创建一个垂直方向的参考线，可以切换百分比，或者是实际的距离。具体用哪种还是得根据实际情况来。</p><p><img src="/posts/1352bf96/Guideline-demo.gif" alt="Guideline demo"></p><h4 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h4><p>很多时候我们都会遇到控件的大小随着其包含的数据的多少而改变的情况，而此时如果有多个控件之间是相互约束的话，就比较难来设定各个控件间的约束关系了<br> 而 <code>Barrier</code>（屏障）就是用于这种情况，<code>Barrier</code> 和 <code>GuideLine</code> 一样是一个虚拟的 View，对界面是不可见的，只是用于辅助布局，而 Barrier 和 GuideLine 的区别在于它可以由多个 View 来决定其属性</p><p>Barrier 可以使用的属性有：</p><ul><li><p>rrierDirection：用于设置 Barrier 的位置，属性值有：bottom、top、start、end、left、right</p></li><li><p>constraint_referenced_ids：用于设置 Barrier 所引用的控件的 ID，可同时设置多个</p></li><li><p>barrierAllowsGoneWidgets：默认为 true，当 Barrier 所引用的控件为 Gone 时，则 Barrier 的创建行为是在已 Gone 的控件已解析的位置上进行创建。如果设置为 false，则不会将 Gone 的控件考虑在内</p></li></ul><p>下面是一个非常简单的例子：</p><p><img src="/posts/1352bf96/barriers_alignment_en.png" alt="barriers alignment en"></p><p>我们有三个TextViews： 左边 textView1 和 textView2 ，右边 textView3。textView3 约束在 textView1 的右边，效果也符合我们的预期。</p><p>但是当需要支持多语言的时候事情就变得复杂了。如果我们添加德语就出现了问题，因为在英语里面textView1的文字是长于textView2的，但是在德语中却是textView2的文字比textView1长：</p><p><img src="/posts/1352bf96/barriers_alignment_de.png" alt="barriers alignment de"></p><p>这里的问题在于textView3仍然是相对于textView1的，所以textView2直接插入了textView3中。在设计视图里看起来更明显（白色背景的那个）。</p><p>View只能设置一个View作为锚点，设置了一个就顾不了另一个,所以传统方法是使用TableLayout，或者把 textView1 &amp; textView2 包裹在一个垂直的LinearLayout中,然后让textView3约束在这个LinearLayout的后面。<br>所以就诞生了Barrier，他可以设置N个View作为锚点。</p><p>Barrier 是一个虚拟视图，类似于 Guideline，用来约束对象。Barrier 和 Guideline 的区别在于它是由多个 view 的大小决定的。在这个例子中，我们不知道 textView1 和 textView2 哪个长些，因此我们可以 基于这两个 view 的宽度创建一个Barrier。我们可以让 textView3 约束在 Barrier 后面。</p><p><strong>在编辑器中创建Barriers</strong></p><p>首先选择上下文菜单的create a vertical barrier，创建一个垂直的barrier：</p><blockquote><p>注：Android Studio2.3貌似没有这个菜单，Android Studio3.0有，但是在help菜单组的下级菜单，跟下面的演示图有些区别。</p></blockquote><p><img src="/posts/1352bf96/barrier_create.gif" alt="barrier create"></p><p>你可以在组建树（component tree）中看到Barrier（左边靠近底部的面板）。</p><p>我们可以通过拖动改变它的位置（可选项）：</p><p><img src="/posts/1352bf96/barrier_order.gif" alt="barrier order"></p><p>接下来我们需要设置Barrier 方向（direction）。这里我们是想让Barrier根据textView1 和 textView2 的大小确定是在谁的后面，因此我们需要把 direction 设置为 end：</p><p><img src="/posts/1352bf96/barrier_direction.gif" alt="barrier direction"></p><p>最后一步是告诉Barrier它是相对于哪些view。我不用约束来形容是因为约束一般指一对一的，而这里是多个view。我们需要为 Barrier 指定引用的view的 ID ， 可以通过在 component tree 中把view拖动到 Barrier 来完成：</p><p><img src="/posts/1352bf96/barrier_references.gif" alt="barrier references"></p><p>一旦定义好之后，这些引用将被列为 Barrier 的 children。而且你还会在蓝色面板中看到Barrier跳到了新的位置（垂直的虚线）。</p><p>现在 Barrier 就已经定义好了，只剩下把textView3的约束从相对于 textView1 改为 相对于 Barrier 了：</p><p><img src="/posts/1352bf96/barrier_constrain.gif" alt="barrier constrain"></p><p>完了之后 textView3 就到了 textView2 的后面了。</p><p>为了看到整体的效果，可以切换语言，此时你会看到 Barrier 会自动位于较宽的那个 textView 后面，也就间接让 textView3 也位于了正确的位置：</p><p><img src="/posts/1352bf96/barrier_example.gif" alt="barrier example"></p><p><strong>在XML中创建Barriers</strong></p><p>XML代码其实也非常简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@string/warehouse"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@string/hospital"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/textView1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Barrier</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/barrier7"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:barrierDirection</span>=<span class="string">"end"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:constraint_referenced_ids</span>=<span class="string">"textView2,textView1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView3"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@string/lorem_ipsum"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@+id/barrier7"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>barrierAllowsGoneWidgets</strong></p><p><img src="/posts/1352bf96/Barrier-barrierAllowsGoneWidgets.gif" alt="Barrier barrierAllowsGoneWidgets"></p><p>目前button3和button1 button2的top对齐，此时如果button1 Gone了呢？</p><p>如上图效果,button1 gone之后，会变为一个点，所以button3顶齐父布局也没问题。但有的时候这不符合我们的需求，我们希望Barrier不要关注Gone的View了，所以谷歌提供了属性<code>barrierAllowsGoneWidgets</code>,设为false后，就不在关注Gone的View了，效果如上图,button1 gone之后,button3 不再和父布局顶齐,而是和button2顶齐。</p><p>Barrier特别的地方就在于Barrier元素自身。app:barrierDirection 属性决定 Barrier 的方向 － 这里把它放在被引用view的后面。被引用的view 是布局中的view的id列表，用逗号隔开。</p><p>借用一张图 来自<a href="https://medium.com/androiddevelopers/introducing-constraint-layout-1-1-d07fc02406bc" target="_blank" rel="noopener">https://medium.com/androiddevelopers/introducing-constraint-layout-1-1-d07fc02406bc</a></p><p><img src="/posts/1352bf96/Barrier-demo.gif" alt="Barrier demo"></p><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>使用组，您可以将某些视图分组在一起。不要把这与Android中的普通ViewGroups混淆。ConstraintLayout中的一个组<strong>仅包含对视图ID的引用，而不将组合中的视图嵌套</strong>。这样一来，您可以设置组中控件的可见性仅通过设置组的可见性就行了，而无需设置每个视图的可见性。这对于诸如错误屏幕或加载屏幕的事情是有用的，其中一些元素需要一次更改其可见性</p><p>其可使用到的属性为：</p><ul><li>constraint_referenced_ids：指定所引用控件的 id。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Group</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:constraint_referenced_ids</span>=<span class="string">"title, desc"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果有多个 Group，是可以同时指定相同的控件的，最终是以 XML 中最后声明的 Group 为准。</p><h4 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h4><p>Placeholder顾名思义，就是用来一个占位的东西，它可以通过 setContentId() 方法将占位符变为有效的视图。如果视图已经存在于屏幕上，那么视图将会从原有位置消失。</p><p>除此之外，还可以通过 setEmptyVisibility() 方法设置当视图不存在时占位符的可见性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/constraintLayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Placeholder</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/placeholder"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"96dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"96dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerInside"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"@+id/mail"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/favorite"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#00000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerInside"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/favorite"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:tint</span>=<span class="string">"#E64A19"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">"@id/mail"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/mail"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#00000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerInside"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/checked"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:tint</span>=<span class="string">"#512DA8"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">"@id/save"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@id/favorite"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/save"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#00000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerInside"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/star"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:tint</span>=<span class="string">"#D32F2F"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">"@id/play"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@id/mail"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/play"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#00000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerInside"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/delete"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:tint</span>=<span class="string">"#FFA000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@id/save"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoFragment</span> : <span class="type">Fragment</span></span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//call TransitionManager so and pass ConstraintLayout to perform smooth animation</span></span><br><span class="line">        TransitionManager.beginDelayedTransition(mConstraintLayout);</span><br><span class="line">        <span class="comment">//finally set clicked view at placeholder</span></span><br><span class="line">        mPlaceholder.setContentId(v.id)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> dashboardViewModel: DashboardViewModel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mConstraintLayout: ConstraintLayout</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mPlaceholder: Placeholder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: View? &#123;</span><br><span class="line">        dashboardViewModel =</span><br><span class="line">                ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(DashboardViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        <span class="keyword">val</span> root = inflater.inflate(R.layout.fragment_dashboard, container, <span class="literal">false</span>)</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">val</span> favorite: ImageButton = root.findViewById(R.id.favorite)</span><br><span class="line">        favorite.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> star : ImageButton = root.findViewById(R.id.star)</span><br><span class="line">        star.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> checked : ImageButton = root.findViewById(R.id.checked)</span><br><span class="line">        checked.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> delete : ImageButton = root.findViewById(R.id.delete)</span><br><span class="line">        delete.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        mConstraintLayout = root.findViewById(R.id.constraintLayout)</span><br><span class="line">        mPlaceholder = root.findViewById(R.id.placeholder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/1352bf96/Placeholder-demo.gif" alt="Placeholder demo"></p><h3 id="Optimizer-优化器"><a href="#Optimizer-优化器" class="headerlink" title="Optimizer (优化器)"></a>Optimizer (优化器)</h3><p>需要知道的是，当我们使用 MATCH_CONSTRAINT 时，ConstraintLayout 将不得不对控件进行 2 次测量，而测量的操作是昂贵的。</p><p>而优化器（Optimizer）的作用就是对 ConstraintLayout 进行优化，对应设置给 ConstraintLauyout 的属性是：</p><ul><li>layout_optimizationLevel。</li></ul><p>可设置的值有：</p><ul><li>none：不应用优化。</li><li>standard：仅优化直接约束和屏障约束（默认的）。</li><li>direct：优化直接约束。</li><li>barrier：优化屏障约束。</li><li>chain：优化链约束（实验）。</li><li>dimensions：优化尺寸测量（实验）。</li></ul><p>在设置值时，可以设置多个，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_optimizationLevel="direct|barrier|dimensions"</span><br></pre></td></tr></table></figure><h2 id="可视化编辑器"><a href="#可视化编辑器" class="headerlink" title="可视化编辑器"></a>可视化编辑器</h2><p>转换布局</p><p>切换试图</p><p>调整控件</p><p>autoconnect</p><p>Inference  <a href="https://www.jianshu.com/p/c34ce21f77b3" target="_blank" rel="noopener">https://www.jianshu.com/p/c34ce21f77b3</a></p><p><a href="http://quanqi.org/2016/05/20/code-labs-constraint-layout/" target="_blank" rel="noopener">http://quanqi.org/2016/05/20/code-labs-constraint-layout/</a></p><p><a href="https://developer.android.com/studio/write/layout-editor.html" target="_blank" rel="noopener">https://developer.android.com/studio/write/layout-editor.html</a></p><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p><a href="https://developer.android.com/reference/android/support/constraint/ConstraintsChangedListener" target="_blank" rel="noopener">https://developer.android.com/reference/android/support/constraint/ConstraintsChangedListener</a></p><p><a href="https://developer.android.com/reference/android/support/constraint/ConstraintSet" target="_blank" rel="noopener">https://developer.android.com/reference/android/support/constraint/ConstraintSet</a></p><p>Barriers clone() in ConstraintSet   1.1.3</p><p>约束集与动画</p><p>您可以将 <code>ConstraintLayout</code> 随同 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fsupport%2Fconstraint%2FConstraintSet.html" target="_blank" rel="noopener"><code>ConstraintSet</code></a> (约束集)一起使用来一次实现多个元素的动画效果。</p><p>一个 <code>ConstraintSet</code> 仅持有一个 <code>ConstraintLayout</code> 的约束。你可以在代码中创建一个<code>ConstraintSet</code>，或者从一个布局文件中加载它。然后，您可以将 <code>ConstraintSet</code> 应用于 <code>ConstraintLayout</code>，更新所有约束以匹配 <code>ConstraintSet</code> 中的约束。</p><p>要使其具有动画效果，请使用 support library 中的 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Ftransition%2FTransitionManager.html%23beginDelayedTransition%28android.view.ViewGroup%29" target="_blank" rel="noopener"><code>TransitionManager.beginDelayedTransition()</code></a> 方法。此功能将使您的 <code>ConstraintSet</code> 中的所有布局的更新都通过动画来呈现。</p><p>这是一个更深入地涵盖了这个话题的视频：</p><ul><li>YouTube 视频链接：<a href="https://youtu.be/OHcfs6rStRo" target="_blank" rel="noopener">https://youtu.be/OHcfs6rStRo</a></li></ul><p>  motionlaytout </p><p><a href="https://github.com/googlesamples/android-ConstraintLayoutExamples" target="_blank" rel="noopener">https://github.com/googlesamples/android-ConstraintLayoutExamples</a></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><a href="https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://www.jianshu.com/p/38ee0aa654a8" target="_blank" rel="noopener">细细品读！深入浅出，官方文档看ConstraintLayout</a></p><p><a href="https://www.jianshu.com/p/32a0a6e0a98a" target="_blank" rel="noopener">为什么ConstraintLayout代替其他布局?</a></p><p><a href="https://juejin.im/post/5adc8bd251882567236e58c1" target="_blank" rel="noopener">Android 约束布局（ConstraintLayout）1.1.0 版详解</a></p><p><a href="https://airsaid.com/20180205/Android-ConstraintLayout-Detailed/" target="_blank" rel="noopener">Android 约束布局（ConstraintLayout）详解</a></p><p><a href="https://www.jianshu.com/p/c34ce21f77b3" target="_blank" rel="noopener">未来布局之星——ConstraintLayout</a></p><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/1017/8601.html" target="_blank" rel="noopener">ConstraintLayout之Barrier</a></p><p><a href="https://www.jianshu.com/p/1ca5c53b96b2" target="_blank" rel="noopener">ConstraintLayout 之 Guideline、Barrier、Chains和Groups</a></p><p><a href="https://www.jianshu.com/p/4b23e789befb" target="_blank" rel="noopener">约束布局（ConstraintLayout）1.1.2 版本的新特性</a></p><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/1019/8618.html" target="_blank" rel="noopener">Constraint Layout 1.1.x带来了哪些新东西？</a></p><p><a href="https://www.jianshu.com/p/502127a493fb" target="_blank" rel="noopener">ConstraintLayout 用法全解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;继承关系&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;java.lang.Object&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;
      
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="ConstrainLayout UI" scheme="https://lingdage.com/tags/ConstrainLayout-UI/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask 源码分析</title>
    <link href="https://lingdage.com/posts/96014b68.html"/>
    <id>https://lingdage.com/posts/96014b68.html</id>
    <published>2019-03-26T06:39:02.000Z</published>
    <updated>2019-03-29T14:38:43.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">framework/base/core/java/andorid/os/AsyncTask.java</span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前讲解了能够在后台工作线程中执行耗时任务的<a href="https://lingdage.com/posts/20470e2e.html">IntentService</a>框架，在这里我们继续学习<code>Android</code>提供的另外一个异步执行任务的框架<code>AsyncTask</code>，它和<code>IntentService</code>既有相似点也有不同点，其相似之处在于都能在新的线程中执行耗时任务防止阻塞主线程，不同之处在于<code>AsyncTask</code>能够追踪任务的执行过程和结果并在主线程中显示出来。</p><a id="more"></a><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><h3 id="LinkedBlockingQueue-链阻塞队列"><a href="#LinkedBlockingQueue-链阻塞队列" class="headerlink" title="LinkedBlockingQueue 链阻塞队列"></a>LinkedBlockingQueue 链阻塞队列</h3><p>阻塞队列<code>BlockingQueue</code>被广泛使用在“生产者-消费者”问题中，其原因是<code>BlockingQueue</code>提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。<br><code>LinkedBlockingQueue</code> 类实现了<code>BlockingQueue</code> 接口。<code>LinkedBlockingQueue</code> 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。<code>LinkedBlockingQueue</code> 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>数组队列 ArrayDeque的特点</p><ul><li>大小自增长的队列</li><li>内部使用数组存储数据</li><li>线程不安全</li><li>内部数组长度为8、16、32….. 2的n次方</li><li>头指针head从内部数组的末尾开始，尾指针tail从0开始，在头部插入数据时，head减一，在尾部插入数据时，tail加一。当head==tail时说明数组的容量满足不了当前的情况，此时需要扩大容量为原来的二倍。</li></ul><h3 id="ExecutorService-执行器服务"><a href="#ExecutorService-执行器服务" class="headerlink" title="ExecutorService 执行器服务"></a>ExecutorService 执行器服务</h3><p>java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。</p><p><strong>ExecutorService 简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>首先使用 newFixedThreadPool() 工厂方法创建一个 <code>ExecutorService</code>。这里创建了一个十个线程执行任务的线程池。<br>然后，将一个 <code>Runnable</code> 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。</p><h3 id="ThreadPoolExecutor-线程池执行者"><a href="#ThreadPoolExecutor-线程池执行者" class="headerlink" title="ThreadPoolExecutor 线程池执行者"></a>ThreadPoolExecutor 线程池执行者</h3><p>ava.util.concurrent.ThreadPoolExecutor 是 <code>ExecutorService</code> 接口的一个实现。<code>ThreadPoolExecutor</code> 使用其内部池中的线程执行给定任务(Callable 或者 Runnable)。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看几个参数的含义及作用</p><ul><li>corePoolSize — 核心线程数，即允许闲置的线程数目</li><li>maximumPoolSize — 最大线程数，即这个线程池的容量</li><li>keepAliveTime — 非核心线程的闲置存活时间</li><li>unit — 上一个参数的单位</li><li>workQueue — 任务队列（阻塞队列）</li><li>threadFacotry — 线程创建工厂</li><li>handler — 当线程池或者任务队列容量已满时用于 reject</li></ul><h3 id="Callable-amp-amp-Future"><a href="#Callable-amp-amp-Future" class="headerlink" title="Callable&amp;&amp;Future"></a>Callable&amp;&amp;Future</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来讲，<code>Callable</code>接口等价于<code>Runable</code>，call()等价于run()，区别在于它是有返回值的。<br>我们可以通过<code>ExecutorService</code>调用<code>Callable</code>，执行后将返回<code>Future对象</code>，比如:<br><code>Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>接口两个方法着重理解下，一是<code>cancel(boolean mayInterruptIfRunning)</code>，顾名思义就是终止线程，二是<code>get()</code>，它会阻塞线程，直到Callable的call()返回对象，并以此作为返回值。至于<code>mayInterruptIfRunning</code>这个boolean值的含义，大家看看<code>FutureTask</code>中相应的源码就直到了，其实只是多了<code>thread.interrupt()</code>的逻辑而已。结合Callable的代码，Future的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable);</span><br><span class="line"><span class="comment">//阻塞线程，等待Callable.call()的返回值</span></span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure><p>FutureTask<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation </span></span><br><span class="line"><span class="comment">     * unless it has been cancelled. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从`FutureTask`的继承关系来看，它既是`Runable`也是Future，所以我们可以把当做Runable来使用，同时它也具备Future的能力，可以终止线程，可以阻塞线程，等待Callable的执行，并获取返回值。另外要注意的是，它的构造函数是public FutureTask(Callable&lt;V&gt; callable)，因此实例化FutureTask时需要Callable对象作为参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## AsyncTask 的使用方式</span><br><span class="line"></span><br><span class="line">### 使用示例</span><br><span class="line">```java</span><br><span class="line">private class DownloadFileTask extends AsyncTask&lt;String, Integer, Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPreExecute() &#123;</span><br><span class="line">        mProgress.setVisibility(View.VISIBLE);</span><br><span class="line">        mProgress.setMax(100);</span><br><span class="line">        mProgress.setProgress(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long doInBackground(String... uris) &#123;</span><br><span class="line">        int count = uris.length;</span><br><span class="line">        long size = 0;</span><br><span class="line">        for (int i = 1; i &lt;= count; i ++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 休眠5秒模拟下载过程</span><br><span class="line">                Thread.sleep(5 * 1000);</span><br><span class="line">                // 假设每个下载文件的大小为（序号*100）</span><br><span class="line">                size += i * 100;</span><br><span class="line">                // 发布进度更新</span><br><span class="line">                publishProgress( (100* i )/count);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onProgressUpdate(Integer... progress) &#123;</span><br><span class="line">        mProgress.setProgress(progress[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onPostExecute(Long result) &#123;</span><br><span class="line">        mText.setText(String.valueOf(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码可以看到要使用<code>AsyncTask</code>实行异步任务是非常容易的，只需要做两件事:</p><ul><li>确定在整个处理过程中需要的参数类型，包括<code>Params</code>,<code>Progress</code>和<code>Result</code>,分别对应着输入参数、进度参数和结果参数。</li><li>实现必要的回调方法，其中必须是实现的是<code>doInBackground</code>，耗时任务正是在这里进行处理的，可以想象<code>doInBackground</code>一定是在子线程里进行的；其他可选实现方法包括<code>onPreExecute</code>,<code>onProgressUpdate</code>和<code>onPostExecute</code>，这些在示例中都参与了UI的更新，所以一定是在主线程中进行的。</li></ul><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><p><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt; { ... }</code></p><p>可以发现<code>AsyncTask</code>中使用的都是泛型参数，在使用过程中要根据需求选择合适的参数类型，在示例中使用的参数类型分别是<code>String</code>,<code>Integer</code>和<code>Long</code>,如果某一个参数是不需要的，可以用<code>Void</code>来表示，下面通过一个表格来对每个参数进行说明：</p><table><thead><tr><th style="text-align:center">参数声明</th><th style="text-align:center">含义</th><th style="text-align:center">作用</th><th style="text-align:center">产生处/调用处</th><th style="text-align:center">注意事项</th></tr></thead><tbody><tr><td style="text-align:center">Params</td><td style="text-align:center">输入参数</td><td style="text-align:center">任务开始执行时客户端发送开始参数</td><td style="text-align:center">execute()中发送，在doInBackground()中调用。</td><td style="text-align:center">可变参类型</td></tr><tr><td style="text-align:center">Progress</td><td style="text-align:center">过程参数</td><td style="text-align:center">任务后台执行过程中服务端发布的当前执行进度</td><td style="text-align:center">在doInBackground()中产生并通过publishProgess()发送，在onProgressUpdate()调用。</td><td style="text-align:center">可变参类型</td></tr><tr><td style="text-align:center">Result</td><td style="text-align:center">结果参数</td><td style="text-align:center">任务执行完成后服务端发送的执行结果</td><td style="text-align:center">在doInBackground()中产生并在onPostExecute()中调用。</td></tr></tbody></table><blockquote><p>参数类型不能是基本数据类型，要使用对应的封装类型，例如示例的<code>Progress</code>和<code>Result</code>参数使用的<code>Integer</code>和<code>Long</code>而不是<code>int</code>和<code>long</code>。</p></blockquote><h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><table><thead><tr><th style="text-align:center">回调方法</th><th style="text-align:center">运行线程</th><th style="text-align:center">作用</th><th style="text-align:center">执行顺序</th><th style="text-align:center">是否需要重新实现</th></tr></thead><tbody><tr><td style="text-align:center">onPreExecute</td><td style="text-align:center">主线程</td><td style="text-align:center">在开始执行后台任务前进行初始化</td><td style="text-align:center">首先开始执行</td><td style="text-align:center">可选</td></tr><tr><td style="text-align:center">doInBackground</td><td style="text-align:center">后台线程</td><td style="text-align:center">执行后台耗时任务完成后返回结果</td><td style="text-align:center">onPreExecute 执行完成后执行</td><td style="text-align:center">必须实现</td></tr><tr><td style="text-align:center">publishProgress</td><td style="text-align:center">后台线程</td><td style="text-align:center">在执行任务过程中发布执行进度</td><td style="text-align:center">在 doInBackground 中执行</td><td style="text-align:center">无须实现，直接调用。</td></tr><tr><td style="text-align:center">onProgressUpdate</td><td style="text-align:center">主线程</td><td style="text-align:center">接收进度并在主线程处理</td><td style="text-align:center">在 publishProgress 之后执行</td><td style="text-align:center">可选</td></tr><tr><td style="text-align:center">onPostExecute</td><td style="text-align:center">主线程</td><td style="text-align:center">接收执行结果并在主线程处理</td><td style="text-align:center">在 doInBackground 执行完成后执行</td><td style="text-align:center">可选</td></tr></tbody></table><h2 id="AsyncTask-源码分析"><a href="#AsyncTask-源码分析" class="headerlink" title="AsyncTask 源码分析"></a>AsyncTask 源码分析</h2><p>回到我们一开始提到的那个示例代码，当我们定义了好自己的AsyncTask之后，要开始运行这个任务时非常简单，只需要一行代码：</p><blockquote><p><code>new DownloadFileTask().execute(url1, url2, url3);</code></p></blockquote><p>我们就以这个为切入点来分析，首先看下<code>execute()</code>做了什么</p><p>首先，new DownloadFileTask() ，执行DownloadFileTask的构造方法，因此必然会执行DownloadFileTask的父类AsyncTask的构造方法，也就是 AsyncTask() ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//设置当前任务已被执行</span></span><br><span class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">            Result result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//设置线程执行的优先级</span></span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                <span class="comment">//noinspection unchecked</span></span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的工作很简单，就是完成了mWorker 和 mFuture 的初始化工作，也就是Callable和Future 的初始化，并关联他们，让mFuture 可以获取mWorker 的执行结果，或者停止mWorker 的执行。</p><p>这里主要由两个方法call()和done()，总的来说当mFuture 开始被执行的时候，call() 就会执行，当这个任务执行完毕后done()方法就会执行。</p><p>那么这个mFuture 什么 时候会被执行呢？继续往下看<code>execute(Params... params)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task is already running."</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task has already been executed "</span></span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line">    <span class="comment">// 回调方法中首先被调用的方法，由于"execute()"是在主线程中执行的,</span></span><br><span class="line">    <span class="comment">// 目前为止也没有进行线程的切换，所以"onPreExecute"也是在主线程中执行的。</span></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就很清楚了，mStatus 默认状态为PENDING，因此任务开始执行后首先将其状态改为<code>RUNNING</code>；同时从异常判断我们也可以看出一个<code>AsyncTask</code>的execute方法不能同时执行两次。</p><p>接下来，onPreExecute()，我们是在onCreate 中开启了<code>AsyncTask</code>的任务，因此这个时候，依旧属于主线程，onPreExecute()方法也会工作在主线程，我们可以在这个方法中执行一些预备操作，初始相关内容。</p><p>mWorker，前面已经说过他就是实现了Callable接口，并添加了一个参数属性，在这里我们把executor中传入的参数赋给了这个属性。exec=sDefaultExecutor=SerialExecutor ，这里任务就开始真正的执行了；按照之前所说就会开始执行mFuture这个任务，因此就会开始执行mWorker的call方法。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;         <span class="comment">//设置当前任务已被执行</span></span><br><span class="line">&gt;         mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">&gt;         Result result = <span class="keyword">null</span>;</span><br><span class="line">&gt;         <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;             <span class="comment">//设置线程执行的优先级</span></span><br><span class="line">&gt;             &gt; &gt; &gt;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">&gt;             <span class="comment">//noinspection unchecked</span></span><br><span class="line">&gt;             result = doInBackground(mParams);</span><br><span class="line">&gt;             Binder.flushPendingCommands();</span><br><span class="line">&gt;         &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">&gt;             mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">&gt;             <span class="keyword">throw</span> tr;</span><br><span class="line">&gt;         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;             postResult(result);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> result;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>到这里，我们终于看到了熟悉的 <em>doInBackground</em>，这是我们必须实现的一个方法，在其中完成耗时操作，并返回结果。由于已经设置了Process的优先级，因此这个方法会处于后台进程。<br>在 <em>doInBackground</em> 里，我们还可以返回当前执行进度</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Long <span class="title">doInBackground</span><span class="params">(String... uris)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">int</span> count = uris.length;</span><br><span class="line">&gt;         <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i ++) &#123;</span><br><span class="line">&gt;             <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                 <span class="comment">// 休眠5秒模拟下载过程</span></span><br><span class="line">&gt;                 Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">&gt;                 <span class="comment">// 假设每个下载文件的大小为（序号*100）</span></span><br><span class="line">&gt;                 size += i * <span class="number">100</span>;</span><br><span class="line">&gt;                 <span class="comment">// 发布进度更新</span></span><br><span class="line">&gt;                 publishProgress( (<span class="number">100</span>* i )/count);</span><br><span class="line">&gt;             &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">&gt;                 ie.printStackTrace();</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> size;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>我们调用了 <em>publishProgress</em> 可以将 <em>doInBackground</em>中<strong>耗时任务的进度发送出去</strong>，大家都知道这个进度会<strong>发送</strong>到onProgressUpdate() 方法中，在onProgressUpdate我们可以方便的进行UI 更新，比如进度条进度更新等。那么他是怎么实现的呢？这就要看publishProgress这个方法的实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTaskResult 顾名思义，很好理解了，就是AsyncTask的执行结果，这是一个静态的内部类，包括两个属性mTask和mData 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsyncTask mTask;</span><br><span class="line">        <span class="keyword">final</span> Data[] mData;</span><br><span class="line"></span><br><span class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">            mData = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此publishProgress中 new AsyncTaskResult 就是创建了一个AsyncTaskResult,他的两个两个属性为当前的AsyncTask和任务任务执行进度。</p><p>到这里的逻辑很清楚了，如果当前任务没有被取消， 那么就从消息池中获取一个<code>Message</code>的实例，同时设置这个<code>Message</code>对象的msg.what=MESSAGE_POST_PROGRESS, msg.obj为一个<code>AsyncTaskResult</code>对象，最后执行sendToTarget方法，通过之前对Handler实现机制的了解，我们知道sendXXX方法殊途同归，所完成的任务都是将Message对象插入到MessageQueue当中，等着Looper的loop方法一个个取出。由于我们是在主线程开启了AsyncTask任务的执行，因此，一旦我们将一个消息插入到队列，那么就会执行Handler的handleMessage方法。下面就来看看你这个InternalHandler 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单,在handleMessage中首先取出结果，并强制转换为AsyncTaskResult对象，在msg.what=MESSAGE_POST_PROGRESS时，就会执行result.mTask.onProgressUpdate(result.mData);<br>mTask 就是当前AsyncTask，因此就会执行AsyncTask中声明的onProgressUpdate方法。这样，就把参数从一个子线程传递到了UI 线程，非常方便开发人员用这个完成相关业务。</p><p>我们再回到mWorker  的call() 方法中，当doInBackground执行完毕后，最后就会执行postResult。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和publishProgress逻辑一样，懂事把result 封装到一个AsyncTaskResult 对象中，做为一个Message对象的obj属性插入到MessageQueue中，只不过msg.what=MESSAGE_POST_RESULT.</p><p>这样就会来到<code>InternalHandler</code> 的<code>handleMessage</code>中，这一次<code>msg.what</code>=<code>MESSAGE_POST_RESULT</code>.时执行<code>result.mTask.finish(result.mData[0])</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也很简单，任务未取消时，onPostExecute(result) 方法被执行。这个onPostExecute(result)就是我们最后要执行的方法，在这个方法中得到最终的执行结果；并将任务状态标记为<code>FINISHED</code>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="串行or并行？"><a href="#串行or并行？" class="headerlink" title="串行or并行？"></a>串行or并行？</h3><p>在SimpleAsyncTask中，我们使用<code>private static final Executor EXECUTOR = Executors.newCachedThreadPool()</code>作为线程池，而实际上，源码中的默认线程池是自定义的，这个类是<code>SerialExecutor</code>，从类的命名上看，Serial是串行的意思，所以很明显，AsyncTask默认是串行的。除此之外，AsyncTask里还有个线程池 <code>THREAD_POOL_EXECUTOR</code>，实在需要并行的话我们就用这个线程池。</p><p>如果都些都不满足要求，我们也可以自定义符合自己业务要求的线程池，并通过<code>setDefaultExecutor(Executor exec)</code>改变默认的线程池。</p><p>在<strong>executeOnExecutor</strong>中我们还可以传入自己自定义的线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//跟默认一样的按顺序执行</span><br><span class="line">asyncTask.executeOnExecutor(Executors.newSingleThreadExecutor());</span><br><span class="line">//无限制的Executor</span><br><span class="line">asyncTask.executeOnExecutor(Executors.newCachedThreadPool());</span><br><span class="line">//同时执行数目为10的Executor</span><br><span class="line">asyncTask.executeOnExecutor(Executors.newFixedThreadPool(10));</span><br></pre></td></tr></table></figure><h3 id="postResultIfNotInvoked的作用是什么？"><a href="#postResultIfNotInvoked的作用是什么？" class="headerlink" title="postResultIfNotInvoked的作用是什么？"></a>postResultIfNotInvoked的作用是什么？</h3><p>AsyncTask有很多逻辑干扰了我们解读源码，postResultIfNotInvoked便是其中一个。它实际上是Google解决的一个bug，确保如果cancel()方法过早调用的场景下，onCancelled()仍然能顺利的执行，参考<a href="https://stackoverflow.com/questions/25322651/asynctask-source-code-questions" target="_blank" rel="noopener">stackoverflow这篇文章</a>。</p><h3 id="用这个玩意-退出页面必须取消运行-否则你下个页面用的时候就知道问题了-串行坑了我一次"><a href="#用这个玩意-退出页面必须取消运行-否则你下个页面用的时候就知道问题了-串行坑了我一次" class="headerlink" title="用这个玩意 退出页面必须取消运行 否则你下个页面用的时候就知道问题了 串行坑了我一次"></a>用这个玩意 退出页面必须取消运行 否则你下个页面用的时候就知道问题了 串行坑了我一次</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5c774c70e51d450636311481" target="_blank" rel="noopener">理解 AsyncTask 原理</a></p><p><a href="https://juejin.im/post/58842012570c350062c111dd" target="_blank" rel="noopener">关于AsyncTask的一次深度解析</a></p><p><a href="https://www.jianshu.com/p/b1574686faa3" target="_blank" rel="noopener">AsyncTask:一只命途多舛的小麻雀</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;framework/base/core/java/andorid/os/AsyncTask.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前讲解了能够在后台工作线程中执行耗时任务的&lt;a href=&quot;https://lingdage.com/posts/20470e2e.html&quot;&gt;IntentService&lt;/a&gt;框架，在这里我们继续学习&lt;code&gt;Android&lt;/code&gt;提供的另外一个异步执行任务的框架&lt;code&gt;AsyncTask&lt;/code&gt;，它和&lt;code&gt;IntentService&lt;/code&gt;既有相似点也有不同点，其相似之处在于都能在新的线程中执行耗时任务防止阻塞主线程，不同之处在于&lt;code&gt;AsyncTask&lt;/code&gt;能够追踪任务的执行过程和结果并在主线程中显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android Bound Service 知识总结</title>
    <link href="https://lingdage.com/posts/ccf7cf3d.html"/>
    <id>https://lingdage.com/posts/ccf7cf3d.html</id>
    <published>2019-03-25T03:35:44.000Z</published>
    <updated>2019-03-28T07:49:31.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。</p><p>本文向您介绍如何创建绑定服务，包括如何绑定到来自其他应用组件的服务。 不过，您还应参阅<a href="https://lingdage.com/posts/75909e64.html">Android Service 知识总结</a>，了解有关一般服务的更多信息，例如：如何利用服务传送通知、如何将服务设置为在前台运行等等。</p><p>绑定服务是 <code>Service</code> 类的实现，可让其他应用与其绑定和交互。要提供服务绑定，您必须实现 <code>onBind()</code> 回调方法。该方法返回的 <code>IBinder</code> 对象定义了客户端用来与服务进行交互的编程接口。</p><a id="more"></a><blockquote><p>绑定到已启动服务</p><p>正如<a href="https://lingdage.com/posts/75909e64.html">Android Service 知识总结</a>中所述，可以创建同时具有已启动和绑定两种状态的服务。 也就是说，可通过调用<code>startService()</code> 启动该服务，让服务无限期运行；此外，还可通过调用 <code>bindService()</code> 使客户端绑定到服务。</p><p>如果您确实允许服务同时具有已启动和绑定状态，则服务启动后，系统“不会”在所有客户端都取消绑定时销毁服务。 为此，您必须通过调用 <code>stopSelf()</code> 或 <code>stopService()</code> 显式停止服务。</p><p>尽管您通常应该实现 <code>onBind()</code> <em>或</em> <code>onStartCommand()</code>，但有时需要同时实现这两者。例如，音乐播放器可能发现让其服务无限期运行并同时提供绑定很有用处。 这样一来，Activity 便可启动服务进行音乐播放，即使用户离开应用，音乐播放也不会停止。 然后，当用户返回应用时，Activity 可绑定到服务，重新获得回放控制权。</p><p>请务必阅读<a href="https://lingdage.com/posts/75909e64.html#lifecycle">管理绑定服务的生命周期</a>部分，详细了解有关为已启动服务添加绑定时该服务的生命周期信息。</p></blockquote><p>客户端可通过调用 <code>bindService()</code> 绑定到服务。调用时，它必须提供 <code>ServiceConnection</code> 的实现，后者会监控与服务的连接。<code>bindService()</code> 方法会立即无值返回，但当 Android 系统创建客户端与服务之间的连接时，会对 <code>ServiceConnection</code> 调用 <code>onServiceConnected()</code>，向客户端传递用来与服务通信的 <code>IBinder</code>。</p><p>多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 <code>onBind()</code> 方法来检索 <code>IBinder</code>。系统随后无需再次调用 <code>onBind()</code>，便可将同一 <code>IBinder</code> 传递至任何其他绑定的客户端。</p><p>当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 <code>startService()</code> 也启动了该服务）。</p><p>当您实现绑定服务时，最重要的环节是定义您的 <code>onBind()</code> 回调方法返回的接口。您可以通过几种不同的方法定义服务的<code>IBinder</code> 接口，下文对这些方法逐一做了阐述。</p><h2 id="创建绑定服务"><a href="#创建绑定服务" class="headerlink" title="创建绑定服务"></a>创建绑定服务</h2><p>创建提供绑定的服务时，您必须提供 <code>IBinder</code>，用以提供客户端用来与服务进行交互的编程接口。 您可以通过三种方法定义接口：</p><ul><li><p>扩展 Binder 类<br>如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 <code>Binder</code> 类并从 <code>onBind()</code> 返回它的一个实例来创建接口。客户端收到 <code>Binder</code> 后，可利用它直接访问 <code>Binder</code> 实现中乃至 <code>Service</code>中可用的公共方法。<br>如果服务只是您的自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的服务被其他应用或不同的进程占用。</p></li><li><p>使用 Messenger<br>如需让接口跨不同的进程工作，则可使用 <code>Messenger</code> 为服务创建接口。服务可以这种方式定义对应于不同类型 <code>Message</code> 对象的 <code>Handler</code>。此 <code>Handler</code> 是 <code>Messenger</code> 的基础，后者随后可与客户端分享一个 <code>IBinder</code>，从而让客户端能利用 <code>Message</code> 对象向服务发送命令。此外，客户端还可定义自有 <code>Messenger</code>，以便服务回传消息。<br>这是执行进程间通信 (IPC) 的最简单方法，因为 <code>Messenger</code> 会在单一线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。</p></li><li><p>使用 AIDL<br>AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 <code>Messenger</code> 的方法实际上是以 AIDL 作为其底层结构。 如上所述，<code>Messenger</code> 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。<br>如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。</p><blockquote><p>注：大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用，本文也不会阐述如何将其用于您的服务。如果您确定自己需要直接使用 AIDL，请参阅 AIDL 文档。</p></blockquote><blockquote><p>在Android系统中，一个进程是不能直接访问另一个进程的内存的，需要提供一些机制在不同的进程之间进行通信，Android官方推出了AIDL(Android Interface Definition Language)，它是基于Binder机制的，至于官方为什么要采用Binder，查看<a href="https://www.zhihu.com/question/39440766" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制</a>，分析很全面。<br>如果组件与服务通信是在同一进程，就使用第一种方式；如果是跨进程通信，使用第二种和第三种，两者不同在于，Messenger不能处理多线程并发请求。</p></blockquote></li></ul><h3 id="Binder">扩展 Binder 类</h3><p>如果您的服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 <code>Binder</code> 类，让您的客户端通过该类直接访问服务中的公共方法。</p><blockquote><p><strong>注</strong>：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。</p></blockquote><p>以下是具体的设置方法：</p><ol><li><p>在您的服务中，创建一个可满足下列任一要求的<code>Binder</code><br> 实例：</p><ul><li>包含客户端可调用的公共方法</li><li>返回当前 <code>Service</code> 实例，其中包含客户端可调用的公共方法</li><li>或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法</li></ul></li><li><p>从 <code>onBind()</code> 回调方法返回此 <code>Binder</code> 实例。</p></li><li><p>在客户端中，从 <code>onServiceConnected()</code> 回调方法接收 <code>Binder</code>，并使用提供的方法调用绑定服务。</p></li></ol><blockquote><p><strong>注</strong>：之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组。</p></blockquote><p>例如，以下这个服务可让客户端通过 Binder 实现访问服务中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Binder given to clients</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">    <span class="comment">// Random number generator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random mGenerator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class used for the client Binder.  Because we know this service always</span></span><br><span class="line"><span class="comment">     * runs in the same process as its clients, we don't need to deal with IPC.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Return this instance of LocalService so clients can call public methods</span></span><br><span class="line">            <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** method for clients */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mGenerator.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalBinder</code> 为客户端提供 <code>getService()</code> 方法，以检索 <code>LocalService</code> 的当前实例。这样，客户端便可调用服务中的公共方法。 例如，客户端可调用服务中的 <code>getRandomNumber()</code>。</p><p>点击按钮时，以下这个 Activity 会绑定到 <code>LocalService</code> 并调用 <code>getRandomNumber()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    LocalService mService;</span><br><span class="line">    <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Bind to LocalService</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService.class);</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// Unbind from the service</span></span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Called when a button is clicked (the button in the layout file attaches to</span></span><br><span class="line"><span class="comment">      * this method with the android:onClick attribute) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            <span class="comment">// Call a method from the LocalService.</span></span><br><span class="line">            <span class="comment">// However, if this call were something that might hang, then this request should</span></span><br><span class="line">            <span class="comment">// occur in a separate thread to avoid slowing down the activity performance.</span></span><br><span class="line">            <span class="keyword">int</span> num = mService.getRandomNumber();</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"number: "</span> + num, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Defines callbacks for service binding, passed to bindService() */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className,</span></span></span><br><span class="line"><span class="function"><span class="params">                IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// We've bound to LocalService, cast the IBinder and get LocalService instance</span></span><br><span class="line">            LocalBinder binder = (LocalBinder) service;</span><br><span class="line">            mService = binder.getService();</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName arg0)</span> </span>&#123;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例说明了客户端如何使用 <code>ServiceConnection</code> 的实现和 <code>onServiceConnected()</code> 回调绑定到服务。<a href="#Binding">下文</a>更详细介绍了绑定到服务的过程。</p><blockquote><p><strong>注</strong>：在上例中，<code>onStop()</code> 方法将客户端与服务取消绑定。 客户端应在适当时机与服务取消绑定，如<a href="#Additional_Notes">附加说明</a>中所述。</p></blockquote><h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><blockquote><p>与 AIDL 比较</p><p>当您需要执行 IPC 时，为您的接口使用 <code>Messenger</code> 要比使用 AIDL 实现它更加简单，因为 <code>Messenger</code> 会将所有服务调用排入队列，而纯粹的 AIDL 接口会同时向服务发送多个请求，服务随后必须应对多线程处理。</p><p>对于大多数应用，服务不需要执行多线程处理，因此使用 <code>Messenger</code> 可让服务一次处理一个调用。如果您的服务必须执行多线程处理，则应使用 <a href="https://developer.android.com/guide/components/aidl.html?hl=zh-cn" target="_blank" rel="noopener">AIDL</a> 来定义接口。</p></blockquote><p>如需让服务与远程进程通信，则可使用 <code>Messenger</code> 为您的服务提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。</p><p>以下是 <code>Messenger</code> 的使用方法摘要：</p><ul><li>服务实现一个 <code>Handler</code>，由其接收来自客户端的每个调用的回调</li><li><code>Handler</code> 用于创建 <code>Messenger</code> 对象（对 <code>Handler</code> 的引用）</li><li><code>Messenger</code> 创建一个 <code>IBinder</code>，服务通过 <code>onBind()</code> 使其返回客户端</li><li>客户端使用 <code>IBinder</code> 将 <code>Messenger</code>（引用服务的 <code>Handler</code>）实例化，然后使用后者将 <code>Message</code> 对象发送给服务</li><li>服务在其 <code>Handler</code> 中（具体地讲，是在 <code>handleMessage()</code> 方法中）接收每个 <code>Message</code>。</li></ul><p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message 对象）是服务在其 Handler 中接收的。<br>以下是一个使用 Messenger 接口的简单服务示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Command to the service to display a message */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SAY_HELLO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handler of incoming messages from clients.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IncomingHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_SAY_HELLO:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">"hello!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Target we publish for clients to send messages to IncomingHandler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> IncomingHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When binding to the service, we return an interface to our messenger</span></span><br><span class="line"><span class="comment">     * for sending messages to the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">"binding"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，服务就是在 <code>Handler#handleMessage()</code> 方法中接收传入的 <code>Message</code>，并根据 what 成员决定下一步操作。</p><p>客户端只需根据服务返回的<code>IBinder</code> 创建一个 <code>Messenger</code>，然后利用 send() 发送一条消息。例如，以下就是一个绑定到服务并向服务传递 MSG_SAY_HELLO 消息的简单 Activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityMessenger</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Messenger for communicating with the service. */</span></span><br><span class="line">    Messenger mService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Flag indicating whether we have called bind on the service. */</span></span><br><span class="line">    <span class="keyword">boolean</span> mBound;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class for interacting with the main interface of the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This is called when the connection with the service has been</span></span><br><span class="line">            <span class="comment">// established, giving us the object we can use to</span></span><br><span class="line">            <span class="comment">// interact with the service.  We are communicating with the</span></span><br><span class="line">            <span class="comment">// service using a Messenger, so here we get a client-side</span></span><br><span class="line">            <span class="comment">// representation of that from the raw IBinder object.</span></span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This is called when the connection with the service has been</span></span><br><span class="line">            <span class="comment">// unexpectedly disconnected -- that is, its process crashed.</span></span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// Create and send a message to the service, using a supported 'what' value</span></span><br><span class="line">        Message msg = Message.obtain(<span class="keyword">null</span>, MessengerService.MSG_SAY_HELLO, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Bind to the service</span></span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class), mConnection,</span><br><span class="line">            Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// Unbind from the service</span></span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，此示例并未说明服务如何对客户端作出响应。如果您想让服务作出响应，则还需要在客户端中创建一个<code>Messenger</code>。然后，当客户端收到 <code>onServiceConnected()</code> 回调时，会向服务发送一条 <code>Message</code>，并在其 <code>send()</code> 方法的 <code>replyTo</code> 参数中包含客户端的 <code>Messenger</code>。</p><h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>AIDL，即<code>Android Interface Definition Language</code>，Android接口定义语言。它是一种IDL语言，可以拿来生成用于IPC的代码。在我看来，它其实就是一个模板。为什么这样说呢？在我们的使用中，实际上起作用的并不是我们写的AIDL代码，而是系统根据它生成的一个IInterface实例的代码。而如果大家多生成几个这样的实例，然后把它们拿来比较，你会发现它们都是有套路的——都是一样的流程，一样的结构，只是根据具体的AIDL文件的不同有细微的变动。所以其实AIDL就是为了避免我们一遍遍的写一些千篇一律的代码而出现的一个模板。</p><p>使用<code>Messenger</code>也是基于AIDL的，<code>Messenger</code>把所有请求都放在一个线程中，service每次处理一个。然而对于AIDL实现来说。service可以同时处理多个请求（应该是并发处理）。这种情况下，你的服务必须拥有多线程处理能力，并且是以线程安全的方式编写的。<br>要直接使用AIDL，你必须创建一个<code>.aidl</code>文件，其中定义了编程接口。 Android SDK 工具使用此文件来自动生成一个抽象类，其中实现了接口及对IPC的处理，然后我们就可以在自己的服务中继承该类。</p><p>那么如何使用AIDL来通过bindService()进行线程间通信呢？基本上有下面这些步骤：</p><p>服务端创建一个AIDL文件，将暴露给客户端的接口在里面声明<br>在service中实现这些接口<br>客户端绑定服务端，并将onServiceConnected()得到的IBinder转为AIDL生成的IInterface实例<br>通过得到的实例调用其暴露的方法<br>上面的描述其实比较抽象，基本上是那种看了也不知道怎么做的类型——这个如果要展开讲的话就又是长篇大论的了。基于这种考虑，这里只是简单的介绍一下AIDL这个东西，它的具体的语法，到底怎么来实现IPC，参考<a href="https://blog.csdn.net/xiaohanluo/article/details/53911529" target="_blank" rel="noopener">Android进程通信之Messenger&amp;AIDL使用详解</a>。</p><p></p><h2 id="Binding">绑定到服务</h2><br>应用组件（客户端）可通过调用 <code>bindService()</code> 绑定到服务。Android 系统随后调用服务的 <code>onBind()</code> 方法，该方法返回用于与服务交互的<code>IBinder</code>。<p></p><p>绑定是异步的。<code>bindService()</code> 会立即返回，“不会”使<code>IBinder</code>返回客户端。要接收 <code>IBinder</code>，客户端必须创建一个 <code>ServiceConnection</code> 实例，并将其传递给 <code>bindService()</code>。<code>ServiceConnection</code> 包括一个回调方法，系统通过调用它来传递<code>IBinder</code>。</p><blockquote><p><strong>注</strong>：只有 Activity、服务和内容提供程序可以绑定到服务 — 您<strong>无法</strong>从广播接收器绑定到服务。</p></blockquote><p>因此，要想从您的客户端绑定到服务，您必须：<br>1.实现<code>ServiceConnection</code>。<br>  您的实现必须重写两个回调方法：<br>  <code>onServiceConnected()</code><br>    系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。</p><p>  <code>onServiceDisconnected()</code><br>    Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。</p><p>2.调用 <code>bindService()</code>，传递 <code>ServiceConnection</code> 实现。<br>3.当系统调用您的 <code>onServiceConnected()</code> 回调方法时，您可以使用接口定义的方法开始调用服务。<br>4.要断开与服务的连接，请调用 <code>unbindService()</code>。<br>  如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。 更好的做法是在客户端与服务交互完成后立即取消绑定客户端。 这样可以关闭空闲服务。如需了解有关绑定和取消绑定的适当时机的详细信息，请参阅<a href="#Additional_Notes">附加说明</a>。</p><p>例如，以下代码段通过<a href="#Binder">扩展 Binder 类</a>将客户端与上面创建的服务相连，因此它只需将返回的 <code>IBinder</code>转换为 <code>LocalService</code>类并请求 <code>LocalService</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LocalService mService;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="comment">// Called when the connection with the service is established</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Because we have bound to an explicit</span></span><br><span class="line">        <span class="comment">// service that is running in our own process, we can</span></span><br><span class="line">        <span class="comment">// cast its IBinder to a concrete class and directly access it.</span></span><br><span class="line">        LocalBinder binder = (LocalBinder) service;</span><br><span class="line">        mService = binder.getService();</span><br><span class="line">        mBound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when the connection with the service disconnects unexpectedly</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onServiceDisconnected"</span>);</span><br><span class="line">        mBound = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端可通过将此 <code>ServiceConnection</code> 传递至 <code>bindService()</code> 绑定到服务。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService.class);</span><br><span class="line">bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><ul><li><code>bindService()</code> 的第一个参数是一个 <code>Intent</code>，用于显式命名要绑定的服务（但 Intent 可能是隐式的）</li><li>第二个参数是 <code>ServiceConnection</code> 对象</li><li>第三个参数是一个指示绑定选项的标志。它通常应该是 <code>BIND_AUTO_CREATE</code>，以便创建尚未激活的服务。其他可能的值为 <code>BIND_DEBUG_UNBIND</code> 和 <code>BIND_NOT_FOREGROUND</code>，或 <code>0</code>（表示无）。</li></ul><p></p><h3 id="Additional_Notes">附加说明</h3><br>以下是一些有关绑定到服务的重要说明：<p></p><ul><li>您应该始终捕获 <code>DeadObjectException</code> 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。</li><li>对象是跨进程计数的引用。</li><li>您通常应该在客户端生命周期的匹配引入 (bring-up) 和退出 (tear-down) 时刻期间配对绑定和取消绑定。 例如：<ul><li>如果您只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。</li><li>如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。</li></ul></li></ul><blockquote><p><strong>注</strong>：通常情况下，<strong>切勿</strong>在 Activity 的 <code>onResume()</code> 和 <code>onPause()</code> 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的处理保持在最低水平。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （<a href="https://developer.android.com/guide/components/activities.html?hl=zh-cn#CoordinatingActivities" target="_blank" rel="noopener">Activity</a>文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。）</p></blockquote><h2 id="管理绑定服务的生命周期"><a href="#管理绑定服务的生命周期" class="headerlink" title="管理绑定服务的生命周期"></a>管理绑定服务的生命周期</h2><p>当服务与所有客户端之间的绑定全部取消时，Android 系统便会销毁服务（除非还使用 <code>onStartCommand()</code> 启动了该服务）。因此，如果您的服务是纯粹的绑定服务，则无需对其生命周期进行管理 — Android 系统会根据它是否绑定到任何客户端代您管理。</p><p>不过，如果您选择实现 <code>onStartCommand()</code> 回调方法，则您必须显式停止服务，因为系统现在已将服务视为<em>已启动</em>。在此情况下，服务将一直运行到其通过 <code>stopSelf()</code> 自行停止，或其他组件调用 <code>stopService()</code> 为止，无论其是否绑定到任何客户端。</p><p>此外，如果您的服务已启动并接受绑定，则当系统调用您的 <code>onUnbind()</code> 方法时，如果您想在客户端下一次绑定到服务时接收 <code>onRebind()</code> 调用，则可选择返回 <code>true</code>。<code>onRebind()</code> 返回空值，但客户端仍在其 <code>onServiceConnected()</code> 回调中接收 <code>IBinder</code>。下图说明了这种生命周期的逻辑。</p><p><img src="/posts/ccf7cf3d/service_binding_tree_lifecycle.png" alt="service_binding_tree_lifecycle"></p><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><h3 id="Messenger与AIDL的比较"><a href="#Messenger与AIDL的比较" class="headerlink" title="Messenger与AIDL的比较"></a>Messenger与AIDL的比较</h3><p>首先，在实现的难度上，肯定是<code>Messenger</code>要简单的多——至少不需要写AIDL文件了(虽然如果认真的究其本质，会发现它的底层实现还是AIDL)。另外，使用<code>Messenger</code>还有一个显著的好处是它会把所有的请求排入队列，因此你几乎可以不用担心多线程可能会带来的问题。</p><p>但是这样说来，难道AIDL进行IPC就一无是处了么？当然不是，如果是那样的话它早就被淘汰了。一方面是如果项目中有并发处理问题的需求，或者会有大量的并发请求，这个时候Messenger就不适用了——它的特性让它只能串行的解决请求。另外，我们在使用Messenger的时候只能通过Message来传递信息实现交互，但是在有些时候也许我们需要直接跨进程调用服务端的方法，这个时候又怎么办呢？只能使用AIDL。</p><p>所以，这两种IPC方式各有各的优点和缺点，具体使用哪种就看具体的需要了——当然，能使用简单的就尽量使用简单的吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/components/bound-services.html?hl=zh-cn" target="_blank" rel="noopener">Android Developers/Docs/指南/绑定服务</a></p><p><a href="https://blog.csdn.net/luoyanglizi/article/details/51594016" target="_blank" rel="noopener">Android中的Service：Binder，Messenger，AIDL（2）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。&lt;/p&gt;
&lt;p&gt;本文向您介绍如何创建绑定服务，包括如何绑定到来自其他应用组件的服务。 不过，您还应参阅&lt;a href=&quot;https://lingdage.com/posts/75909e64.html&quot;&gt;Android Service 知识总结&lt;/a&gt;，了解有关一般服务的更多信息，例如：如何利用服务传送通知、如何将服务设置为在前台运行等等。&lt;/p&gt;
&lt;p&gt;绑定服务是 &lt;code&gt;Service&lt;/code&gt; 类的实现，可让其他应用与其绑定和交互。要提供服务绑定，您必须实现 &lt;code&gt;onBind()&lt;/code&gt; 回调方法。该方法返回的 &lt;code&gt;IBinder&lt;/code&gt; 对象定义了客户端用来与服务进行交互的编程接口。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android Service 知识总结</title>
    <link href="https://lingdage.com/posts/75909e64.html"/>
    <id>https://lingdage.com/posts/75909e64.html</id>
    <published>2019-03-23T09:18:16.000Z</published>
    <updated>2019-03-28T07:29:53.074Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码</em></p></blockquote><p><code>framework/base/core/java/andorid/app/Service.java</code></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>引用官方定义:</p><blockquote><p> <code>Service</code> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p><p> <strong>注意：</strong>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p></blockquote><a id="more"></a><p><code>Service</code>是一个可以在后台执行长时间操作而不使用用户界面的应用组件。那么问题来了，既然它不使用用户界面，那么它怎么知道应该什么时候开始执行什么操作呢？答案是——它可以与其他的引用组件形成一些联系，从而可以根据其传来的信息在合适的时候执行合适的操作。</p><p>一般来讲，这种联系分为两种：<code>startService()</code>以及<code>bindService()</code>。这两种联系都可以使得一个<code>Service</code>开始运行，但是在其他方面有着诸多不同。</p><table><thead><tr><th></th><th><strong>启动service的方式</strong></th><th><strong>停止service的方式</strong></th><th><strong>service与启动它的组件之间的通信方式</strong></th><th><strong>service的生命周期</strong></th></tr></thead><tbody><tr><td>startService</td><td>在其他组件中调用startService()方法后，服务即处于启动状态</td><td>service中调用stopSelf()方法，或者其他组件调用stopService()方法后，service将停止运行</td><td>没有提供默认的通信方式，启动service后该service就处于独立运行状态</td><td>一旦启动，service即可在后台无限期运行，即使启动service的组件已被销毁也不受其影响，直到其被停止</td></tr><tr><td>bindService</td><td>在其他组件中调用bindService()方法后，服务即处于启动状态</td><td>所有与service绑定的组件都被销毁，或者它们都调用了unbindService()方法后，service将停止运行</td><td>可以通过 ServiceConnection进行通信，组件可以与service进行交互、发送请求、获取结果，甚至是利用IPC跨进程执行这些操作</td><td>当所有与其绑定的组件都取消绑定(可能是组件被销毁也有可能是其调用了unbindService()方法)后，service将停止</td></tr></tbody></table><p>注：<br>1.表格中的“其他组件”不包括<code>Broadcast receiver</code>，其不能bindService,但是可以startService的</p><p>2.startService()与bindService()并不冲突，同一个service可能既有组件调用了startService()启动它，又有组件与它进行了绑定。当同一个service与其他组件同时存在这两种联系时，其生命周期会发生变化，必须<strong>从两种方法的角度看service均停止</strong>才能真正停止。</p><h2 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h2><p>创建一个<code>Service</code>一般有下面2个步骤</p><ul><li>创建一个类继承自<code>Service</code>(或它的子类，如<code>IntentService</code>)，重写里面的一些键的回调方法，如<code>onStartCommand()</code>，<code>onBind()</code>等</li><li>在Manifests文件里面为其声明，并根据需要配置一些其他属性。</li></ul><p>讲道理，这一切跟新建一个<code>Activity</code>非常的像。</p><ul><li>onCreate()<br>在每个<code>Service</code>的生命周期中这个方法会且仅会调用一次，并且它的调用在<code>onStartCommand()</code>以及<code>onBind()</code>之前，我们可以在这个方法中进行一些一次性的初始化工作。</li><li>onStartCommand()<br>当其他组件通过<code>startService()</code>方法启动<code>Service</code>时，此方法将会被调用。</li><li>onBind()<br>当其他组件通过<code>bindService()</code>方法与<code>Service</code>相绑定之后，此方法将会被调用。这个方法有一个<code>IBinder</code>的返回值，这意味着在重写它的时候必须返回一个<code>IBinder</code>对象，它是用来支撑其他组件与<code>Service</code>之间的通信的——另外，如果你不想让这个<code>Service</code>被其他组件所绑定，可以通过在这个方法返回一个null值来实现。</li><li>onDestroy()<br>这是<code>Service</code>一生中调用的最后一个方法，当这个方法被调用之后，<code>Service</code>就会被销毁。所以我们应当在这个方法里面进行一些资源的清理，比如注册的一些监听器什么的。</li></ul><p>在Manifests文件里进行声明的时候，只有android:name属性是必须要有的，其他的属性都可以没有。但是有的时候适当的配置可以让我们的开发进行地更加顺利，所以了解一下注册一个<code>Service</code>可以声明哪些属性也是很有必要的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:isolatedProcess</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>具体含义可参考<a href="https://developer.android.com/guide/topics/manifest/service-element.html?hl=zh-cn" target="_blank" rel="noopener">官网</a></p><ul><li>android:enabled : 如果为true，则这个<code>Service</code>可以被系统实例化，如果为false，则不行。默认为true</li><li>android:exported : 如果为true，则其他应用的组件也可以调用这个<code>Service</code>并且可以与它进行互动，如果为false，则只有与<code>Service</code>同一个应用或者相同user ID的应用可以开启或绑定此<code>Service</code>。它的默认值取决于<code>Service</code>是否有<code>intent filters</code>。如果一个filter都没有，就意味着只有指定了<code>Service</code>的准确的类名才能调用，也就是说这个<code>Service</code>只能应用内部使用——其他的应用不知道它的类名。这种情况下exported的默认值就为false。反之，只要有了一个filter，就意味着<code>Service</code>是考虑到外界使用的情况的，这时exported的默认值就为true</li><li>android:icon : 一个象征着这个<code>Service</code>的icon</li><li>android:isolatedProcess : 如果设置为true，这个<code>Service</code>将运行在一个从系统中其他部分分离出来的特殊进程中，我们只能通过Service API来与它进行交流。默认为false。</li><li>android:label : 显示给用户的这个<code>Service</code>的名字。如果不设置，将会默认使用<application>的label属性。</application></li><li>android:name : 这个<code>Service</code>的路径名，例如“com.lingdage.demo.ServiceDemo”。这个属性是唯一一个必须填的属性。</li><li>android:permission : 其他组件必须具有所填的权限才能启动这个<code>Service</code>。</li><li>android:process : <code>Service</code>运行的进程的name。默认启动的<code>Service</code>是运行在<strong>主进程</strong>中的。</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDemo</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ServiceDome"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">        <span class="comment">//只在service创建的时候调用一次，可以在此进行一些一次性的初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onStartCommand"</span>);</span><br><span class="line">        <span class="comment">//当其他组件调用startService()方法时，此方法将会被调用</span></span><br><span class="line">        <span class="comment">//在这里进行这个service主要的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onBind"</span>);</span><br><span class="line">        <span class="comment">//当其他组件调用bindService()方法时，此方法将会被调用</span></span><br><span class="line">        <span class="comment">//如果不想让这个service被绑定，在此返回null即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onDestroy"</span>);</span><br><span class="line">        <span class="comment">//service调用的最后一个方法</span></span><br><span class="line">        <span class="comment">//在此进行资源的回收</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:每个<code>Service</code>必须在<code>manifest</code>中 通过<service>来声明</service></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.ServiceDemo"</span> &gt;</span> </span><br><span class="line">&gt;   ... </span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>现在我们通过继承<code>Service</code>的方式定义了我们自己的<code>ServiceDemo</code>类,并且在<code>manifest</code>中声明了我们的<code>ServiceDemo</code>,接下来我们应该启动我们自己的服务.</p><p>请注意，<code>onStartCommand()</code> 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，<code>IntentService</code> 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从<code>onStartCommand()</code> 返回的值必须是以下常量之一：</p><ul><li><p><code>START_NOT_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则除非有挂起 Intent 要传递，否则系统<em>不会</em>重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p></li><li><p><code>START_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务并调用 <code>onStartCommand()</code>，但<em>不会</em>重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 <code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p></li><li><p><code>START_REDELIVER_INTENT</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用<code>onStartCommand()</code>。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p></li></ul><h2 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h2><p>另一个组件通过调用<code>startService()</code>方法，就可以启动一个特定的<code>Service</code>，并且这将导致<code>Service</code>中的<code>onStartCommand()</code>方法被调用。在调用<code>startService()</code>方法的时候，其他组件需要在方法中传递一个<code>Intent</code>参数，然后<code>Service</code>将会在<code>onStartCommand()</code>中接收这个<code>Intent</code>，并获取一些数据。比如此时某个<code>Activity</code>要将一些数据存入数据库中，我就可以通过<code>Intent</code>把数据传入<code>Service</code>，然后让<code>Service</code>去进行连接数据库，存储数据等操作，而此时用户可以执行其他的任何操作——甚至包括销毁那个<code>Activity</code>——这并不会影响<code>Service</code>存储数据这件事。</p><p>当一个<code>Service</code>通过这种方式启动之后，它的生命周期就已经不受启动它的组件影响了，它可以在后台无限期的运行下去，只要<code>Service</code>自身没有调用<code>stopSelf()</code>并且其他的组件没有调用针对它的<code>stopService()</code>。</p><p>另外，如果确定了使用这种方式启动<code>Service</code>并且不希望这个<code>Service</code>被绑定的话，那么也许除了传统的创建一个类继承<code>Service</code>之外我们有一个更好的选择——<a href="https://lingdage.com/posts/e4e64342.html">IntentService</a>。</p><p>相比<code>Service</code>，IntentService要简单许多。但是要注意的是，如果你有让<code>Service</code>同时处理多个请求的需求，这个时候就只能去继承Service了。这个时候就要自己去处理工作线</p><p>demo</p><p>我们通过一个<code>Intent</code>对象，并调用<code>startService()</code>方法来启动<code>ServiceDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ServiceDemo.class);  </span><br><span class="line">startService(startIntent);</span><br></pre></td></tr></table></figure><blockquote><p> 注意,假如我们是通过点击<code>Button</code>执行上面的代码,那么第一次点击的时候回执行其中的<code>onCreate()</code>和<code>onStartCommand()</code>方法,但是当我们第二次点击的时候就只会执行<code>onStartCommand()</code>方法了.</p><p>为什么会这样呢？<br>这是由于<code>onCreate()</code>方法只会在<code>Service</code>第一次被创建的时候调用，如果当前<code>Service</code>已经被创建过了(第一次点击创建了<code>ServiceDemo</code>)，不管怎样调用<code>startService()</code>方法，<code>onCreate()</code>方法都不会再执行。</p></blockquote><p>启动了之后,当我们想停止服务的时候该怎么做呢?</p><p>我们也是通过一个<code>Intent</code>对象，并调用<code>stopService()</code>方法来停止<code>ServiceDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ServiceDemo.class);</span><br><span class="line">stopService(stopIntent);</span><br></pre></td></tr></table></figure><h2 id="停止Service"><a href="#停止Service" class="headerlink" title="停止Service"></a>停止Service</h2><p>启动服务必须管理自己的生命周期。也就是说，除非系统必须回收内存资源，否则系统不会停止或销毁服务，而且服务在<code>onStartCommand()</code> 返回后会继续运行。因此，服务必须通过调用 <code>stopSelf()</code> 自行停止运行，或者由另一个组件通过调用 <code>stopService()</code> 来停止它。</p><p>一旦请求使用 <code>stopSelf()</code> 或 <code>stopService()</code> 停止服务，系统就会尽快销毁服务。</p><p>但是，如果服务同时处理多个 <code>onStartCommand()</code> 请求，则您不应在处理完一个启动请求之后停止服务，因为您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，您可以使用<code>stopSelf(int)</code> 确保服务停止请求始终基于最近的启动请求。也就说，在调用 <code>stopSelf(int)</code> 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 <code>onStartCommand()</code> 的 <code>startId</code>）。然后，如果在您能够调用 <code>stopSelf(int)</code> 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。</p><blockquote><p><strong>注意：</strong>为了避免浪费系统资源和消耗电池电量，应用必须在工作完成之后停止其服务。 如有必要，其他组件可以通过调用<code>stopService()</code> 来停止服务。即使为服务启用了绑定，一旦服务收到对 <code>onStartCommand()</code> 的调用，您始终仍须亲自停止服务。</p></blockquote><h2 id="创建绑定服务"><a href="#创建绑定服务" class="headerlink" title="创建绑定服务"></a>创建绑定服务</h2><p>绑定服务允许应用组件通过调用 <code>bindService()</code> 与其绑定，以便创建长期连接（通常不允许组件通过调用<code>startService()</code> 来<em>启动</em>它）。</p><p>如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。</p><p>要创建绑定服务，必须实现 <code>onBind()</code> 回调方法以返回 <code>IBinder</code>，用于定义与服务通信的接口。然后，其他应用组件可以调用 <code>bindService()</code> 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（您<em>不必</em>按通过 <code>onStartCommand()</code> 启动的服务那样来停止绑定服务）。</p><p>要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 <code>IBinder</code> 的实现，并且服务必须从 <code>onBind()</code> 回调方法返回它。一旦客户端收到 <code>IBinder</code>，即可开始通过该接口与服务进行交互。</p><p>多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 <code>unbindService()</code> 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。</p><p>bindService这是一种比startService更复杂的启动方式，同时使用这种方式启动的service也能完成更多的事情，比如其他组件可向其发送请求，接受来自它的响应，甚至通过它来进行IPC等等。我们通常将绑定它的组件成为客户端，而称它为服务器。</p><p>如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式</p><ul><li>继承Binder类</li><li>使用Messenger类(AIDL的简化版)</li><li>使用AIDL</li></ul><p>这一块比较复杂,我们新开一篇讲解。<a href="https://lingdage.com/posts/ccf7cf3d.html">Android Bound Service 知识总结</a></p><h2 id="在前台运行服务"><a href="#在前台运行服务" class="headerlink" title="在前台运行服务"></a>在前台运行服务</h2><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。</p><p>例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。</p><p>要请求让服务运行于前台，请调用 <code>startForeground()</code>。此方法采用两个参数：唯一标识通知的整型数和状态栏的<code>Notification</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = <span class="keyword">new</span> Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);</span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：</strong>提供给 <code>startForeground()</code> 的整型 ID 不得为 0。    </p></blockquote><p>要从前台移除服务，请调用<code>stopForeground()</code>。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。</p><h1 id="lifecycle">管理服务生命周期</h1><p>服务的生命周期比 <code>Activity</code>的生命周期要简单得多。但是，密切关注如何创建和销毁服务反而更加重要，因为服务可以在用户没有意识到的情况下运行于后台。</p><p>服务生命周期（从创建到销毁）可以遵循两条不同的路径：</p><ul><li><p>启动服务</p><p>该服务在其他组件调用 <code>startService()</code> 时创建，然后无限期运行，且必须通过调用 <code>stopSelf()</code> 来自行停止运行。此外，其他组件也可以通过调用 <code>stopService()</code> 来停止服务。服务停止后，系统会将其销毁。</p></li><li><p>绑定服务</p><p>该服务在另一个组件（客户端）调用 <code>bindService()</code> 时创建。然后，客户端通过 <code>IBinder</code> 接口与服务进行通信。客户端可以通过调用 <code>unbindService()</code> 关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统即会销毁该服务。 （服务<em>不必</em>自行停止运行。）</p></li></ul><p>这两条路径并非完全独立。也就是说，您可以绑定到已经使用 <code>startService()</code> 启动的服务。例如，可以通过使用<code>Intent</code>（标识要播放的音乐）调用 <code>startService()</code> 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 <code>bindService()</code> 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 <code>stopService()</code> 或 <code>stopSelf()</code> 不会实际停止服务。</p><h2 id="实现生命周期回调"><a href="#实现生命周期回调" class="headerlink" title="实现生命周期回调"></a>实现生命周期回调</h2><p>与 <code>Activity</code> 类似，服务也拥有生命周期回调方法，您可以实现这些方法来监控服务状态的变化并适时执行工作。 以下框架服务展示了每种生命周期方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mStartMode;       <span class="comment">// indicates how to behave if the service is killed</span></span><br><span class="line">    IBinder mBinder;      <span class="comment">// interface for clients that bind</span></span><br><span class="line">    <span class="keyword">boolean</span> mAllowRebind; <span class="comment">// indicates whether onRebind should be used</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is being created</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is starting, due to a call to startService()</span></span><br><span class="line">        <span class="keyword">return</span> mStartMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A client is binding to the service with bindService()</span></span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// All clients have unbound with unbindService()</span></span><br><span class="line">        <span class="keyword">return</span> mAllowRebind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRebind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A client is binding to the service with bindService(),</span></span><br><span class="line">        <span class="comment">// after onUnbind() has already been called</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is no longer used and is being destroyed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong>与 Activity 生命周期回调方法不同，您<em>不</em>需要调用这些回调方法的超类实现。</p></blockquote><p><img src="/posts/75909e64/service_lifecycle.png" alt="android service lifecycle"></p><p>通过实现这些方法，您可以监控服务生命周期的两个嵌套循环：</p><ul><li><p>服务的整个生命周期从调用<code>onCreate()</code> 开始起，到<code>onDestroy()</code>返回时结束。与 Activity 类似，服务也在<code>onCreate()</code>中完成初始设置，并在<code>onDestroy()</code>中释放所有剩余资源。例如，音乐播放服务可以在<code>onCreate()</code>中创建用于播放音乐的线程，然后在<code>onDestroy()</code>中停止该线程。</p><p>无论服务是通过 <code>startService()</code> 还是 <code>bindService()</code> 创建，都会为所有服务调用 <code>onCreate()</code> 和 <code>onDestroy()</code> 方法。</p></li><li><p>服务的有效生命周期从调用<code>onStartCommand()</code>或<code>onBind()</code>方法开始。每种方法均有<code>Intent</code>对象，该对象分别传递到<code>startService()</code>或<code>bindService()</code> 。</p><p>对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 <code>onStartCommand()</code> 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 <code>onUnbind()</code> 返回时结束。</p></li></ul><blockquote><p><strong>注：</strong>尽管启动服务是通过调用 <code>stopSelf()</code> 或 <code>stopService()</code> 来停止，但是该服务并无相应的回调（没有 <code>onStop()</code> 回调）。因此，除非服务绑定到客户端，否则在服务停止时，系统会将其销毁 — <code>onDestroy()</code> 是接收到的唯一回调。</p></blockquote><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="Service和Thread的关系"><a href="#Service和Thread的关系" class="headerlink" title="Service和Thread的关系"></a>Service和Thread的关系</h3><p>答案：<code>Service</code>和<code>Thread</code>之间没有任何关系！</p><ul><li><p>两者概念的迥异</p><ul><li><p><code>Thread</code> 是程序执行的最小单元，它是分配CPU的基本单位，<code>Android</code>系统中UI线程也是线程的一种，当然<code>Thread</code>还可以用于执行一些耗时异步的操作。</p></li><li><p><code>Service</code>是<code>Android</code>的一种机制，服务是运行在主线程上的，它是由系统进程托管。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是<code>Binder</code>，它是在linux层交换信息的一种IPC，而所谓的<code>Service</code>后台任务只不过是指没有UI的组件罢了。</p></li></ul></li><li><p>两者的执行任务迥异</p><ul><li>在<code>Android</code>系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作。如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。</li><li><code>Service</code> 则是<code>Android</code>系统中的组件，一般情况下它运行于<strong>主线程</strong>中，因此在<code>Service</code>中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称<code>Service</code>为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让<code>Service</code>执行耗时任务，可在<code>Service</code>中开启单独线程去执行。</li></ul></li><li><p>两者使用场景</p><ul><li><p>当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程<code>Thread</code>，这样才能保证UI线程不被占用而影响用户体验。</p></li><li><p>在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过<code>Service</code>+<code>Notification</code>方式在后台执行同时在通知栏显示着。</p></li></ul></li><li><p>两者的最佳使用方式<br>在大部分情况下，<code>Thread</code>和<code>Service</code>都会结合着使用，比如下载文件，一般会通过<code>Service</code>在后台执行+<code>Notification</code>在通知栏显示+<code>Thread</code>异步下载，再如应用程序会维持一个<code>Service</code>来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个<code>Thread</code>与<code>Service</code>的结合来方便我们执行后台耗时任务，它就是<code>IntentService</code>，(深入了解<code>IntentService</code>，可以看<a href="https://lingdage.com/posts/e4e64342.html">IntentService</a>)，当然<code>IntentService</code>并不适用于所有的场景，但它的优点是使用方便、代码简洁，不需要我们创建<code>Service</code>实例并同时也创建线程，某些场景下还是非常赞的！由于<code>IntentService</code>是单个<code>worker thread</code>，所以任务需要排队，因此不适合大多数的多任务情况。还有为什么不直接在<code>Activity</code>里创建呢？这是因为<code>Activity</code>很难对<code>Thread</code>进行控制，当<code>Activity</code>被销毁之后，就没有任何其它的办法可以再重新获取到<strong>之前创建的子线程的实例</strong>。而且在一个<code>Activity</code>中创建的子线程，另一个<code>Activity</code>无法对其进行操作。但是<code>Service</code>就不同了，所有的<code>Activity</code>都可以与<code>Service</code>进行关联(通过绑定)，然后可以很方便地操作其中的方法，即使<code>Activity</code>被销毁了，之后只要重新与<code>Service</code>建立关联，就又能够获取到原有的<code>Service</code>中<code>Binder</code>的实例。因此，使用<code>Service</code>来处理后台任务，<code>Activity</code>就可以放心地<code>finish</code>，完全不需要担心无法对后台任务进行控制的情况。</p></li></ul><h3 id="Service的种类"><a href="#Service的种类" class="headerlink" title="Service的种类"></a>Service的种类</h3><h4 id="按运行地点分类"><a href="#按运行地点分类" class="headerlink" title="按运行地点分类"></a><strong>按运行地点分类</strong></h4><table><thead><tr><th style="text-align:center"><strong>类别</strong></th><th style="text-align:center"><strong>区别</strong></th><th style="text-align:center"><strong>优点</strong></th><th style="text-align:center"><strong>缺点</strong></th><th style="text-align:center"><strong>应用</strong></th></tr></thead><tbody><tr><td style="text-align:center">本地服务(Local)</td><td style="text-align:center">该服务依附在主进程上</td><td style="text-align:center">服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。</td><td style="text-align:center">主进程被Kill后，服务便会终止。</td><td style="text-align:center">非常常见的应用如：音乐播放服务。</td></tr><tr><td style="text-align:center">远程服务(Remote)</td><td style="text-align:center">该服务是独立的进程</td><td style="text-align:center">服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。</td><td style="text-align:center">该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。</td><td style="text-align:center">一些提供系统服务的Service，这种Service是常驻的。</td></tr></tbody></table><h4 id="按运行类型分类"><a href="#按运行类型分类" class="headerlink" title="按运行类型分类"></a>按运行类型分类</h4><table><thead><tr><th style="text-align:center"><strong>类别</strong></th><th style="text-align:center"><strong>区别</strong></th><th style="text-align:center"><strong>应用</strong></th></tr></thead><tbody><tr><td style="text-align:center">前台服务</td><td style="text-align:center">会在通知一栏显示 ONGOING 的 Notification，</td><td style="text-align:center">当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。</td></tr><tr><td style="text-align:center">后台服务</td><td style="text-align:center">默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。</td><td style="text-align:center">当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。</td></tr></tbody></table><p>有同学可能会问，后台服务我们可以自己创建<code>ONGOING</code>的 <code>Notification</code> 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 <code>startForeground</code>（ android 2.0 及其以后版本 ）或 <code>setForeground</code>（android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，<code>ONGOING</code> 的 <code>Notification</code>任然会移除掉。</p><p>####　<strong>按使用方式分类</strong></p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">区别</th></tr></thead><tbody><tr><td style="text-align:center">startService 启动的服务</td><td style="text-align:center">主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService</td></tr><tr><td style="text-align:center">bindService 启动的服务</td><td style="text-align:center">该方法启动的服务要进行通信。停止服务使用unbindService</td></tr><tr><td style="text-align:center">startService 同时也 bindService 启动的服务</td><td style="text-align:center">停止服务应同时使用stepService与unbindService</td></tr></tbody></table><blockquote><p>特别注意:<br>1、你应当知道在调用 <code>bindService</code> 绑定到<code>Service</code>的时候，你就应当保证在某处调用 <code>unbindService</code> 解除绑定（尽管 <code>Activity</code>被 <code>finish</code> 的时候绑定会自动解除，并且<code>Service</code>会自动停止）；<br>2、你应当注意 使用<code>startService</code>启动服务之后，一定要使用 <code>stopService</code>停止服务，不管你是否使用<code>bindService</code>；<br>3、同时使用 <code>startService</code> 与 <code>bindService</code> 要注意到，<code>Service</code> 的终止，需要<code>unbindService</code>与<code>stopService</code>同时调用，才能终止 <code>Service</code>，不管 <code>startService</code> 与 <code>bindService</code> 的调用顺序，如果先调用 <code>unbindService</code> 此时服务不会自动终止，再调用 <code>stopService</code> 之后服务才会停止，如果先调用<code>stopService</code> 此时服务也不会终止，而再调用 <code>unbindService</code> 或者 之前调用 <code>bindService</code> 的 <code>Context</code>不存在了（如<code>Activity</code>被<code>finish</code> 的时候）之后服务才会自动停止；<br>4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 <strong>Activity</strong> 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（<code>Context</code>不存在了），对应服务的生命周期与上述相同。<br>5、在 sdk 2.0 及其以后的版本中，对应的 <code>onStart</code> 已经被否决变为了 <code>onStartCommand</code>，不过之前的 <code>onStart</code> 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用<code>onStartCommand</code>而不是 <code>onStart</code>。</p></blockquote><p>这两种启动方式生命周期可以参考<a href="https://www.jianshu.com/p/9ff1e04268c0" target="_blank" rel="noopener">Android Service本地服务详解</a></p><h3 id="onStartCommand详解"><a href="#onStartCommand详解" class="headerlink" title="onStartCommand详解"></a>onStartCommand详解</h3><p>第一次调用<code>startService</code>方法时，<code>onCreate</code>方法、<code>onStartCommand`</code>方法将依次被调用，而多次调用startService<code>时，只有</code>onStartCommand<code>方法被调用，最后我们调用</code>stopService<code>方法停止服务时</code>onDestory<code>方法被回调，这就是启动状态下</code>Service`的执行周期。接着我们重新回过头来进一步分析onStartCommand（Intent intent, int flags, int startId），这个方法有3个传入参数，它们的含义如下：</p><ul><li><p>intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service</p></li><li><p>flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：</p><ul><li>START_FLAG_REDELIVERY<br>这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。</li><li>START_FLAG_RETRY<br>该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。</li></ul></li><li><p>startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。</p></li></ul><hr><p>另外，我们注意到onStartCommand()的返回值是一个很奇怪的值<code>START_STICKY</code>，这是个什么呢？或者说这个方法的返回值是用来干嘛的呢？事实上，它的返回值是用来指定系统对当前线程的行为的。它的返回值必须是以下常量之一： </p><ul><li><p>START_NOT_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p></li><li><p>START_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但绝对不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p></li><li><p>START_REDELIVER_INTENT : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p></li></ul><h3 id="关于启动服务与绑定服务间的转换问题"><a href="#关于启动服务与绑定服务间的转换问题" class="headerlink" title="关于启动服务与绑定服务间的转换问题"></a>关于启动服务与绑定服务间的转换问题</h3><p>虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个<code>Service</code>创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个<code>Service</code>实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：</p><ul><li><p>先绑定服务后启动服务<br>如果当前<code>Service</code>实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主<code>Activity</code>被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p></li><li><p>先启动服务后绑定服务<br>如果当前<code>Service</code>实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有<code>Context</code>调用了<code>stopService()</code>或是服务本身调用了<code>stopSelf()</code>方法抑或内存不足时才会销毁服务。</p></li></ul><p>以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论<code>Service</code>是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用<code>Activity</code>那样通过调用<code>Intent</code> 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/luoyanglizi/article/details/51586437" target="_blank" rel="noopener">Android中的Service：默默的奉献者 (1)</a></p><p><a href="https://developer.android.com/guide/components/services?hl=zh-cn" target="_blank" rel="noopener">Android Developers/Docs/指南/服务</a></p><p><a href="https://juejin.im/entry/589fd89b61ff4b006b48e41c" target="_blank" rel="noopener">全面了解 Service</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/52709857" target="_blank" rel="noopener">关于Android Service真正的完全详解，你需要知道的一切</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;framework/base/core/java/andorid/app/Service.java&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;引用官方定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;code&gt;Service&lt;/code&gt; 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;注意：&lt;/strong&gt;服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 源码分析</title>
    <link href="https://lingdage.com/posts/26c77b42.html"/>
    <id>https://lingdage.com/posts/26c77b42.html</id>
    <published>2019-03-22T12:41:21.000Z</published>
    <updated>2019-04-04T02:44:53.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>ThreadLocal</code>类是<code>java.lang</code>包下的一个类，用于线程内部的数据存储，通过它可以在指定的线程中存储数据，本文针对该类进行原理分析。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>我们一般用ThreadLocal来提供线程局部变量。线程局部变量会在每个Thread内拥有一个副本，Thread只能访问自己的那个副本。</p><a id="more"></a><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值传递</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Integer temp = threadLocal.get();</span><br><span class="line">                threadLocal.set(temp + <span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">"current thread is "</span> + Thread.currentThread().getName() + <span class="string">" num is "</span> + threadLocal.get());</span><br><span class="line">            &#125;, <span class="string">"thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的输出结果是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">current thread is thread-<span class="number">1</span> num is <span class="number">5</span></span><br><span class="line">current thread is thread-<span class="number">3</span> num is <span class="number">5</span></span><br><span class="line">current thread is thread-<span class="number">0</span> num is <span class="number">5</span></span><br><span class="line">current thread is thread-<span class="number">4</span> num is <span class="number">5</span></span><br><span class="line">current thread is thread-<span class="number">2</span> num is <span class="number">5</span></span><br></pre></td></tr></table></figure><p>我们可以看到，每一个线程打印出来的都是5，哪怕我是先通过<code>ThreadLocal.get()</code>方法获取变量，然后再<code>set</code>进去，依然不会进行重复叠加。</p><p>这就是线程隔离。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取该线程的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//将数据放入ThreadLocalMap中，key是当前ThreadLocal对象，值是我们传入的value。</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//初始化ThreadLocalMap，并以当前ThreadLocal对象为Key，value为值存入map中。</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal#set()</code>方法主要是通过当前线程的<code>ThreadLocalMap</code>实现的。<code>ThreadLocalMap</code>是一个Map，它的key是<code>ThreadLoacl</code>，value是<code>Object</code>。</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//若该线程的ThreadLocalMap对象已存在，则直接获取该Map里的值；否则则通过初始化函数创建1个ThreadLocalMap对象</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上与set方法类似，就是先获取到当前线程的<code>ThreadLocalMap</code>，然后以this为key可以取得value</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>到这里我们基本上明白了<code>ThreadLocal</code>的工作原理，我们总结一下</p><ol><li><p>每个<code>Thread</code>实例内部都有一个<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>是一种Map，它的key是<code>ThreadLocal</code>，value是Object。</p></li><li><p><code>ThreadLocal#set()</code>方法其实是往当前线程的<code>ThreadLocalMap</code>中存入数据，其key是当前<code>ThreadLocal</code>对象，value是set方法中传入的值。</p></li><li><p>使用数据时，以当前<code>ThreadLocal</code>为key，从当前线程的<code>ThreadLocalMap</code>中取出数据。</p></li></ol><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p><code>ThreadLocal</code>的核心就是<code>ThreadLocalMap</code>,它是维护我们线程与变量之间关系的一个类。</p><h4 id="Entry内部类"><a href="#Entry内部类" class="headerlink" title="Entry内部类"></a>Entry内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">         * Entry数组的初始化大小</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">         * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">         * &lt;ThreadLocal, 保存的泛型值&gt;数组</span></span><br><span class="line"><span class="comment">         * 长度必须是2的N次幂</span></span><br><span class="line"><span class="comment">         * 这个可以参考为什么HashMap里维护的数组也必须是2的N次幂</span></span><br><span class="line"><span class="comment">         * 主要是为了减少碰撞，能够让保存的元素尽量的分散</span></span><br><span class="line"><span class="comment">         * 关键代码还是hashcode &amp; table.length - 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The number of entries in the table.</span></span><br><span class="line"><span class="comment">         * table里的元素个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">         * 扩容的阈值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line"><span class="comment">         * 根据长度计算扩容的阈值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Increment i modulo len.</span></span><br><span class="line"><span class="comment">         * 获取下一个索引，超出长度则返回0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Decrement i modulo len.</span></span><br><span class="line"><span class="comment">         * 返回上一个索引</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">// 初始化table的大小为16</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">// 通过hashcode &amp; （长度-1）的位运算，确定键值对的位置</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 创建一个新节点保存在table当中</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            <span class="comment">// 设置table内元素为1</span></span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 设置扩容阈值</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map including all Inheritable ThreadLocals</span></span><br><span class="line"><span class="comment">         * from given parent map. Called only by createInheritedMap.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * ThreadLocal本身是线程隔离的，按道理是不会出现数据共享和传递的行为的</span></span><br><span class="line"><span class="comment">         * 这是InheritableThreadLocal提供了了一种父子间数据共享的机制</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> parentMap the map associated with parent thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Object value = key.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们可以看到，在<code>ThreadLocalMap</code>这个内部类当中，又定义了一个<code>Entry</code>内部类，它是一个<code>WeakReference</code>准去的说继承自弱引用</li><li>ThreadLocal对象的引用被传到<code>WeakReference</code>的<code>reference</code>中，<code>entry.get()</code>被当作map元素的key，而Entry还多了一个字段<code>value</code>，用来存放ThreadLocal变量实际的值。</li><li>至于为什么要用弱引用呢？我想我源码上面的注释其实也写得很明白了，这ThreadLocal实际上就是个线程本地变量隔离作用的工具类而已，当线程走完了，肯定希望能回收这部分产生的资源，所以就用了弱引用。</li><li>由于是弱引用，若ThreadLocal对象不再有普通引用，GC发生时会将ThreadLocal对象清除。而Entry的key，即<code>entry.get()</code>会变为null。然而，GC只会清除被引用对象，<code>Entry</code>还被线程的ThreadLocalMap引用着，因而不会被清除。因而，<code>value</code>对象就不会被清除。除非线程退出，造成该线程的ThreadLocalMap整体释放，否则<code>value</code>的内存就无法释放，<strong>内存泄漏</strong>！</li><li>JDK的作者自然想到了这一点，因此在ThreadLocalMap的很多方法中，调用<code>expungeStaleEntries()</code>清除<code>entry.get() == null</code> 的元素，将Entry的value释放。所以，只要线程还在使用其他ThreadLocal，已经无效的ThreadLocal内存就会被清除。</li><li><strong>然而</strong>，我们大部分的使用场景是，ThreadLocal是一个<strong>静态变量</strong>，因此永远有普通引用指向每个线程中的ThreadLocalMap的该entry。因此该ThreadLocal的Entry永远不会被释放，自然<code>expungeStaleEntries()</code>就无能为力，<code>value</code>的内存也不会被释放。所以在我们确实用完了ThreadLocal后，可以主动调用<code>remove()</code>方法，主动删掉entry。</li></ul><p>我相信有人会有疑问，如果在我要用的时候，被回收了怎么办？下面的代码会一步步地让你明白，你考虑到的问题，这些大牛都已经想到并且解决了。接着看</p><h4 id="getEntry-amp-amp-getEntryAfterMiss"><a href="#getEntry-amp-amp-getEntryAfterMiss" class="headerlink" title="getEntry &amp;&amp; getEntryAfterMiss"></a>getEntry &amp;&amp; getEntryAfterMiss</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment"> * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment"> * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment"> * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过hashcode确定下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果找到则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 找不到的话接着从i位置开始向后遍历，基于线性探测法，是有可能在i之后的位置找到的</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key's hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 循环向后遍历</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 获取节点对应的k</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 相等则返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 如果为null，触发一次连续段清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 获取下一个下标接着进行判断</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a>expungeStaleEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> * 这个函数可以看做是ThreadLocal里的核心清理函数，它主要做的事情就是</span></span><br><span class="line"><span class="comment"> * 1、从staleSlot开始，向后遍历将ThreadLocal对象被回收所在Entry节点的value和Entry节点本身设置null，方便GC，并且size自减1</span></span><br><span class="line"><span class="comment"> * 2、并且会对非null的Entry节点进行rehash，只要不是在当前位置，就会将Entry挪到下一个为null的位置上</span></span><br><span class="line"><span class="comment"> * 所以实际上是对从staleSlot开始做一个连续段的清理和rehash操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 新的引用指向table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">     <span class="comment">// 先将传过来的下标置null</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;<span class="comment">// table的size-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">     <span class="comment">// 遍历删除指定节点所有后续节点当中，ThreadLocal被回收的节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">         <span class="comment">// 获取entry当中的key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果ThreadLocal为null，则将value以及数组下标所在位置设置null，方便GC</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重新计算key的下标</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 如果是当前位置则遍历下一个</span></span><br><span class="line">             <span class="comment">// 不是当前位置，则重新从i开始找到下一个为null的坐标进行赋值</span></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以说是<code>ThreadLocal</code>非常核心的一个清理方法，为什么会需要清理呢？或许很多人想不明白，我们用List或者是Map也好，都没有说要清理里面的内容。</p><p>但是这里是对于线程来说的隔离的本地变量，并且使用的是弱引用，那便有可能在GC的时候就被回收了。</p><ul><li><p>如果有很多Entry节点已经被回收了，但是在table数组中还留着位置，这时候不清理就会浪费资源</p></li><li><p>在清理节点的同时，可以将后续非空的Entry节点重新计算下标进行排放，这样子在get的时候就能快速定位资源，加快效率。</p></li></ul><h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the value associated with key.</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap的set方法，这个方法还是挺关键的</span></span><br><span class="line"><span class="comment"> * 通过这个方法，我们可以看出该哈希表是用线性探测法来解决冲突的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新开一个引用指向table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取table的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 获取对应ThreadLocal在table当中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从该下标开始循环遍历</span></span><br><span class="line"><span class="comment">     * 1、如遇相同key，则直接替换value</span></span><br><span class="line"><span class="comment">     * 2、如果该key已经被回收失效，则替换该失效的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k 为null，则替换当前失效的k所在Entry节点</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 找到空的位置，创建Entry对象并插入</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="comment">// table内元素size自增</span></span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新开一个引用指向table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="comment">// 记录当前失效的节点下标</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个for循环的prevIndex(staleSlot, len)可以看出</span></span><br><span class="line"><span class="comment">     * 这是由staleSlot下标开始向前扫描</span></span><br><span class="line"><span class="comment">     * 查找并记录最前位置value为null的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过for循环nextIndex(staleSlot, len)可以看出</span></span><br><span class="line"><span class="comment">     * 这是由staleSlot下标开始向后扫描</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果与新的key对应，直接赋值value</span></span><br><span class="line"><span class="comment">         * 则直接替换i与staleSlot两个下标</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">             <span class="comment">// 通过注释看出，i之前的节点里，没有value为null的情况</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在调用cleanSomeSlots进行启发式清理之前</span></span><br><span class="line"><span class="comment">             * 会先调用expungeStaleEntry方法从slotToExpunge到table下标所在为null的连续段进行一次清理</span></span><br><span class="line"><span class="comment">             * 返回值便是table[]为null的下标</span></span><br><span class="line"><span class="comment">             * 然后以该下标--len进行一次启发式清理</span></span><br><span class="line"><span class="comment">             * 最终里面的方法实际上还是调用了expungeStaleEntry</span></span><br><span class="line"><span class="comment">             * 可以看出expungeStaleEntry方法是ThreadLocal核心的清理函数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果当前下标所在已经失效，并且向后扫描过程当中没有找到失效的Entry节点</span></span><br><span class="line"><span class="comment">         * 则slotToExpunge赋值为当前位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    <span class="comment">// 如果并没有在table当中找到该key，则直接在当前位置new一个Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面的for循环探测过程当中</span></span><br><span class="line"><span class="comment">     * 如果发现任何无效的Entry节点，则slotToExpunge会被重新赋值</span></span><br><span class="line"><span class="comment">     * 就会触发连续段清理和启发式清理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment"> * 启发式地清理被回收的Entry</span></span><br><span class="line"><span class="comment"> * i对应的Entry是非无效的，有可能是失效被回收了，也有可能是null</span></span><br><span class="line"><span class="comment"> * 会有两个地方调用到这个方法</span></span><br><span class="line"><span class="comment"> * 1、set方法，在判断是否需要resize之前，会清理并rehash一遍</span></span><br><span class="line"><span class="comment"> * 2、替换失效的节点时候，也会进行一次清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">// Entry对象不为空，但是ThreadLocal这个key已经为null</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用该方法进行回收</span></span><br><span class="line"><span class="comment">             * 实际上不是只回收 i 这一个节点而已</span></span><br><span class="line"><span class="comment">             * 而是对 i 开始到table所在下标为null的范围内，对那些节点都进行一次清理和rehash</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double the capacity of the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从下标0开始，逐个向后遍历插入到新的table当中</span></span><br><span class="line"><span class="comment">     * 1、如遇到key已经为null，则value设置null，方便GC回收</span></span><br><span class="line"><span class="comment">     * 2、通过hashcode &amp; len - 1计算下标，如果该位置已经有Entry数组，则通过线性探测向后探测插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设置扩容的阈值</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    <span class="comment">// 更新size</span></span><br><span class="line">    size = count;</span><br><span class="line">    <span class="comment">// 指向新的Entry数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码就是调用set方法往<code>ThreadLocalMap</code>当中保存K-V关系的一系列代码，我就不分开再一个个讲了，这样大家看起来估计也比较方便，有连续性。</p><p>​    我们可以来看看一整个的set流程：</p><p>​    1、先通过hashcode &amp; (len - 1)来定位该<code>ThreadLocal</code>在table当中的下标i</p><p>​    2、从i开始for循环向后遍历</p><p>​        1）如果获取Entry节点的key与我们需要操作的<code>ThreadLocal</code>相等，则直接替换value</p><p>​        2）如果遍历的时候拿到了key为null的情况，则调用<code>replaceStaleEntry</code>方法进行与之替换。</p><p>​    3、如果上述两个情况都是，则直接在计算的出来的下标当中new一个Entry阶段插入。</p><p>​    4、进行一次启发式地清理并且如果插入节点后的size大于扩容的阈值，则调用resize方法进行扩容。</p><h4 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 将引用设置null，方便GC</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 从该位置开始进行一次连续段清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，remove节点的时候，也会使用线性探测的方式，当找到对应key的时候，就会调用clear将引用指向null，并且会触发一次连续段清理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>借用张流程图，来自<a href="https://juejin.im/post/5ca225adf265da30cd1847f3" target="_blank" rel="noopener">https://juejin.im/post/5ca225adf265da30cd1847f3</a></p><p><img src="/posts/26c77b42/threadlocal_flow_chart.png" alt="threadlocal_flow_chart.png"></p><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><p>不知从何时起，网上开始流传ThreadLocal有内存泄漏的问题。下面我们从ThreadLocal的内存入手，分析一下这种说法是否正确。话不多说直接上图。</p><p><img src="/posts/26c77b42/memory leak1.webp" alt=""></p><p>现在，我们假设ThreadLocal完成了自己的使命，与ThreadLocalRef断开了引用关系。此时内存图变成了这样。</p><p><img src="/posts/26c77b42/memory leak2.webp" alt=""></p><p>系统GC发生时，由于Heap中的ThreadLocal只有来自key的弱引用，因此ThreadLocal内存会被回收到。</p><p><img src="/posts/26c77b42/memory leak3.webp" alt=""></p><p>到这里，value被留在了Heap中，而我们没办法通过引用访问它。value这块内存将会持续到线程结束。导致内存泄漏。</p><p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。这样就能 <strong>一定情况下避免内存泄漏</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">     e != <span class="keyword">null</span>;</span><br><span class="line">     e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal get方法获取时，有一段如果Entry的key为null，移除Entry和Entry.value的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><ul><li>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li><li>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。</li></ul><p>如果不想依赖线程的生命周期,那就调用remove方法来释放value的内存吧。个人认为，这种设计应该也是JDK开发大佬的无奈之举。</p><p>还可以参考<a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">Java进阶（七）正确理解Thread Local的原理与适用场景</a></p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p><p>我们先来看看官方文档的说法：</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. 为了应对非常大和长时间的用途，哈希表使用弱引用的 key。**<br> 下面我们分两种情况讨论：</p></blockquote><ul><li><strong>key 使用强引用</strong>：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li><strong>key 使用弱引用</strong>：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</strong>。</li></ul><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h3 id="ThreadLocal-最佳实践"><a href="#ThreadLocal-最佳实践" class="headerlink" title="ThreadLocal 最佳实践"></a>ThreadLocal 最佳实践</h3><p>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><ul><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li></ul><p>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p><h3 id="跨线程传递"><a href="#跨线程传递" class="headerlink" title="跨线程传递"></a>跨线程传递</h3><p>参考<a href="https://juejin.im/post/5ca0238ae51d453d6970e1f2#heading-3" target="_blank" rel="noopener">揭开ThreadLocal的面纱#跨线程传递</a></p><h3 id="ThreadLocal-如何解决-Hash-冲突？"><a href="#ThreadLocal-如何解决-Hash-冲突？" class="headerlink" title="ThreadLocal 如何解决 Hash 冲突？"></a>ThreadLocal 如何解决 Hash 冲突？</h3><p>我们知道，HashMap是一种get、set都非常高效的集合，它的时间复杂度只有O(1)。但是如果存在严重的Hash冲突，那HashMap的效率就会降低很多。</p><p>与 HashMap 不同，ThreadLocalMap 结构非常简单，没有 next 引用，也就是说 ThreadLocalMap 中解决 Hash 冲突的方式并非链表的方式，而是采用线性探测的方式。所谓线性探测，就是根据初始 key 的 hashcode 值( key.threadLocalHashCode &amp; (len-1))确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。len是当前Entry[]的长度，这没什么好说的。那看来秘密就在threadLocalHashCode中了。我们来看一下threadLocalHashCode是如何产生的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单。有个全局的计数器nextHashCode，每有一个ThreadLocal产生这个计数器就会加0x61c88647，然后把当前值赋给threadLocalHashCode。关于0x61c88647这个神奇的常量，可以点<a href="https://www.jianshu.com/p/529c03d9b67e" target="_blank" rel="noopener">这里</a>。</p><h3 id="为什么ThreadLocal类内部的ThreadLocalMap要用Entry数组实现？"><a href="#为什么ThreadLocal类内部的ThreadLocalMap要用Entry数组实现？" class="headerlink" title="为什么ThreadLocal类内部的ThreadLocalMap要用Entry数组实现？"></a>为什么ThreadLocal类内部的ThreadLocalMap要用Entry数组实现？</h3><p>set方法只会设置一个值，直接用一个Entry不就解决问题了？为什么会涉及到数组，还会有数组扩容的问题？</p><p>首先明确一下<code>ThreadLocal</code>的<code>set</code>和<code>get</code>的过程</p><ul><li><p>调用<code>get()</code></p><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在,如果存在，则以当前的<code>ThreadLocal</code> 为 <code>key</code>，调用<code>ThreadLocalMap</code>中的<code>getEntry</code>方法获取对应的存储实体 <code>e</code>。找到对应的存储实体 <code>e</code>，获取存储实体 <code>e</code> 对应的 <code>value</code>值，即为我们想要的当前线程对应此<code>ThreadLocal</code>的值，返回结果值。</li><li>如果不存在，则证明此线程没有维护的<code>ThreadLocalMap</code>对象，调用<code>setInitialValue</code>方法进行初始化。返回<code>setInitialValue</code>初始化的值。</li></ul></li><li><p>调用<code>set(T value)</code></p><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在：</li><li>如果存在，则调用<code>map.set</code>设置此实体<code>entry</code>。</li><li>如果不存在，则调用<code>createMap</code>进行<code>ThreadLocalMap</code>对象的初始化，并将此实体<code>entry</code>作为第一个值存放至<code>ThreadLocalMap</code>中。</li></ul></li></ul><p>总结起来就是<br>ThreadLocal#get() 方法中首先取当前线程<br>然后从当前线程对象中获取 threadLocals 属性<br>这个属性就是 ThreadLocalMap 的一个对象<br>既然一个线程只对应一个 Thread 对象<br>那么一个线程中也就只有一个 ThreadLocalMap 对象<br>而一个程序中可以创建多个 ThreadLocal 对象<br>在同一个线程中都会访问到这个 Map<br>key就是一个指向threadLocal实例的一个弱引用<br>多个ThreadLocal实例的话，那么就key必然是不同的<br>那么这个 Map 就必须存储多个 value 值并考虑扩容</p><blockquote><p>此题来自知乎<a href="https://www.zhihu.com/question/279007680" target="_blank" rel="noopener">https://www.zhihu.com/question/279007680</a></p></blockquote><h3 id="ThreadLocal实现原理是什么"><a href="#ThreadLocal实现原理是什么" class="headerlink" title="ThreadLocal实现原理是什么"></a>ThreadLocal实现原理是什么</h3><p>通常，如果我不去看源代码的话，我猜<code>ThreadLocal</code>是这样子设计的：每个<code>ThreadLocal</code>类都创建一个<code>Map</code>，然后用线程的ID <code>threadID</code>作为<code>Map</code>的<code>key</code>，要存储的局部变量作为<code>Map</code>的<code>value</code>，这样就能达到各个线程的值隔离的效果。这是最简单的设计方法，JDK最早期的<code>ThreadLocal</code>就是这样设计的。</p><p>但是，JDK后面优化了设计方案，现时JDK8 <code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>哈希表，这个哈希表的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</p><p>这个设计与我们一开始说的设计刚好相反，这样设计有如下几点优势：</p><ol><li>这样设计之后每个<code>Map</code>存储的<code>Entry</code>数量就会变小，因为之前的存储数量由<code>Thread</code>的数量决定，现在是由<code>ThreadLocal</code>的数量决定。</li><li>当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能减少内存的使用。</li></ol><h3 id="与同步机制区别"><a href="#与同步机制区别" class="headerlink" title="与同步机制区别"></a>与同步机制区别</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">实现机制</th><th style="text-align:center">同步共享</th><th style="text-align:center">应用场景</th></tr></thead><tbody><tr><td style="text-align:center">ThreadLocal</td><td style="text-align:center">为每个线程都提供一个变量的副本，从而实现同时访问，而互不影响。<br><strong>(以空间换时间)</strong></td><td style="text-align:center">无需对该变量进行同步<br><strong>(每个线程都拥有自己的变量副本)</strong></td><td style="text-align:center">隔离多个线程的数据共享</td></tr><tr><td style="text-align:center">同步机制</td><td style="text-align:center">提供一个变量，让不同的线程排队访问<br><strong>(以时间换空间)</strong></td><td style="text-align:center">被作用”锁机制”的变量是多个线程共享的<br>- 通过对象的锁机制保证同一时间只有一个线程访问变量<br>- synchronized = 1个保留字，依靠JVM的锁机制来实现临界区的函数or变量的访问中的原子性</td><td style="text-align:center">同步多个线程对相同资源的并发访问，防止并发冲突</td></tr></tbody></table><p>更多参考<a href="https://www.zhihu.com/question/23089780" target="_blank" rel="noopener">ThreadLocal和synchronized的区别?</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5c948d3b6fb9a070ba314002" target="_blank" rel="noopener">ThreadLocal用法及原理</a></p><p><a href="https://blog.csdn.net/carson_ho/article/details/82344011" target="_blank" rel="noopener">Java多线程：神秘的线程变量 ThreadLocal 你了解吗？</a></p><p><a href="https://juejin.im/post/5c9ca318f265da60ce37b8a2" target="_blank" rel="noopener">深入理解ThreadLocal</a></p><p><a href="https://juejin.im/post/5c99c7c8f265da60e65ba56d" target="_blank" rel="noopener">ThreadLocal和ThreadLocalMap源码分析</a></p><p><a href="https://juejin.im/post/5ca0238ae51d453d6970e1f2" target="_blank" rel="noopener">揭开ThreadLocal的面纱</a></p><p><a href="https://www.jianshu.com/p/3ef661af6136" target="_blank" rel="noopener">ThreadLocal内存泄漏问题及如何解决</a></p><p><a href="https://juejin.im/post/5c805cb9f265da2d9e177f6d" target="_blank" rel="noopener">Java 200+ 面试题补充 ThreadLocal 模块</a></p><p><a href="https://juejin.im/post/5a0e985df265da430e4ebb92" target="_blank" rel="noopener">JAVA并发-自问自答学ThreadLocal</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;类是&lt;code&gt;java.lang&lt;/code&gt;包下的一个类，用于线程内部的数据存储，通过它可以在指定的线程中存储数据，本文针对该类进行原理分析。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;我们一般用ThreadLocal来提供线程局部变量。线程局部变量会在每个Thread内拥有一个副本，Thread只能访问自己的那个副本。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>IntentService 源码分析</title>
    <link href="https://lingdage.com/posts/e4e64342.html"/>
    <id>https://lingdage.com/posts/e4e64342.html</id>
    <published>2019-03-22T05:53:18.000Z</published>
    <updated>2019-03-27T14:35:17.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码</em></p></blockquote><p><code>framework/base/core/java/andorid/app/IntentService.java</code></p><h2 id="IntentService简介"><a href="#IntentService简介" class="headerlink" title="IntentService简介"></a>IntentService简介</h2><p><code>IntentService</code>是<code>Service</code>的子类，比普通的<code>Service</code>增加了额外的功能。先看<code>Service</code>本身存在两个问题：  </p><ul><li><code>Service</code>不会专门启动一条单独的进程，<code>Service</code>与它所在应用位于同一个进程中</li><li><code>Service</code> 也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。</li></ul><p><a href="https://lingdage.com/posts/75909e64.html"><code>Service</code></a>主要用来在后台进行任务处理，例如后台播放音乐、下载文件、上传文件等等。由于<code>Service</code>是运行在主线程中的，也有一定的时间限制，如果在主线程中对一个任务的处理时间超过了限制，进程就会出现“应用不响应”,即ANR, Application Not Responding。为了避免这样情况,一般都会在<code>Service</code>里用新的<code>thread</code>处理一些可能需要更多处理时间的任务。</p><p>其实Android早就替我们设计了一种更方便的<code>Service + Thread</code>模式，就是本文要讲的<code>IntentService</code>，通过它可以很方便地实现在<code>Service</code>中使用<code>Thread</code>进行耗时任务的处理。</p><a id="more"></a><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="扩展-IntentService-类"><a href="#扩展-IntentService-类" class="headerlink" title="扩展 IntentService 类"></a>扩展 IntentService 类</h3><p>以下是 <code>IntentService</code> 的实现示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A constructor is required, and must call the super IntentService(String)</span></span><br><span class="line"><span class="comment">   * constructor with a name for the worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The IntentService calls this method from the default worker thread with</span></span><br><span class="line"><span class="comment">   * the intent that started the service. When this method returns, IntentService</span></span><br><span class="line"><span class="comment">   * stops the service, as appropriate.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">      <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// Restore interrupt status.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您只需要一个构造函数和一个 <code>onHandleIntent()</code> 实现即可。</p><p>如果您决定还重写其他回调方法（如 <code>onCreate()</code>、<code>onStartCommand()</code> 或 <code>onDestroy()</code>），请确保调用超类实现，以便 <code>IntentService</code> 能够妥善处理工作线程的生命周期。</p><p>例如，<code>onStartCommand()</code> 必须返回默认实现（即，如何将 Intent 传递给 <code>onHandleIntent()</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">"service starting"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除 <code>onHandleIntent()</code> 之外，您无需从中调用超类的唯一方法就是 <code>onBind()</code>（仅当服务允许绑定时，才需要实现该方法）。</p><p>在下一部分中，您将了解如何在扩展 <code>Service</code> 基类时实现同类服务。该基类包含更多代码，但如需同时处理多个启动请求，则更适合使用该基类。</p><h3 id="扩展服务类"><a href="#扩展服务类" class="headerlink" title="扩展服务类"></a>扩展服务类</h3><p>正如上一部分中所述，使用 <code>IntentService</code> 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 <code>Service</code> 类来处理每个 Intent。</p><p>为了便于比较，以下提供了 <code>Service</code> 类实现的代码示例，该类执行的工作与上述使用 <code>IntentService</code> 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Looper mServiceLooper;</span><br><span class="line">  <span class="keyword">private</span> ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handler that receives messages from the thread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>(looper);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">          <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="comment">// Restore interrupt status.</span></span><br><span class="line">              Thread.currentThread().interrupt();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Stop the service using the startId, so that we don't stop</span></span><br><span class="line">          <span class="comment">// the service in the middle of handling another job</span></span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Start up the thread running the service.  Note that we create a</span></span><br><span class="line">    <span class="comment">// separate thread because the service normally runs in the process's</span></span><br><span class="line">    <span class="comment">// main thread, which we don't want to block.  We also make it</span></span><br><span class="line">    <span class="comment">// background priority so CPU-intensive work will not disrupt our UI.</span></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"ServiceStartArguments"</span>,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the HandlerThread's Looper and use it for our Handler</span></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>, <span class="string">"service starting"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// For each start request, send a message to start a job and deliver the</span></span><br><span class="line">      <span class="comment">// start ID so we know which request we're stopping when we finish the job</span></span><br><span class="line">      Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">      msg.arg1 = startId;</span><br><span class="line">      mServiceHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we get killed, after returning from here, restart</span></span><br><span class="line">      <span class="keyword">return</span> START_STICKY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// We don't provide binding, so return null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">"service done"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所见，与使用 <code>IntentService</code> 相比，这需要执行更多工作。</p><p>但是，因为是由您自己处理对 <code>onStartCommand()</code> 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。</p><p>请注意，<code>onStartCommand()</code> 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，<code>IntentService</code> 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从<code>onStartCommand()</code> 返回的值必须是以下常量之一：</p><ul><li><p><code>START_NOT_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则除非有挂起 Intent 要传递，否则系统<em>不会</em>重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p></li><li><p><code>START_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务并调用 <code>onStartCommand()</code>，但<em>不会</em>重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 <code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p></li><li><p><code>START_REDELIVER_INTENT</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用<code>onStartCommand()</code>。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。<br>以上大部分来自<a href="https://developer.android.com/guide/components/services?hl=zh-cn#ExtendingIntentService" target="_blank" rel="noopener">官方文档</a></p></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="创建工作线程"><a href="#创建工作线程" class="headerlink" title="创建工作线程"></a>创建工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>IntentService</code>第一次启动的时候会调用其<code>onCreate</code>来完成一些初始化操作：</p><p>首先创建了一个<code>HandlerThread</code>对象，这就是前面一直提到的<code>Worker线程</code>。大家对<code>Handler</code>和<code>Thread</code>都很了解，那这个<code>HandlerThread</code>是什么呢？简单来说，它就是内部有一个消息循环队列的线程，我们知道默认的线程内部是没有消息循环队列的，这就导致我们无法直接在其内部使用<code>Handler</code>。<code>Android</code>为了方便使用，直接提供了一个含有消息循环队列的<code>HandlerThread</code>。具体见<a href="https://lingdage.com/posts/b4da2c1c.html">HandlerThread 源码分析</a></p><p>利用已创建的<code>HandlerThread</code>内部的消息循环创建一个 <code>ServiceHandler</code>对象，这样它的消息处理函数<code>handleMessage</code>就会在对应的线程中执行了。</p><h3 id="接收和处理请求"><a href="#接收和处理请求" class="headerlink" title="接收和处理请求"></a>接收和处理请求</h3><p>我们其他组件通过<code>startService</code>来发送请求的，结合<code>service</code>的生命周期，会执行<code>onStartCommand</code>回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码看到，<code>onStartCommand</code>会直接调用<code>onStart</code>，在这里对发送过来的请求接收并通过<code>mServiceHandler</code>进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>handleMessage</code>中对接收到的请求用<code>onHandleIntent</code>进行实际处理，而<code>onHandleIntent</code>就是我们在使用过程中必须实现的处理逻辑。</p><h3 id="销毁Worker线程"><a href="#销毁Worker线程" class="headerlink" title="销毁Worker线程"></a>销毁Worker线程</h3><p>前面提到：当所有请求都被处理完成后，<code>service</code>就会被销毁，这是如何实现的呢？在上面看到<code>handleMessage</code>方法里在处理完当前请求时会调用<code>stopSelf(msg.arg1)</code>来尝试停止当前服务，之所以说“尝试”，是因为它不一定能真正停止服务。还是来看下<code>stopSelf(int)</code>的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Old version of &#123;<span class="doctag">@link</span> #stopSelfResult&#125; that doesn't return a result.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #stopSelfResult</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">stopSelfResult</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stopSelf(int)</code>的声明里提到它是<code>stopSelfResult(int)</code>的老版本，唯一的区别就是没有返回值。那我们直接看<code>stopSelfResult(int)</code>的声明，其中提到只有在当前的<code>service</code>的最近一次启动是<code>startId</code>发起的才会被停止。我们把这句话放在<code>IntentService</code>的场景里去理解，如果说当前接收到3个请求，在处理第一个请求后打算去停止服务，但是调用<code>stopSelf(int)</code>的时候发现最后一次启动是第三个请求发生的，并不会停止服务；处理完第二个请求后是类似的，只有在处理完第三个请求后，去尝试停止服务，这时发现最近一次启动就是它发起的，可以去停止服务了。</p><p>停止服务时，其<code>onDestroy</code>会得到调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mServiceLooper.quit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的用法例子可以参考<a href="https://www.jianshu.com/p/332b6daf91f0" target="_blank" rel="noopener">IntentService 示例与详解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>IntentService</code>相比父类<code>Service</code>而言，最大特点是其回调函数<code>onHandleIntent</code>中可以直接进行耗时操作，不必再开线程。其原理是<code>IntentService</code>的成员变量 <code>Handler</code>在初始化时已属于工作线程，之后<code>handleMessage</code>，包括<code>onHandleIntent</code>等函数都运行在工作线程中。</p><p>如果对<code>IntentService</code>的了解仅限于此，会有种<code>IntentService</code>很鸡肋的观点，因为在<code>Service</code>中开线程进行耗时操作也不麻烦。我当初也是这个观点，所以很少用<code>IntentService</code>。</p><p>但是<code>IntentService</code>还有一个特点，就是多次调用<code>onHandleIntent</code>函数（也就是有多个耗时任务要执行），多个耗时任务会按顺序依次执行。原理是其内置的<code>Handler</code>关联了任务队列，<code>Handler</code>通过<code>Looper</code>取任务执行是顺序执行的。</p><p>这个特点就能解决多个耗时任务需要顺序依次执行的问题。而如果仅用<code>Service</code>，开多个线程去执行耗时操作，就很难管理。</p><p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 <code>IntentService</code> 类实现服务也许是最好的选择。</p><h1 id="IntentService特征"><a href="#IntentService特征" class="headerlink" title="IntentService特征"></a>IntentService特征</h1><ul><li>会创建独立的worker线程用于在应用的主线程外执行传递给 <code>onStartCommand()</code> 的所有 Intent。</li><li>创建worker队列，用于将 Intent 逐一传递给 <code>onHandleIntent()</code> 实现，这样您就永远不必担心多线程问题。</li><li>所有请求处理完成后，<code>IntentService</code>会自动停止，无需调用<code>stopSelf()</code>方法停止<code>Service</code></li><li>为<code>Service</code>的<code>onBind()</code>提供默认实现，返回null</li><li>为<code>Service</code>的<code>onStartCommand</code>提供默认实现，可将<code>Intent</code> 依次发送到工作队列和 <code>onHandleIntent()</code> 实现。</li><li><code>IntentService</code>不会阻塞UI线程，而普通<code>Serveice</code>会导致ANR异常</li><li>可以启动<code>IntentService</code> 多次，而每一个耗时操作会以工作队列的方式在<code>IntentService</code> 的 <code>onHandleIntent</code> 回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推`</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/zhengyin_tmac/article/details/52446696" target="_blank" rel="noopener">IntentService的实际应用场景</a><br><a href="https://juejin.im/post/5c75f3e851882540a702ea8f" target="_blank" rel="noopener">理解 IntentService 原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;framework/base/core/java/andorid/app/IntentService.java&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;IntentService简介&quot;&gt;&lt;a href=&quot;#IntentService简介&quot; class=&quot;headerlink&quot; title=&quot;IntentService简介&quot;&gt;&lt;/a&gt;IntentService简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;IntentService&lt;/code&gt;是&lt;code&gt;Service&lt;/code&gt;的子类，比普通的&lt;code&gt;Service&lt;/code&gt;增加了额外的功能。先看&lt;code&gt;Service&lt;/code&gt;本身存在两个问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Service&lt;/code&gt;不会专门启动一条单独的进程，&lt;code&gt;Service&lt;/code&gt;与它所在应用位于同一个进程中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Service&lt;/code&gt; 也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://lingdage.com/posts/75909e64.html&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt;主要用来在后台进行任务处理，例如后台播放音乐、下载文件、上传文件等等。由于&lt;code&gt;Service&lt;/code&gt;是运行在主线程中的，也有一定的时间限制，如果在主线程中对一个任务的处理时间超过了限制，进程就会出现“应用不响应”,即ANR, Application Not Responding。为了避免这样情况,一般都会在&lt;code&gt;Service&lt;/code&gt;里用新的&lt;code&gt;thread&lt;/code&gt;处理一些可能需要更多处理时间的任务。&lt;/p&gt;
&lt;p&gt;其实Android早就替我们设计了一种更方便的&lt;code&gt;Service + Thread&lt;/code&gt;模式，就是本文要讲的&lt;code&gt;IntentService&lt;/code&gt;，通过它可以很方便地实现在&lt;code&gt;Service&lt;/code&gt;中使用&lt;code&gt;Thread&lt;/code&gt;进行耗时任务的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread 源码分析</title>
    <link href="https://lingdage.com/posts/b4da2c1c.html"/>
    <id>https://lingdage.com/posts/b4da2c1c.html</id>
    <published>2019-03-21T08:47:54.000Z</published>
    <updated>2019-03-27T09:01:00.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> <em>本文基于Android 9.0.0的源代码</em></p></blockquote><p><code>framework/base/core/java/andorid/os/HandlerThread.java</code></p><h2 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h2><p>在<a href="https://lingdage.com/posts/20470e2e.html">Handler源码分析</a>中我们提到,在子线程中创建<code>Handler</code>,要手动调用<code>Looper.prepare()</code>,创建的过程大致如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createManualThreadWithHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Android为了简化<code>Handler</code>的创建过程提供了一个便捷的类，使用它我们可以快速的创建一个带有<code>Looper</code>的线程，有了<code>Looper</code>这个线程，我们就可以生成<code>Handler</code>。</p><a id="more"></a><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: 创建并启动HandlerThread线程，内部包含Looper</span></span><br><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"lingdage"</span>);</span><br><span class="line">handlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 创建Handler</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 发送消息</span></span><br><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread id="</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="创建HandlerThread对象"><a href="#创建HandlerThread对象" class="headerlink" title="创建HandlerThread对象"></a>创建HandlerThread对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="comment">//HandlerThread的默认优先级是Process.THREAD_PRIORITY_DEFAULT,具体值为0。</span></span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的<code>HandlerThread</code>没有必要设置这么高的优先级，因而需要我们降低其优先级。注意！是Process里的优先级而不是Thread的。</p><h4 id="可控制的优先级"><a href="#可控制的优先级" class="headerlink" title="可控制的优先级"></a>可控制的优先级</h4><ul><li><code>THREAD_PRIORITY_DEFAULT</code>，默认的线程优先级，值为0。</li><li><code>THREAD_PRIORITY_LOWEST</code>，最低的线程级别，值为19。</li><li><code>THREAD_PRIORITY_BACKGROUND</code> 后台线程建议设置这个优先级，值为10。</li><li><code>THREAD_PRIORITY_MORE_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微优先，值为-1。</li><li><p><code>THREAD_PRIORITY_LESS_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微落后一些，值为1。</p><p>以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。</p><p>常见的加入优先级的方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>关于Android中线程的调度详情，请参考<a href="https://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/" target="_blank" rel="noopener">剖析Android中进程与线程调度之nice</a></p><h3 id="获取Looper"><a href="#获取Looper" class="headerlink" title="获取Looper"></a>获取Looper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用handlerThread 要先start</span></span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123; <span class="comment">// 进入同步块，当条件不满足时无限等待，</span></span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// 直到mLooper被设置成有效值了才退出while（当然也可能是线程状态不满足）；</span></span><br><span class="line">                wait();  <span class="comment">// run方法里的notifyAll就是用来唤醒这里的</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，直接看官方的注释就明白了。</p><h3 id="执行HandlerThread的run"><a href="#执行HandlerThread的run" class="headerlink" title="执行HandlerThread的run()"></a>执行HandlerThread的run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();  <span class="comment">//获取线程的tid</span></span><br><span class="line">    Looper.prepare();   <span class="comment">// 创建Looper对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">//获取looper对象</span></span><br><span class="line">        notifyAll(); <span class="comment">//唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();  <span class="comment">// 重写 onLooperPrepared，做一些初始化工作</span></span><br><span class="line">    Looper.loop();   <span class="comment">//loop方法是阻塞的 在未执行quit()或quitSafely()的时候后面代码是不执行的</span></span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Looper退出"><a href="#Looper退出" class="headerlink" title="Looper退出"></a>Looper退出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quitSafely();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>quit()</code>与<code>quitSafely()</code>的区别，仅仅在于是否移除当前正在处理的消息。移除当前正在处理的消息可能会出现不安全的行为。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>总结之前，我们先想一个场景，如果我们现在需要请求网络数据(假设需要请求一张图片,图片请求返回后需要更新UI),我们都知道UI线程中不允许进行耗时的网络请求。那么，我们通常会开启一个子线程来进行请求,如果你不用网络请求的三方库，一般会通过<code>new Thread()</code>,然后<code>start()</code>来完成吧！这样的话，如果有多次请求图片，那么我们就得new 很多个<code>Thread</code>。所以这是个问题！！！</p><p>问题解决分析<br>通过上面代码我们知道：<code>HandlerThread</code>一个子线程，并且含有一个<code>Looper</code>。<br>再来看看那个问题：我们之所以需要<code>new Thread()</code>,然后<code>start()</code>.是因为UI线程无法进行网络请求，但是，<code>HandlerThread</code>可是一个子线程，所以，在它里面可以直接请求网络，于是上面的<code>new Thread()</code>然后<code>start()</code>问题就解决了。<br>当然，就凭他是个子线程还没法说服我，虽然它是一个子线程不需要<code>new Thread()</code>，但是它自己也可能需要多次创建啊！只不过是从new一个<code>Thread</code>变成了<code>new HanderThread()</code>而已。这还不是没卵用。</p><p>那么如何解释它不需要重复创建呢？<br>其实也不难，只需要子线程不结束不就行了。(run方法中加个<code>while(true)</code>啊)，不过，它这里并不是<code>while(true)</code>,而是用到了调用了一个<code>loop()</code>方法。</p><p>loop方法是阻塞的，所以它后面的语句在它未退出的（可以通过quit()方法和quitSafely()方法退出）时候是没办法执行的。再加上它可以通过在外部实现一个Handler，然后，通过这个Handler给Looper发送message，近而源源不断的实现网络请求。所以，这就真正的解决了上面提出的那个问题。<br>这里给一个连接，里面介绍了如何在外部创建一个Handler,然后源源不断进行网络请求。<br><a href="https://blog.csdn.net/javazejian/article/details/52426353" target="_blank" rel="noopener">Android 多线程之HandlerThread 完全详解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HandlerThread</code>所做的就是在新开的子线程中创建了 <code>Looper</code>，那它的使用场景就是 <code>Thread</code>+<code>Looper</code>使用场景的结合，即：在子线程中执行耗时的、可能有多个任务的操作。</p><p><code>HandlerThread</code>比较适用于单线程+异步队列的场景，比如IO读写操作，耗时不多而且也不会产生较大的阻塞。对于网络IO操作，<code>HandlerThread</code>并不适合，因为它只有一个线程，还得排队一个一个等着。</p><p>对于本地IO读取操作，我们可以使用<code>postAtFrontOfQueue</code>方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。</p><p>使用 HandlerThread 的典型例子就是 IntentService，参考另一篇文章。<a href="https://lingdage.com/posts/e4e64342.html">IntentService 源码分析</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></p><p><a href="https://blog.csdn.net/qq_25184739/article/details/77926247" target="_blank" rel="noopener">HandlerThread</a></p><p><a href="https://www.jianshu.com/p/e9b2c0831b0d" target="_blank" rel="noopener">对HandlerThread的理解</a></p><p><a href="https://blog.csdn.net/u011240877/article/details/72905631" target="_blank" rel="noopener">Android 进阶15：HandlerThread 使用场景及源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; &lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;framework/base/core/java/andorid/os/HandlerThread.java&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用简介&quot;&gt;&lt;a href=&quot;#使用简介&quot; class=&quot;headerlink&quot; title=&quot;使用简介&quot;&gt;&lt;/a&gt;使用简介&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://lingdage.com/posts/20470e2e.html&quot;&gt;Handler源码分析&lt;/a&gt;中我们提到,在子线程中创建&lt;code&gt;Handler&lt;/code&gt;,要手动调用&lt;code&gt;Looper.prepare()&lt;/code&gt;,创建的过程大致如下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Handler mHandler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createManualThreadWithHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Looper.prepare();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Handler(Looper.myLooper());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Looper.loop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Android为了简化&lt;code&gt;Handler&lt;/code&gt;的创建过程提供了一个便捷的类，使用它我们可以快速的创建一个带有&lt;code&gt;Looper&lt;/code&gt;的线程，有了&lt;code&gt;Looper&lt;/code&gt;这个线程，我们就可以生成&lt;code&gt;Handler&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Handler源码分析</title>
    <link href="https://lingdage.com/posts/20470e2e.html"/>
    <id>https://lingdage.com/posts/20470e2e.html</id>
    <published>2019-03-04T07:15:49.000Z</published>
    <updated>2019-04-09T07:57:01.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码，来分析Handler的用法</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">framework/base/core/java/andorid/os/</span><br><span class="line">  - Handler.java</span><br><span class="line">  - Looper.java</span><br><span class="line">  - Message.java</span><br><span class="line">  - MessageQueue.java</span><br></pre></td></tr></table></figure><h2 id="Handler作用"><a href="#Handler作用" class="headerlink" title="Handler作用"></a>Handler作用</h2><ul><li>任务调度：即通过 <code>post()</code> 和 <code>send()</code> 等方法来指定某个任务在某个时间执行</li><li>线程切换：执行耗时的操作，比如网络请求，IO操作等，需要在子线程中运行，不然会阻塞主线程。<br>而执行完网络请求等耗时操作后通常需要更新UI，如果在子线程中更新UI，那么程序会崩溃。因为Android的UI是线程不安全的。 在Android中使用Rxjava，还要配合RxAndroid来使用，RxAndroid 内部就使用 Handler 来实现线程切换。</li></ul><a id="more"></a><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>常见的子线程中更新UI,复现代码,更具体见 <a href="https://juejin.im/post/5c7e19b7518825196101a47d" target="_blank" rel="noopener">Android子线程和更新UI问题</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">textView = (TextView) findViewById(R.id.txt);</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SystemClock.sleep(<span class="number">3000</span>);<span class="comment">//这句不加不会报错，具体分析见上面链接</span></span><br><span class="line">  textView.setText(<span class="string">"from来自子线程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;).start();</span><br></pre></td></tr></table></figure></p><p>运行异常信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ErrorInfo: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br><span class="line">        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6903)</span><br><span class="line">        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1050)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.widget.TextView.checkForRelayout(TextView.java:7368)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:4480)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:4337)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:4312)</span><br></pre></td></tr></table></figure></p><p>可以看到错误发生在<strong>android.view.ViewRootImpl#checkThread</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见此处会判断<code>mThread</code>是不是等于当前线程<br>看下<code>mThread</code>到底是啥，在何处赋值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中被赋值的，也就是说是创建<code>ViewRootImpl</code>时所在的线程<br><code>ViewRootImpl</code>又是在哪里被创建的呢?这里不深入讲了，是在main线程<br>更具体的异常分析可以参考<a href="https://github.com/peerless2012/AndroidBasis/blob/master/problem/Only%20the%20original%20thread%20that%20created%20a%20view%20hierarchy%20can%20touch%20its%20views.%20%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84.md" target="_blank" rel="noopener">这个</a></p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">android.os.Handler handler = <span class="keyword">new</span> Handler()&#123;<span class="comment">//在主线程中获取handler</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里接受并处理消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">2000</span>);<span class="comment">//子线程中执行耗时操作</span></span><br><span class="line">         <span class="comment">//发送消息</span></span><br><span class="line">         Message message = Message.obtain();</span><br><span class="line"> message.what=<span class="number">1</span>;</span><br><span class="line"> message.obj=<span class="keyword">new</span> Object();</span><br><span class="line">     handler.sendMessage(message);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实例化一个 <code>Handler</code> 重写<code>handleMessage</code>方法 ，然后在需要的时候调用它的 <code>send</code> 以及 <code>post</code>系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档）</p><p>但是我们并没有看到<code>Handler</code>是如何与<code>MessageQueue</code>以及<code>Looper</code>关联起来的，下面我们进入源码分析下</p><h2 id="Handler-源码分析"><a href="#Handler-源码分析" class="headerlink" title="Handler 源码分析"></a>Handler 源码分析</h2><h3 id="Handler-实例化"><a href="#Handler-实例化" class="headerlink" title="Handler  实例化"></a>Handler  实例化</h3><p>从构造函数开始,我们通常从主线程中创建,先看下Handler的构造函数有哪些</p><ul><li><p>Handler()</p></li><li><p>Handler(Callback callback)</p></li><li><p>Handler(Looper looper)</p></li><li><p>Handler(Looper looper, Callback callback)</p></li><li><p>Handler(boolean async)</p></li><li><p>Handler(Callback callback, boolean async)</p></li><li><p>Handler(Looper looper, Callback callback, boolean async)</p></li></ul><p>看最后两个构造方法就行，因为前面的几个也是依次调用到后的方法</p><p>先看<code>Handler(Callback callback, boolean async)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Handler(Looper looper, Callback callback, boolean async)</code>与上面的区别就是<code>Looper</code>是赋值进去的。</p><h3 id="Looper-实例化"><a href="#Looper-实例化" class="headerlink" title="Looper 实例化"></a>Looper 实例化</h3><p>由上面可以看到调用<code>Looper#myLooper</code>方法获取到Looper对象， 如果mLooper == null的话，会抛出异常</p><blockquote><p>Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p>这个错误我们应该也见过。实际上我们在实例化 <code>Handler</code> 的时候 会去检查当前线程的 <code>Looper</code> 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 <code>Looper</code> 。<br>我们平时一般不会遇到这个错，因为我们大多数都是在主线程创建<code>Handler</code>的，而为什么在主线程就不要自己创建<code>Looper</code>，我们待会再看，目前只需要知道如果<code>Looper.myLooper()</code>没有获取到<code>Looper</code>对象的话就会报这个错。</p><p>我们跟踪<code>Looper#myLooper</code>方法进去，解决为什么会抛出这个异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有一行代码，从线程中取出<code>Looper</code>对象，那么我们有理由相信，这个<code>ThreadLocal</code>是通过set方法把<code>Looper</code>对象设置进去的。关于<code>ThreadLocal</code>，参考<a href="https://lingdage.com/posts/26c77b42.html">ThreadLocal 源码分析</a>。</p><p>想一想ThreadLocal在哪里把Looper对象设置进去了呢。回到刚才想要解决的问题：Can’t create handler inside thread that has not called Looper.prepare() 。那会不会是Looper的prepare方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用私有构造方法    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>确实是在<code>Looper#prepare</code>方法里把<code>Looper</code>对象设置进去的，而且从第一行的判断可以知道，一个线程只有一个<code>Looper</code>对象。 </p><p>所以，要创建<code>Handler</code>,那么<code>Looper.myLooper()</code>就必须非空，上面分析得出要非空，要先调用<code>Looper.prepare()</code>。</p><p>到了这里，<code>Looper</code>与<code>ThreadLocal</code>建立起了关联。</p><h3 id="MessageQueue-实例化"><a href="#MessageQueue-实例化" class="headerlink" title="MessageQueue 实例化"></a>MessageQueue 实例化</h3><p>接着上面继续看下<code>Looper</code>的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们实例化一个 <code>Looper</code> 的时候会调用它的构造方法，并在其中实例化一个<code>MessageQueue</code>，相比于 <code>Looper</code> 和<code>Handler</code>，<code>MessageQueue</code>就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 <code>native</code> 的方法。可以在 <a href="https://link.juejin.im/?target=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fframeworks%2Fbase%2F%2B%2Fmaster%2Fcore%2Fjni%2Fandroid_os_MessageQueue.cpp" target="_blank" rel="noopener">android_os_MessageQueue</a> 查看其源码的定义。更多参考<a href="https://juejin.im/post/5bdec872e51d4551ee2761cb#heading-6" target="_blank" rel="noopener">MessageQueue 的实例化</a></p><p>我们接着看<code>Handle</code>构造函数里的</p><blockquote><p>mQueue = mLooper.mQueue</p></blockquote><p>我们知道消息是存放在<code>MessageQueue</code>消息队列中的,而<code>MessageQueue</code>就是在上面<code>Looper</code>构造函数中new出来的，至此<code>Handler</code>通过<code>Looper</code>与<code>MessageQueue</code>也建立起了关联。</p><p>总结一下，创建<code>Handler</code>,他的构造函数中会先调用<code>Looper.myLooper()</code>获取Looper，也即是从<code>ThreadLocal</code>中获取，而<code>ThreadLocal</code>中要想获取到，要先调用<code>Looper.prepare()</code>来set值，那么问题又来了，我们写程序时好像没有手动调用<code>Looper.prepare()</code>吧，也不会抛出异常。其实这是一个特殊情况，我们通常都是在主线程，也就是UI线程中创建handler的。而在主线程中，系统已经为我们创建了一个<code>Looper</code>对象，所以不会抛出异常了,而那些会抛出异常报错的情况，是在子线程中创建的<code>Handler</code>，但是又没有调用<code>Looper.prepare()</code>去创建<code>Looper</code>对象。<br>继续看，主线程在什么时候创建了<code>Looper</code>对象吧。</p><p>在<code>ActivityThread</code>的main方法，这个方法是应用程序的入口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Looper.prepareMainLooper();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到第一行还是调用了<code>prepar(false）</code>方法的(false代表不可退出)。所以主线程是已经创建了一个<code>Looper</code>对象的。 </p><p><code>Handler</code>的创建过程分析完毕，现在总算搞明白了。</p><h3 id="Handler、MessageQueue-和-Looper-之间的关系"><a href="#Handler、MessageQueue-和-Looper-之间的关系" class="headerlink" title="Handler、MessageQueue 和 Looper 之间的关系"></a>Handler、MessageQueue 和 Looper 之间的关系</h3><p>最后再总结一下，<code>Handler</code>的创建是依赖于<code>Looper</code>的。而主线程是默认创建了一个<code>Looper</code>对象的。每一个<code>Looper</code>会关联一个线程（<code>ThreadLocal</code>中封装了<code>Looper</code>)。每一个<code>Looper</code>中又会封装一个消息队列。<br>这样一来，<code>Handler</code>，<code>Looper</code>，<code>MessageQueue</code>，<code>Thread</code>四个角色就关联了起来。<br><code>Handler</code>在主线程中创建，是因为要和主线程的消息队列关联起来，那样<code>Handler#handleMessage</code>方法才会在主线程中执行，那么这样在更新UI就是线程安全的了。</p><h2 id="Handler-发送消息过程"><a href="#Handler-发送消息过程" class="headerlink" title="Handler  发送消息过程"></a>Handler  发送消息过程</h2><p>回想开头我们基础用法里提到 <code>Handler</code>一般是通过一下2个方法发送的</p><blockquote><p>handler.sendMessage(message);<br>handler.post(runnable);</p></blockquote><h3 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h3><p>我们先从第一个开始分析 <strong>handler.sendMessage(message)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendMessage</code>会调用<code>sendMessageDelayed</code>方法并将<code>message</code>对象传进去，第二个参数是延时时间，使用<code>sendMessage</code>方法时默认为0的,最后都会调用<code>sendMessageAtTime</code>。<br>上面分析了，在创建<code>Looper</code>对象的时候，会创建一个<code>MessageQueue</code>，所以只要<code>Looper</code>是正常创建的话，消息队列是不为空的。<br>那么到最后一行的<code>enqueueMessage</code>方法，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>handler</code>本身赋值给<code>msg.target</code></p><p><code>msg.setAsynchronous(true</code>设置message是否是异步的，这是message的一个属性。同一个Thread只有一个Looper，一个MessageQueue，但是可以有很多个Handler，如果<code>Handler</code>初始化的时候async参数是true，那么这个<code>Handler</code>所post的所有的message都会带上异步的属性。可以通过<code>MessageQueue`</code>的postSyncBarrier(long when)`来向队列中插入一个同步分割栏，同步分割栏是一个特殊的message，这种message的target=null，就像一个卡子，当他被插入时，会卡住在这之后的所有的同步的message，只会摘取异步的message。当然也可以通过MessageQueue的removeSyncBarrier(int token)来移除这个同步分割栏，token就是postSyncBarrier方法的返回值。但是目前这两个方法都被hide了。所以大家一般用到的都只是普通的Message。(注:摘自<a href="https://juejin.im/post/5c9b198ff265da612f1baa9e" target="_blank" rel="noopener">从源码去理解Handler</a>)</p><p> 然后最终调用<code>queue.enqueueMessage</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//消息是否正在使用</span></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">//很明显enqueueMessage需要同步,因为存在多个线程往一个Loop线程的MessageQueue中插入消息的场景。 </span></span><br><span class="line">                <span class="comment">//这里其实是将Message根据延时插入到特定的地方，先看下关键点1，mMessages其实代表消息队列的头部，如果mMessages为空，说明还没有消息，如果当前插入的消息不需要延时，或者说延时比mMessages头消息的延时要小，那么当前要插入的消息就需要放在头部</span></span><br><span class="line">                <span class="comment">//至于是否需要唤醒队列，则需要根据当前的Loop线程的状态来判断，后面讲Loop线程的时候再回过头说；</span></span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//再来看下关键点2，这个时候需要将消息插入到队列中间，其实就是找到第一个Delay事件小于当前Message的非空Message，并插入到它的前面，往队列中插入消息时，如果Loop线程在睡眠，是不应该唤醒的，异步消息的处理会更加特殊一些，先不讨论。</span></span><br><span class="line">                <span class="comment">//最后看关键点3，如果需要唤醒Loop线程，通过nativeWake唤醒，以上，就是普通消息的插入。</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Messagequeue</code>中有一个对象<code>mMessage</code>用于指向当前传进的<code>msg</code>，即最新的消息。而刚才的<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>方法，第二个参数指定了时间，然后在这里按照这个<code>uptimeMillis</code>来进行消息的排序，这样每一个消息都是按照时间的排序关联了起来，排在前面的消息指向了排在后面的消息。</p><p>以上是进入消息队列的分析，<code>Handler</code>调用<code>sendMessage</code>方法的最终将<code>message</code>对象传进<code>Messagequeue</code>。</p><h3 id="取出消息"><a href="#取出消息" class="headerlink" title="取出消息"></a>取出消息</h3><p>那么消息是怎么从消息队列出来的呢？<br>这时我们要回看<code>ActiviryThread</code>的main方法，去寻找点线索。源码在上面已贴出。<br>发现了倒数第二行的<code>Looper.loop()</code>，简单理解就是消息执行循环操作。<br><strong>android.os.Looper#loop</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保MessageQueue准备好</span></span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//for 无限循环，阻塞于消息队列的 next() 方法；</span></span><br><span class="line">            <span class="comment">//不断从队列中读取消息并移除，如果队列为空，阻塞等待</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block </span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;<span class="comment">//跳出循环，looper退出就是利用了这点</span></span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//清理，回收到缓存池</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loop方法是个死循环，但是为什么不会卡死主线程呢，参考</p><p><a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a> </p><p><a href="https://juejin.im/post/5c5694b951882562e5441e71" target="_blank" rel="noopener">Handler后传篇一: 为什么Looper中的Loop()方法不能导致主线程卡死?</a></p><p><a href="https://pqpo.me/2017/05/03/learn-messagequeue/" target="_blank" rel="noopener">深入理解 MessageQueue</a></p><p>loop内容有点复杂，借用一张图来看下</p><p><img src="/posts/20470e2e/loop.png" alt="Looper#loop"></p><p>当我们调用 <code>Looper#loop()</code> 方法之后整个 <code>Looper</code> 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 <code>MessageQueue#next()`</code> 方法来获取下一个消息的时候，会调用 nativePollOnce()<code>方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从</code>MessageQueuue<code>中取得一个消息之后给</code>Looper <code>进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的</code>Looper <code>的作用就是通过阻塞消息队列获取消息的过程阻塞</code> Looper`。</p><p>再看下关键的<code>Message msg = queue.next()</code>  深入分析参见<a href="https://juejin.im/post/59083d7fda2f60005d14efdb#heading-1" target="_blank" rel="noopener">MessageQueue中Message消息的执行</a>以及 <a href="https://juejin.im/post/5bdec872e51d4551ee2761cb#heading-10" target="_blank" rel="noopener">MessageQueue 的消息管理</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否需要阻塞等待，第一次一定不阻塞</span></span><br><span class="line">            <span class="comment">// 调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。</span></span><br><span class="line">            <span class="comment">// 在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。</span></span><br><span class="line">            <span class="comment">// 如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//互斥同步</span></span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="comment">//是否存在barier</span></span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="comment">//存在同步分隔栏，找到后面异步属性的msg</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一个消息是否需要阻塞等待，并计算出阻塞等待时间</span></span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    <span class="comment">//需要无限等待</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="comment">//没有可以即刻执行的Message，查看是否存在需要处理的IdleHandler，如果不存在，则返回，阻塞等待，如果存在则执行IdleHandler</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="comment">// 如果目前没有消息，已经处在空闲状态，则执行 idler.queueIdle</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">            <span class="comment">//处理完IdleHandler ，需要重新判断Message队列 nextPollTimeoutMillis赋值为0</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面分析过<code>msg.target</code>就是<code>handler</code>，所以<code>loop</code>循环的时候又把消息取出扔给<code>handler#dispatchMessage</code>方法了，我们来看下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于这种方法没有传<code>callback</code>，所以最终调用<code>handleMessage</code>，我们来看下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，相信大家应该很熟悉了，这就是我们重写的方法。</p><p>我们再看看另一个发送消息的方法 <strong>handler.post(runnable)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收一个实现了<code>Runable</code>接口的对象，然后将其传进<code>getPostMessage()</code>方法。跟进<code>getPostMessage()</code>方法看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实就是将<code>Runable</code>包装成<code>message的callback</code>嘛。<br>所以，如果我们使用<code>post</code>方法发送消息，在执行<code>dispatchMessage</code>的时候,<code>callback</code>字段是不为空的，那么就会执行<code>handleCallback()</code>方法，而不是执行<code>handleMessage</code>方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空闲处理者的添加与处理"><a href="#空闲处理者的添加与处理" class="headerlink" title="空闲处理者的添加与处理"></a>空闲处理者的添加与处理</h3><h4 id="什么是空闲处理者"><a href="#什么是空闲处理者" class="headerlink" title="什么是空闲处理者"></a>什么是空闲处理者</h4><p>通过上面的分析可知 <code>MessageQueue</code>通过 <code>next</code>方法通过死循环获取下一个要处理的 Message, 若当前时刻不存在要处理的消息, 下次循环会进行睡眠操作</p><ul><li><strong>在没有取到可执行消息 —&gt; 下次 for 循环进行睡眠</strong> 之间的时间间隔, 称之为<strong>空闲时间</strong></li><li><strong>在空闲时间处理事务的对象, 称之为空闲处理者</strong></li></ul><h4 id="空闲处理者的添加"><a href="#空闲处理者的添加" class="headerlink" title="空闲处理者的添加"></a>空闲处理者的添加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">         * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">         * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">         * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">         * after the current time.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't add a null IdleHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可以得到以下的信息</p><ul><li>空闲处理者使用 IdleHandler 接口描述</li><li>空闲处理者通过 MessageQueue.addIdleHandler() 添加</li><li>空闲处理者使用 MessageQueue.mIdleHandlers 维护</li></ul><h4 id="空闲消息的处理"><a href="#空闲消息的处理" class="headerlink" title="空闲消息的处理"></a>空闲消息的处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲消息集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">    <span class="comment">// 空闲消息处理者的数组</span></span><br><span class="line">    <span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...... </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 省略获取 msg 的代码</span></span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 1. 从空闲消息集合 mIdleHandlers 中获取 空闲处理者 数量</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2 若无空闲处理者, 则进行下一次 for 循环</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 3. 将空闲消息处理者集合转为数组</span></span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 4. 处理空闲消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];<span class="comment">// 获取第 i 给位置的空闲处理者</span></span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// 置空</span></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;        </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4.1 处理空闲消息</span></span><br><span class="line">                    keep = idler.queueIdle(); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// 4.2 走到这里表示它是一次性的处理者, 从 mIdleHandlers 移除</span></span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到 MessageQueue.next 在获取不到 msg 时, 会进行一些空闲消息的处理</p><ul><li>从空闲消息集合 mIdleHandlers 中获取 空闲处理者 数量</li><li>若无空闲处理者, 则进行下一次 for 循环</li><li>若存在空闲处理者, 则空闲消息处理者集合转为数组 mPendingIdleHandlers</li><li>for 循环处理空闲消息 <ul><li>调用 IdleHandler.queueIdle 处理空闲消息 <ul><li>返回 true, 下次再 MessageQueue.next 获取不到 msg 的空闲时间会继续处理</li><li>返回 false 表示它是一次性的处理者, 从 mIdleHandlers 移除</li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们发现不管是使用<code>post</code>方法还是<code>sendMessage</code>方法来发送消息，最终都会调用<code>sendMessageDelayed</code>方法。<code>handler</code>将消息追加到消息队列中的过程都是一样的，然后<code>Looper</code>不断的从<code>MessageQueue</code>中取出消息，并由<code>handler</code>去分发消息，处理消息，这样就构成了完善的Android消息机制体系。</p><h2 id="Handler扩展"><a href="#Handler扩展" class="headerlink" title="Handler扩展"></a>Handler扩展</h2><p><code>Handler</code> 虽然简单易用，但是要用好它还是需要注意一点。</p><p>由于<code>Handler</code> 的特性，它在 Android 里的应用非常广泛，比如： <a href="https://lingdage.com/posts/96014b68.html">AsyncTask</a>、<a href="https://lingdage.com/posts/b4da2c1c.html">HandlerThread</a>、<a href="https://lingdage.com/posts/ccf7cf3d.html">Messenger</a>、IdleHandler 和 <a href="https://lingdage.com/posts/e4e64342.html">IntentService</a> 等等。</p><h3 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h3><p><code>Handler</code> 允许我们发送<strong>延时消息</strong>，如果在延时期间用户关闭了 <code>Activity</code>，那么该 <code>Activity</code>会泄露。</p><p>这个泄露是因为<code>Message</code>会持有<code>Handler</code>，而又因为 <strong>Java 的特性，内部类会持有外部类</strong>，使得 <code>Activity</code> 会被 <code>Handler</code>持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：<strong>将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息</strong>。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;HandlerActivity&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        HandlerActivity activity = ref.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且再在 <code>Activity.onDestroy()</code> 前移除消息，加一层保障：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  safeHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样双重保障，就能完全避免内存泄露了。</p><p><strong>注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。</strong></p><h3 id="Handler-里的-Callback-用处"><a href="#Handler-里的-Callback-用处" class="headerlink" title="Handler 里的 Callback 用处"></a>Handler 里的 Callback 用处</h3><p>在 <code>Handler</code> 的构造方法中有几个 要求传入 <code>Callback</code> ，那它是什么，又能做什么呢？</p><p>来看看 <code>Handler.dispatchMessage(msg)</code>  方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里的 callback 是 Runnable</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Handler.Callback</code> 有<strong>优先处理消息的权利</strong> ，当一条消息被 <code>Callback</code> 处理<strong>并拦截（返回 true）</strong>，那么 <code>Handler</code> 的 <code>handleMessage(msg)</code> 方法就不会被调用了；如果 <code>Callback</code>处理了消息，但是并没有拦截，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p>这个就很有意思了，这有什么作用呢？</p><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><p>场景：Hook <code>ActivityThread.mH</code> ， 在 <code>ActivityThread</code> 中有个成员变量 <code>mH</code> ，它是个 <code>Handler</code>，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h3 id="创建-Message-实例的最佳方式"><a href="#创建-Message-实例的最佳方式" class="headerlink" title="创建 Message 实例的最佳方式"></a>创建 Message 实例的最佳方式</h3><p>由于 <code>Handler</code> 极为常用，所以为了节省开销，Android 给 <code>Message</code> 设计了回收机制，所以我们在使用的时候尽量复用 <code>Message</code> ，减少内存消耗。</p><p>方法有二：</p><ol><li>通过 <code>Message</code> 的静态方法 <code>Message.obtain();</code>   获取；</li><li>通过 <code>Handler</code> 的公有方法 <code>handler.obtainMessage();</code> 。</li></ol><h3 id="妙用-Looper-机制"><a href="#妙用-Looper-机制" class="headerlink" title="妙用 Looper 机制"></a>妙用 Looper 机制</h3><p>我们可以利用 <code>Looper</code> 的机制来帮助我们做一些事情：</p><ul><li><p>将 <code>Runnable</code> post 到主线程执行</p><blockquote><p> Activity.runOnUiThread(Runnable)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>View.post(Runnable)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//直接通过handler发送Post消息</span></span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先加入队列,等attachInfo被赋值时,会通过handler发送消息.</span></span><br><span class="line">  getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>Looper</code> 判断当前线程是否是主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(@NonNull Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        HANDLER.post(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Looper-和-Handler-一定要处于一个线程吗？子线程中可以用-MainLooper-去创建-Handler吗？"><a href="#Looper-和-Handler-一定要处于一个线程吗？子线程中可以用-MainLooper-去创建-Handler吗？" class="headerlink" title="Looper 和 Handler 一定要处于一个线程吗？子线程中可以用 MainLooper 去创建 Handler吗？"></a>Looper 和 Handler 一定要处于一个线程吗？子线程中可以用 MainLooper 去创建 Handler吗？</h3><p><code>Looper</code> 和<code>Handler</code> 不需要再一个线程中，默认的情况下会从<code>ThreadLocal</code>中取当前线程对应的 <code>Looper</code>，但我们可以通过显式地指定一个 <code>Looper</code>的方式来创建<code>Handler</code>. 比如，当我们想要在子线程中发送消息到主线程中，那么我们可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure><h3 id="子线程中进行UI操作的方法"><a href="#子线程中进行UI操作的方法" class="headerlink" title="子线程中进行UI操作的方法"></a>子线程中进行UI操作的方法</h3><ul><li><p>Handler的post()方法</p></li><li><p>View的post()方法</p></li><li><p>Activity的runOnUiThread()方法</p></li></ul><h3 id="如何理解Handler的异步"><a href="#如何理解Handler的异步" class="headerlink" title="如何理解Handler的异步"></a>如何理解Handler的异步</h3><p>参见<a href="https://juejin.im/post/5c592dc9f265da2de04a91ec" target="_blank" rel="noopener">Handler后传篇二: 该如何理解Handler的”异步”？</a></p><h3 id="MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？-MessageQueue-next-方法内部的原理？"><a href="#MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？-MessageQueue-next-方法内部的原理？" class="headerlink" title="MessageQueue.next() 会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？  MessageQueue.next() 方法内部的原理？"></a>MessageQueue.next() 会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？  MessageQueue.next() 方法内部的原理？</h3><p>调用 <code>MessageQueue.next()</code> 方法的时候会调用 Native 层的 <code>nativePollOnce()</code> 方法进行精准时间的阻塞。在 Native 层，将进入 <code>pullInner()</code> 方法，使用 <code>epoll_wait</code> 阻塞等待以读取管道的通知。如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。</p><p>当我们加入消息的时候，会调用 <code>MessageQueue.enqueueMessage()</code> 方法，添加完 Message 后，如果消息队列被阻塞，则会调用 Native 层的 <code>nativeWake()</code> 方法去唤醒。它通过向管道中写入一个消息，结束上述阻塞，触发上面提到的 <code>nativePollOnce()</code> 方法返回，好让加入的 Message 得到分发处理。</p><p><code>MessageQueue.enqueueMessage()</code> 使用 synchronized 代码块去进行同步。</p><p>资料：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.liangzl.com%2Fget-article-detail-14435.html" target="_blank" rel="noopener">Android 中的 Handler 的 Native 层研究</a></p><h3 id="Looper-的退出方法？"><a href="#Looper-的退出方法？" class="headerlink" title="Looper 的退出方法？"></a>Looper 的退出方法？</h3><blockquote><p>quit() 和 quitSafely() 有什么区别<br>子线程中创建了 Looper，在使用完毕后，终止消息循环的方法？<br>quit() 和 quitSafely() 的本质是什么？</p></blockquote><p><code>quit()</code> 和 <code>quitSafely()</code>的本质就是让消息队列的 <code>next()</code> 返回 <code>null</code>，以此来退出<code>Looper.loop()</code>。<br><code>quit()</code> 调用后直接终止 <code>Looper</code>，不在处理任何 <code>Message</code>，所有尝试把<code>Message</code> 放进消息队列的操作都会失败，比如 <code>Handler.sendMessage()</code> 会返回 false，但是存在不安全性，因为有可能有<code>Message</code> 还在消息队列中没来的及处理就终止<code>Looper</code>了。<br><code>quitSafely()</code> 调用后会在所有消息都处理后再终止 <code>Looper</code>，所有尝试把 <code>Message</code>放进消息队列的操作也都会失败。</p><h3 id="知识点汇总"><a href="#知识点汇总" class="headerlink" title="知识点汇总"></a>知识点汇总</h3><p>由前文可得出一些知识点，汇总一下，方便记忆。</p><ol><li><code>Handler</code> 的背后有 <code>Looper</code>、<code>MessageQueue</code> 支撑，<code>Looper</code> 负责消息分发，<code>MessageQueue</code> 负责消息管理</li><li>在创建 <code>Handler</code> 之前一定需要先创建<code>Looper</code></li><li><code>Looper</code> 有退出的功能，但是主线程的 <code>Looper</code> 不允许退出</li><li>异步线程的<code>Looper</code> 需要自己调用 <code>Looper.myLooper().quit();</code>  退出</li><li><code>Runnable</code>被封装进了 <code>Message</code>，可以说是一个特殊的 <code>Message</code></li><li><code>Handler.handleMessage()</code> 所在的线程是 <code>Looper.loop()</code> 方法被调用的线程，也可以说成<code>Looper</code>所在的线程，并不是创建 <code>Handler</code> 的线程</li><li>使用内部类的方式使用<code>Handler</code>可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/xyh269/article/details/52554712" target="_blank" rel="noopener">Android中的消息机制</a><br><a href="https://juejin.im/post/5c4fb8e9e51d4502723b1f68#heading-3" target="_blank" rel="noopener">Android点将台：烽火狼烟[-Handler-]</a><br><a href="https://juejin.im/post/5c74b64a6fb9a049be5e22fc" target="_blank" rel="noopener">Handler 都没搞懂，拿什么去跳槽啊？</a><br><a href="https://juejin.im/post/5c6a9a106fb9a04a0c2f0093" target="_blank" rel="noopener">Android 高级面试-1：Handler 相关</a><a href="https://juejin.im/post/5bdec872e51d4551ee2761cb" target="_blank" rel="noopener">Android 消息机制：Handler、MessageQueue 和 Looper</a><br><a href="https://juejin.im/post/5c5272196fb9a04a0d5745d2" target="_blank" rel="noopener">Android 消息机制详解(Android P)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码，来分析Handler的用法&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;framework/base/core/java/andorid/os/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - Handler.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - Looper.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - Message.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - MessageQueue.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Handler作用&quot;&gt;&lt;a href=&quot;#Handler作用&quot; class=&quot;headerlink&quot; title=&quot;Handler作用&quot;&gt;&lt;/a&gt;Handler作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;任务调度：即通过 &lt;code&gt;post()&lt;/code&gt; 和 &lt;code&gt;send()&lt;/code&gt; 等方法来指定某个任务在某个时间执行&lt;/li&gt;
&lt;li&gt;线程切换：执行耗时的操作，比如网络请求，IO操作等，需要在子线程中运行，不然会阻塞主线程。&lt;br&gt;而执行完网络请求等耗时操作后通常需要更新UI，如果在子线程中更新UI，那么程序会崩溃。因为Android的UI是线程不安全的。 在Android中使用Rxjava，还要配合RxAndroid来使用，RxAndroid 内部就使用 Handler 来实现线程切换。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Handler" scheme="https://lingdage.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>AOSP 源码导入 Android Studio</title>
    <link href="https://lingdage.com/posts/fa96240a.html"/>
    <id>https://lingdage.com/posts/fa96240a.html</id>
    <published>2019-03-02T06:12:53.000Z</published>
    <updated>2019-04-01T08:56:37.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇文章<a href="">AOSP 源码环境搭建</a>(<a href="https://lingdage.com/posts/8c9d1837.html)我们已经将AOSP整个源码down到了我们硬盘。接下来我们就要Read">https://lingdage.com/posts/8c9d1837.html)我们已经将AOSP整个源码down到了我们硬盘。接下来我们就要Read</a> The Fucking Source Code !</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>原理</p><p>idegen专门为IDE环境调试源码而设计的工具，所以我们要将工程导入AS需要下面三个步骤</p><ol><li>获取到idegen.jar</li><li>获取idegen.sh 执行生成android.ipr/android.iml</li><li>Android sutdio 选择android.ipr导入</li></ol><p>不想编译整个AOSP源码的，对于idegen.jar以及idegen.sh 获取可以参考<a href="https://lingdage.com/posts/ca9841f5.html">AOSP frameworks 源码环境搭建</a></p><p>下面讲下完整版的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ～/aosp //具体的源码根目录</span><br><span class="line"></span><br><span class="line">//用于初始化环境变量</span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh  </span><br><span class="line"></span><br><span class="line">//生成文件out/host/linux-x86/framework/idegen.jar</span><br><span class="line">mmm development/tools/idegen/  </span><br><span class="line"></span><br><span class="line">//源码根目录生成文件android.ipr(工程相关设置), android.iml(模块相关配置)</span><br><span class="line">./development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure><blockquote><p>m/mm/mmm/make 相关参考<a href="https://blog.csdn.net/Luoshengyang/article/details/19023609" target="_blank" rel="noopener">Android源代码编译命令m/mm/mmm/make分析</a></p></blockquote><h2 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h2><p>打开Android Studio， 点击<code>File</code> -&gt; <code>Open</code>，选中前面生成的<strong>android.ipr</strong>文件即可， 该过程较耗时</p><h3 id="加载前配置文件提速"><a href="#加载前配置文件提速" class="headerlink" title="加载前配置文件提速"></a>加载前配置文件提速</h3><p>打开<code>android.iml</code>文件，有大量excludeFolder，是指不会导入到AS的模块，默认除了以下14个文件夹之外的所有文件都会导致到AS工程， 这显然还会非常庞大的，那么我们可以有选择的导入 如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/.repo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/external/bluetooth"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/frameworks/base/docs"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/out/host"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/prebuilt"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="加载后提速"><a href="#加载后提速" class="headerlink" title="加载后提速"></a>加载后提速</h3><p>如果已经把全部项目导入到Android Studio，又想删除怎么办，其实有一个简单的方法就是进入目录<code>Project Structure</code> -&gt; <code>Modules</code>， 可快速去除某些模块, 其中红色代码Exclueded选项(即代表已删除的目录), 如下图: <img src="/posts/fa96240a/as_excluded_modules.png" alt="as_modules"></p><h3 id="配置源码正确跳转"><a href="#配置源码正确跳转" class="headerlink" title="配置源码正确跳转"></a>配置源码正确跳转</h3><p>这里的配置JDK/SDK，是用于解决在分析和调试源码的过程，能正确地跳转到目标源码，而非SDK中的代码。 点击<code>File</code>菜单下的<code>Project Structure</code>.</p><h4 id="新建JDK-No-Libraries"><a href="#新建JDK-No-Libraries" class="headerlink" title="新建JDK(No Libraries)"></a>新建JDK(No Libraries)</h4><ol><li>新建JDK(No Libraries),路径可选择之前的一样的</li><li>删除JDK(No Libraries)中的ClassPath和SourcePath<br><img src="/posts/fa96240a/as_jdk_none.png" alt="as_jdk_none"></li></ol><h4 id="配置SDK"><a href="#配置SDK" class="headerlink" title="配置SDK"></a>配置SDK</h4><p>Project Structure -&gt; SDKs, 选中<code>Android API 28 Platform</code>, 然后选择其Java SDK为前面新建的<code>JDK(No Libraries)</code></p><p><img src="/posts/fa96240a/sdk_none.png" alt="sdk_none"></p><h4 id="选择SDK"><a href="#选择SDK" class="headerlink" title="选择SDK"></a>选择SDK</h4><p><img src="/posts/fa96240a/project_sdk.png" alt="project_sdk"></p><h4 id="建立依赖"><a href="#建立依赖" class="headerlink" title="建立依赖"></a>建立依赖</h4><p>Project Structure -&gt; Modules -&gt; android -&gt; Dependencies: 先删除Android API 25 Platform之外的所有依赖, 然后点击下图绿色的<code>+</code>号来选择<code>Jars or directories</code>，将frameworks添加进来, 也可添加其他所关注的源码；</p><p><img src="/posts/fa96240a/project_dependencies.png" alt="project_dependencies"></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>前面已搭建好了Android的源码调试环境, 接下来可以在线调试源码. 首先,需要一台具有debug版的手机, 打开开发者选项, 允许USB调试.</p><p>frameworks各大核心服务运行在system_server进程, 在调试器上名字为system_process,通过attach到我们要调试的目标进程, 同理, 要调试其他app进程也是这个方式.    </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://gityuan.com/2016/08/13/android-os-env" target="_blank" rel="noopener">AndroidStudio源码开发环境搭建</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一篇文章&lt;a href=&quot;&quot;&gt;AOSP 源码环境搭建&lt;/a&gt;(&lt;a href=&quot;https://lingdage.com/posts/8c9d1837.html)我们已经将AOSP整个源码down到了我们硬盘。接下来我们就要Read&quot;&gt;https://lingdage.com/posts/8c9d1837.html)我们已经将AOSP整个源码down到了我们硬盘。接下来我们就要Read&lt;/a&gt; The Fucking Source Code !&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="AOSP" scheme="https://lingdage.com/tags/AOSP/"/>
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>AOSP 源码环境搭建</title>
    <link href="https://lingdage.com/posts/8c9d1837.html"/>
    <id>https://lingdage.com/posts/8c9d1837.html</id>
    <published>2019-03-01T14:45:54.000Z</published>
    <updated>2019-04-01T06:16:31.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="配置Android-Studio"><a href="#配置Android-Studio" class="headerlink" title="配置Android Studio"></a>配置Android Studio</h3><p><strong>调整内存大小: </strong> Android Studio需要大量的内存来加载Android源码，所以经常会遇到内存不足的问题, 需要加大内存. 点击<code>Help</code>-&gt; <code>Edit Custom VM Options</code>, 比如 “-Xms4096m -Xmx4096m”</p><p>更多资料:</p><ul><li><a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio官网</a></li><li><a href="https://developer.android.com/studio/intro/studio-config.html#low_memory" target="_blank" rel="noopener">配置 Android Studio</a></li></ul><a id="more"></a><h3 id="配置repo"><a href="#配置repo" class="headerlink" title="配置repo"></a>配置repo</h3><p>下载repo工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p><strong>或者使用tuna的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/" target="_blank" rel="noopener">git-repo镜像</a></strong></p><p>然后建立一个工作目录（名字任意）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/aosp //创建目录，可自己定义</span><br><span class="line">cd ~/aosp</span><br></pre></td></tr></table></figure><p>初始化仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest</span><br></pre></td></tr></table></figure><p><strong>如果提示无法连接到 gerrit.googlesource.com，请参照git-repo的帮助页面的更新一节。</strong></p><p>如果需要某个特定的 Android 版本（<a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="noopener">Android 版本列表</a>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r1</span><br></pre></td></tr></table></figure><p>同步源码树（以后只需执行这条命令来同步）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">同步所有可用的project</span></span><br><span class="line">repo sync</span><br><span class="line"><span class="meta">#</span><span class="bash">只同步当前初始化的分支</span></span><br><span class="line">repo sync -c -j4</span><br><span class="line"><span class="meta">#</span><span class="bash">只同步frameworks/base库</span></span><br><span class="line">repo sync platform/frameworks/base -c -j4</span><br></pre></td></tr></table></figure><h4 id="repo-sync-失败"><a href="#repo-sync-失败" class="headerlink" title="repo sync 失败"></a>repo sync 失败</h4><p>虽然是国内镜像，但同步依然会出错停止，所以我们需要创建一个自动下载脚本，确保出错了之后会自动执行repo sync，在aosp文件夹下创建一个脚本down.sh，(自己在aosp文件夹创建down.sh文件，然后用编辑器打开，copy代码进去保存就行)代码如下，这个<code>-j 8</code>可以自己改，你的CPU总线程数*2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">    repo sync -j 8  </span><br><span class="line">    <span class="keyword">while</span> [ $? = 1 ]; <span class="keyword">do</span>  </span><br><span class="line">            <span class="built_in">echo</span> “======sync failed, re-sync again======”  </span><br><span class="line">            sleep 3  </span><br><span class="line">            repo sync  -j 8 </span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>如果只需要同步部分project</p><p>把上面的的两行<code>repo sync -j 8</code>替换成下面的语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync platform/development platform/frameworks/base -j 8</span><br></pre></td></tr></table></figure><p><code>repo sync</code>命令后面可以指定要同步的project，上面这行命令就是指定了2个project<br> 打开<code>.repo/manifest.xml</code>,可以看到project的名字和路径。</p><p>然后命令行执行，就开始下载啦。（注意：Terminal要在aosp文件夹下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x down.sh</span><br><span class="line">./down.sh</span><br></pre></td></tr></table></figure><h4 id="替换已有的-AOSP-源代码的-remote"><a href="#替换已有的-AOSP-源代码的-remote" class="headerlink" title="替换已有的 AOSP 源代码的 remote"></a>替换已有的 AOSP 源代码的 remote</h4><p>如果你之前已经通过某种途径获得了 AOSP 的源码(或者你只是 init 这一步完成后)， 你希望以后通过 TUNA 同步 AOSP 部分的代码，只需要将<code>.repo/manifest.xml</code> 把其中的 aosp 这个 remote 的 fetch 从 <code>https://android.googlesource.com</code> 改为 <code>https://aosp.tuna.tsinghua.edu.cn/</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"aosp"</span></span></span><br><span class="line"><span class="tag"><span class="attr">-</span>           <span class="attr">fetch</span>=<span class="string">"https://android.googlesource.com"</span></span></span><br><span class="line"><span class="tag">+           <span class="attr">fetch</span>=<span class="string">"https://aosp.tuna.tsinghua.edu.cn"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">review</span>=<span class="string">"android-review.googlesource.com"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"github"</span></span></span><br></pre></td></tr></table></figure><p>同时，修改 <code>.repo/manifests.git/config</code>，将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = https://android.googlesource.com/platform/manifest</span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = https://aosp.tuna.tsinghua.edu.cn/platform/manifest</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们分析源码其实是不需要全部代码的，因为AOSP不仅包括系统源码，还有些工具代码，如aapt，adb等，这些我们根本不需要，而且即便是系统源码，也不是所有我们都需要看，如果真的全部看，你这辈子都看不完.</p><p>如果只想下载单个目录，比如我们要下载platform/frameworks/base/目录下的代码，我们可以git clone <a href="https://android.googlesource.com/platform/frameworks/base" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base</a> ，不过这个还是会遇到翻墙的问题，当然我们也可以用镜像。</p><p>镜像地址 <a href="https://aosp.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://aosp.tuna.tsinghua.edu.cn/</a> ，比如我们要下载platform/frameworks/base/目录，就用git clone <a href="https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base" target="_blank" rel="noopener">https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base</a> ，如果你带宽够的话，一般几分钟就可以下载好你想要的单个源码了。</p><p>如果你想下载单个文件，或者搜索文件名及代码，可以访问 <a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a> ，这里有部分Android的源码</p><p>具体可以参考<a href="https://lingdage.com/posts/ca9841f5.html">how to read android framework source code in android studio</a></p><h2 id="Android-架构简介"><a href="#Android-架构简介" class="headerlink" title="Android 架构简介"></a>Android 架构简介</h2><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>Android系统架构分为五层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。</p><p><img src="/posts/8c9d1837/android-stack_2x.png" alt="android-stack"></p><p><img src="/posts/8c9d1837/android-asop-root.png" alt="android asop root"></p><table><thead><tr><th style="text-align:center">Android源码根目录</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">abi</td><td style="text-align:center">abi相关代码，abi:application binary interface，应用程序二进制接口</td></tr><tr><td style="text-align:center">art</td><td style="text-align:center">全新的运行环境，需要和Dalvik VM区分开来</td></tr><tr><td style="text-align:center">bionic</td><td style="text-align:center">系统C库</td></tr><tr><td style="text-align:center">bootable</td><td style="text-align:center">启动引导相关代码</td></tr><tr><td style="text-align:center">build</td><td style="text-align:center">存放系统编译规则及generic等基础开发配置包</td></tr><tr><td style="text-align:center">cts</td><td style="text-align:center">Android兼容性测试套件标准</td></tr><tr><td style="text-align:center">dalvik</td><td style="text-align:center">dalvik虚拟机</td></tr><tr><td style="text-align:center">developers</td><td style="text-align:center">开发者目录</td></tr><tr><td style="text-align:center">development</td><td style="text-align:center">应用程序开发相关</td></tr><tr><td style="text-align:center">device</td><td style="text-align:center">设备相关配置</td></tr><tr><td style="text-align:center">docs</td><td style="text-align:center">参考文档目录</td></tr><tr><td style="text-align:center">external</td><td style="text-align:center">Android使用的一些开源的模组</td></tr><tr><td style="text-align:center">frameworks</td><td style="text-align:center">应用程序框架，Android系统核心部分，由Java和C++编写</td></tr><tr><td style="text-align:center">hardware</td><td style="text-align:center">主要是硬件适配层HAL代码</td></tr><tr><td style="text-align:center">libcore</td><td style="text-align:center">核心库相关文件</td></tr><tr><td style="text-align:center">libnativehelper</td><td style="text-align:center">是Support functions for Android’s class libraries的缩写，表示动态库，是实现的JNI库的基础</td></tr><tr><td style="text-align:center">ndk</td><td style="text-align:center">Android NDK ( Android Native Development Kit )是一系列的开发工具，允许程序开发人员在Android应用程序中嵌入C/C++语言编写的非托管代码</td></tr><tr><td style="text-align:center">out</td><td style="text-align:center">编译完成后代码输出在此目录</td></tr><tr><td style="text-align:center">packages</td><td style="text-align:center">应用程序包</td></tr><tr><td style="text-align:center">pdk</td><td style="text-align:center">Plug Development Kit 的缩写，本地开发套件</td></tr><tr><td style="text-align:center">platform_testing</td><td style="text-align:center">平台测试</td></tr><tr><td style="text-align:center">prebuilts</td><td style="text-align:center">x86和arm架构下预编译的一些资源</td></tr><tr><td style="text-align:center">sdk</td><td style="text-align:center">sdk和模拟器</td></tr><tr><td style="text-align:center">system</td><td style="text-align:center">文件系统和应用及组件，是用C语言实现的</td></tr><tr><td style="text-align:center">toolchain</td><td style="text-align:center">工具链文件</td></tr><tr><td style="text-align:center">tools</td><td style="text-align:center">工具文件</td></tr><tr><td style="text-align:center">Makefile</td><td style="text-align:center">全局Makefile文件，用来定义编译规则 ( 通常文件后缀为.mk )</td></tr></tbody></table><h4 id="应用层部分"><a href="#应用层部分" class="headerlink" title="应用层部分"></a>应用层部分</h4><p>应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都是在应用层。源码根目录中的<em>packages</em>目录对应着系统应用层。</p><table><thead><tr><th style="text-align:center">packages目录</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">apps</td><td style="text-align:center">核心应用程序</td></tr><tr><td style="text-align:center">experimental</td><td style="text-align:center">第三方应用程序</td></tr><tr><td style="text-align:center">inputmethods</td><td style="text-align:center">输入法目录</td></tr><tr><td style="text-align:center">providers</td><td style="text-align:center">内容提供者目录</td></tr><tr><td style="text-align:center">screensavers</td><td style="text-align:center">屏幕保护</td></tr><tr><td style="text-align:center">services</td><td style="text-align:center">通信服务</td></tr><tr><td style="text-align:center">wallpapers</td><td style="text-align:center">墙纸</td></tr></tbody></table><h4 id="应用框架层部分"><a href="#应用框架层部分" class="headerlink" title="应用框架层部分"></a>应用框架层部分</h4><p>应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与C/C++程序库以及硬件抽象层等进行衔接。 应用框架层的主要实现代码在/frameworks/base和/frameworks/av目录下</p><p>其中系统服务部分在frameworks/base/services中，在frameworks/av/services里存放着音频和照相机的服务。</p><p>/frameworks/base目录结构如下</p><table><thead><tr><th style="text-align:center">/frameworks/base目录</th><th style="text-align:center">描述</th><th style="text-align:center">/frameworks/base目录</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">api</td><td style="text-align:center">定义API</td><td style="text-align:center">cmds</td><td style="text-align:center">重要命令：am、app_proce等</td></tr><tr><td style="text-align:center">core</td><td style="text-align:center">核心库</td><td style="text-align:center">data</td><td style="text-align:center">字体和声音等数据文件</td></tr><tr><td style="text-align:center">docs</td><td style="text-align:center">文档</td><td style="text-align:center">graphics</td><td style="text-align:center">图形图像相关</td></tr><tr><td style="text-align:center">include</td><td style="text-align:center">头文件</td><td style="text-align:center">keystore</td><td style="text-align:center">和数据签名证书相关</td></tr><tr><td style="text-align:center">libs</td><td style="text-align:center">库</td><td style="text-align:center">location</td><td style="text-align:center">地理位置相关库</td></tr><tr><td style="text-align:center">media</td><td style="text-align:center">多媒体相关库</td><td style="text-align:center">native</td><td style="text-align:center">本地库</td></tr><tr><td style="text-align:center">nfc-extras</td><td style="text-align:center">NFC相关</td><td style="text-align:center">obex</td><td style="text-align:center">蓝牙传输</td></tr><tr><td style="text-align:center">opengl</td><td style="text-align:center">2D/3D 图形API</td><td style="text-align:center">packages</td><td style="text-align:center">设置、TTS、VPN程序</td></tr><tr><td style="text-align:center">sax</td><td style="text-align:center">XML解析器</td><td style="text-align:center">services</td><td style="text-align:center">系统服务</td></tr><tr><td style="text-align:center">telephony</td><td style="text-align:center">电话通讯管理</td><td style="text-align:center">test-runner</td><td style="text-align:center">测试工具相关</td></tr><tr><td style="text-align:center">tests</td><td style="text-align:center">测试相关</td><td style="text-align:center">tools</td><td style="text-align:center">工具</td></tr><tr><td style="text-align:center">wifi</td><td style="text-align:center">wifi无线网络</td><td style="text-align:center"></td></tr></tbody></table><h4 id="C-C-程序库部分"><a href="#C-C-程序库部分" class="headerlink" title="C/C++程序库部分"></a>C/C++程序库部分</h4><p>系统运行库层（Native)中的 C/C++程序库的类型繁多，功能强大，C/C++程序库并不完全在一个目录中，这里给出几个常用且比较重要的C/C++程序库所在的目录位置。</p><table><thead><tr><th style="text-align:center">目录位置</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">bionic/</td><td style="text-align:center">Google开发的系统C库，以BSD许可形式开源。</td></tr><tr><td style="text-align:center">/frameworks/av/media</td><td style="text-align:center">系统媒体库</td></tr><tr><td style="text-align:center">/frameworks/native/opengl</td><td style="text-align:center">3D图形库/第三方图形渲染库</td></tr><tr><td style="text-align:center">/frameworks/native/services/surfaceflinger</td><td style="text-align:center">图形显示库，主要负责图形的渲染、叠加和绘制等功能</td></tr><tr><td style="text-align:center">external/sqlite</td><td style="text-align:center">轻量型关系数据库SQLite的C++实现</td></tr><tr><td style="text-align:center">external/webp,external/webrtc</td><td style="text-align:center">网络引擎库</td></tr></tbody></table><h4 id="系统运行库部分"><a href="#系统运行库部分" class="headerlink" title="系统运行库部分"></a>系统运行库部分</h4><p>Dalvik虚拟机的实现: /dalvik，从Android 5.0开始，Android应用程序的默认运行环境为ART ( Android Runtime )，ART模式拥有更快更高的运行效率。ART: /art</p><h4 id="硬件抽象层部分"><a href="#硬件抽象层部分" class="headerlink" title="硬件抽象层部分"></a>硬件抽象层部分</h4><p><strong>hardware/</strong><br>libhardware: audio、nfc、power实现<br>ril: 无线硬件设备与电话的实现</p><h2 id="阅读工具"><a href="#阅读工具" class="headerlink" title="阅读工具"></a>阅读工具</h2><h3 id="vim-ctags-cscope"><a href="#vim-ctags-cscope" class="headerlink" title="vim+ctags+cscope"></a>vim+ctags+cscope</h3><p><a href="https://blog.xiaohansong.com/linux-code-tool.html" target="_blank" rel="noopener">Linux 平台下阅读源码的工具</a></p><h3 id="Source-Insight-Understand"><a href="#Source-Insight-Understand" class="headerlink" title="Source Insight/Understand"></a>Source Insight/Understand</h3><p><a href="https://www.cnblogs.com/andy-songwei/p/9965714.html" target="_blank" rel="noopener">【工利其器】工具使用之（一）Source Insight篇</a></p><p><a href="https://github.com/foxleezh/AOSP/issues/2#" target="_blank" rel="noopener">如何阅读Android源码</a> </p><h3 id="OpenGrok"><a href="#OpenGrok" class="headerlink" title="OpenGrok"></a>OpenGrok</h3><p><a href="https://juejin.im/post/5850f0b1128fe1006b4e5e68" target="_blank" rel="noopener">搭建大型源码阅读环境——使用 OpenGrok</a></p><p><a href="https://blog.csdn.net/TaylorPotter/article/details/72084817" target="_blank" rel="noopener">工具使用-Mac上搭建OpenGrok查看Android源码</a></p><p><a href="http://androidxref.com" target="_blank" rel="noopener">androidxref</a></p><h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p><a href="https://lingdage.com/posts/fa96240a.html">AOSP 源码导入 Android Studio</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/fb176196bfcf" target="_blank" rel="noopener">获取Android源码，初识源码模块架构</a></p><p><a href="https://github.com/aosp-mirror" target="_blank" rel="noopener">Github asop mirror</a></p><p><a href="https://blog.csdn.net/itachi85/article/details/54695046" target="_blank" rel="noopener">Android系统架构与系统源码目录</a></p><p><a href="https://www.jianshu.com/p/3922ec229077" target="_blank" rel="noopener">下载AOSP android源码（最小最快下载方式，跳过编译直接导入Android Studio） Ubuntu 16.04</a></p><p><a href="http://gityuan.com/2016/08/13/android-os-env" target="_blank" rel="noopener">AndroidStudio源码开发环境搭建</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;配置Android-Studio&quot;&gt;&lt;a href=&quot;#配置Android-Studio&quot; class=&quot;headerlink&quot; title=&quot;配置Android Studio&quot;&gt;&lt;/a&gt;配置Android Studio&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;调整内存大小: &lt;/strong&gt; Android Studio需要大量的内存来加载Android源码，所以经常会遇到内存不足的问题, 需要加大内存. 点击&lt;code&gt;Help&lt;/code&gt;-&amp;gt; &lt;code&gt;Edit Custom VM Options&lt;/code&gt;, 比如 “-Xms4096m -Xmx4096m”&lt;/p&gt;
&lt;p&gt;更多资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/intro/studio-config.html#low_memory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;配置 Android Studio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="AOSP" scheme="https://lingdage.com/tags/AOSP/"/>
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>AOSP frameworks 源码环境搭建</title>
    <link href="https://lingdage.com/posts/ca9841f5.html"/>
    <id>https://lingdage.com/posts/ca9841f5.html</id>
    <published>2019-02-28T05:25:24.000Z</published>
    <updated>2019-04-01T06:07:26.224Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录最快捷的将framework层源码导入android studio进行源码分析的方法</p><ul><li><p>获取framework源码，这里使用清华大学的<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">镜像</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/WorkSpace/AOSP</span><br><span class="line">cd ~/WorkSpace/AOSP</span><br><span class="line">git clone -b android-9.0.0_r1 https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base platform/frameworks/ --depth 1</span><br></pre></td></tr></table></figure></li><li><p>新建out文件夹 和 frameworks 同级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/WorkSpace/AOSP/platform/frameworks</span><br><span class="line">mkdir -p ./out/host/linux-x86/framework</span><br></pre></td></tr></table></figure></li><li><p>获取idegen.jar 并复制到 out/host/linux-x86/framework  下<br><a href="ca9841f5/idegen.jar">idegen.jar</a></p></li><li><p>获取idegen.sh </p><ul><li><p>clone development 到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://aosp.tuna.tsinghua.edu.cn/platform/development platform/development platform/</span><br><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure></li><li><p>或直接选择别人下好的idegen.sh<br><a href="ca9841f5/idegen.sh">idegen.sh</a><br>执行idegen.sh将会在～/WorkSpace/AOSP/platform/ 下生成android.iml 和 android.ipr 文件</p></li></ul></li><li>打开android studio 选择android.ipr 导入工程即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将记录最快捷的将framework层源码导入android studio进行源码分析的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取framework源码，这里使用清华大学的&lt;a href=&quot;https://mirror.tuna.tsinghua.edu.cn/help/
      
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="AOSP" scheme="https://lingdage.com/tags/AOSP/"/>
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>计划2019</title>
    <link href="https://lingdage.com/posts/397a8e26.html"/>
    <id>https://lingdage.com/posts/397a8e26.html</id>
    <published>2019-01-18T06:03:24.000Z</published>
    <updated>2019-03-21T10:32:14.481Z</updated>
    
    <content type="html"><![CDATA[<p> 　　2015年12月入职的，一直在这家公司，时光如白驹过隙，一晃3年就过去了，从来没有好好静下心来回头看看。今年结了婚，有了十一，压力一下子大了一个级别，生活也瞬间过得捉襟见肘的。3年过去，自己的能力明显没有达到自己的期望，在公司这3年，怎么说呢，虽然不说虚度，但至少没有自己想象的那么努力，技术上广度我自认为还是可以的，深度就不行了，杂而不精。</p><p><img src="/posts/397a8e26/01-big.jpg" alt="01"></p><p>　　希望今年不再碌碌无为，能有个质变。</p><a id="more"></a><hr><p>　　2019年要努力达成的目标 ： </p><ul><li style="list-style: none"><input type="checkbox"> 长10斤肉</li><li style="list-style: none"><input type="checkbox"> 早睡早起</li><li style="list-style: none"><input type="checkbox"> 每周至少运动2次</li><li style="list-style: none"><input type="checkbox"> 精读至少10本技术书</li><li style="list-style: none"><input type="checkbox"> 尽量阅读英文文档</li><li style="list-style: none"><input type="checkbox"> 产出至少10篇技术博客，3篇非技术博客</li><li style="list-style: none"><input type="checkbox"> 开源至少1个<a href="http://www.google.com/" target="_blank" rel="noopener">项目</a></li><li style="list-style: none"><input type="checkbox"> Android常见组件以及目前流行框架源码至少都过一遍</li><li style="list-style: none"><input type="checkbox"> 参加至少1次技术沙龙</li><li style="list-style: none"><input type="checkbox"> 有机会去北上广深杭感受下</li><li style="list-style: none"><input type="checkbox"> 学会Kotlin/Flutter 并投入生产</li><li style="list-style: none"><input type="checkbox"> 了解，并初步使用Go</li><li style="list-style: none"><input type="checkbox"> 简单学习一些shell编程</li><li style="list-style: none"><input type="checkbox"> 工资翻一番</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　　2015年12月入职的，一直在这家公司，时光如白驹过隙，一晃3年就过去了，从来没有好好静下心来回头看看。今年结了婚，有了十一，压力一下子大了一个级别，生活也瞬间过得捉襟见肘的。3年过去，自己的能力明显没有达到自己的期望，在公司这3年，怎么说呢，虽然不说虚度，但至少没有自己想象的那么努力，技术上广度我自认为还是可以的，深度就不行了，杂而不精。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/397a8e26/01-big.jpg&quot; alt=&quot;01&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　希望今年不再碌碌无为，能有个质变。&lt;/p&gt;
    
    </summary>
    
      <category term="生活随笔" scheme="https://lingdage.com/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活随笔" scheme="https://lingdage.com/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="计划" scheme="https://lingdage.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
</feed>
