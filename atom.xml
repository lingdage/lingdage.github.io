<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌大哥@Android攻城狮</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lingdage.com/"/>
  <updated>2019-03-28T08:02:05.601Z</updated>
  <id>https://lingdage.com/</id>
  
  <author>
    <name>lingdage</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AsyncTask 源码分析</title>
    <link href="https://lingdage.com/posts/96014b68.html"/>
    <id>https://lingdage.com/posts/96014b68.html</id>
    <published>2019-03-26T06:39:02.000Z</published>
    <updated>2019-03-28T08:02:05.601Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">framework/base/core/java/andorid/os/AsyncTask.java</span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前讲解了能够在后台工作线程中执行耗时任务的<a href="https://lingdage.com/posts/20470e2e.html">IntentService</a>框架，在这里我们继续学习<code>Android</code>提供的另外一个异步执行任务的框架<code>AsyncTask</code>，它和<code>IntentService</code>既有相似点也有不同点，其相似之处在于都能在新的线程中执行耗时任务防止阻塞主线程，不同之处在于<code>AsyncTask</code>能够追踪任务的执行过程和结果并在主线程中显示出来。</p><a id="more"></a><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><h3 id="LinkedBlockingQueue-链阻塞队列"><a href="#LinkedBlockingQueue-链阻塞队列" class="headerlink" title="LinkedBlockingQueue 链阻塞队列"></a>LinkedBlockingQueue 链阻塞队列</h3><p>阻塞队列<code>BlockingQueue</code>被广泛使用在“生产者-消费者”问题中，其原因是<code>BlockingQueue</code>提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。<br><code>LinkedBlockingQueue</code> 类实现了<code>BlockingQueue</code> 接口。<code>LinkedBlockingQueue</code> 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。<code>LinkedBlockingQueue</code> 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>数组队列 ArrayDeque的特点</p><ul><li>大小自增长的队列</li><li>内部使用数组存储数据</li><li>线程不安全</li><li>内部数组长度为8、16、32….. 2的n次方</li><li>头指针head从内部数组的末尾开始，尾指针tail从0开始，在头部插入数据时，head减一，在尾部插入数据时，tail加一。当head==tail时说明数组的容量满足不了当前的情况，此时需要扩大容量为原来的二倍。</li></ul><h3 id="ExecutorService-执行器服务"><a href="#ExecutorService-执行器服务" class="headerlink" title="ExecutorService 执行器服务"></a>ExecutorService 执行器服务</h3><p>java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。</p><p><strong>ExecutorService 简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>首先使用 newFixedThreadPool() 工厂方法创建一个 <code>ExecutorService</code>。这里创建了一个十个线程执行任务的线程池。<br>然后，将一个 <code>Runnable</code> 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。</p><h3 id="ThreadPoolExecutor-线程池执行者"><a href="#ThreadPoolExecutor-线程池执行者" class="headerlink" title="ThreadPoolExecutor 线程池执行者"></a>ThreadPoolExecutor 线程池执行者</h3><p>ava.util.concurrent.ThreadPoolExecutor 是 <code>ExecutorService</code> 接口的一个实现。<code>ThreadPoolExecutor</code> 使用其内部池中的线程执行给定任务(Callable 或者 Runnable)。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看几个参数的含义及作用</p><ul><li>corePoolSize — 核心线程数，即允许闲置的线程数目</li><li>maximumPoolSize — 最大线程数，即这个线程池的容量</li><li>keepAliveTime — 非核心线程的闲置存活时间</li><li>unit — 上一个参数的单位</li><li>workQueue — 任务队列（阻塞队列）</li><li>threadFacotry — 线程创建工厂</li><li>handler — 当线程池或者任务队列容量已满时用于 reject</li></ul><h3 id="Callable-amp-amp-Future"><a href="#Callable-amp-amp-Future" class="headerlink" title="Callable&amp;&amp;Future"></a>Callable&amp;&amp;Future</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来讲，<code>Callable</code>接口等价于<code>Runable</code>，call()等价于run()，区别在于它是有返回值的。<br>我们可以通过<code>ExecutorService</code>调用<code>Callable</code>，执行后将返回<code>Future对象</code>，比如:<br><code>Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>接口两个方法着重理解下，一是<code>cancel(boolean mayInterruptIfRunning)</code>，顾名思义就是终止线程，二是<code>get()</code>，它会阻塞线程，直到Callable的call()返回对象，并以此作为返回值。至于<code>mayInterruptIfRunning</code>这个boolean值的含义，大家看看<code>FutureTask</code>中相应的源码就直到了，其实只是多了<code>thread.interrupt()</code>的逻辑而已。结合Callable的代码，Future的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(mCallable);</span><br><span class="line"><span class="comment">//阻塞线程，等待Callable.call()的返回值</span></span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure><p>FutureTask<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation </span></span><br><span class="line"><span class="comment">     * unless it has been cancelled. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从`FutureTask`的继承关系来看，它既是`Runable`也是Future，所以我们可以把当做Runable来使用，同时它也具备Future的能力，可以终止线程，可以阻塞线程，等待Callable的执行，并获取返回值。另外要注意的是，它的构造函数是public FutureTask(Callable&lt;V&gt; callable)，因此实例化FutureTask时需要Callable对象作为参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## AsyncTask 的使用方式</span><br><span class="line"></span><br><span class="line">### 使用示例</span><br><span class="line">```java</span><br><span class="line">private class DownloadFileTask extends AsyncTask&lt;String, Integer, Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPreExecute() &#123;</span><br><span class="line">        mProgress.setVisibility(View.VISIBLE);</span><br><span class="line">        mProgress.setMax(100);</span><br><span class="line">        mProgress.setProgress(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long doInBackground(String... uris) &#123;</span><br><span class="line">        int count = uris.length;</span><br><span class="line">        long size = 0;</span><br><span class="line">        for (int i = 1; i &lt;= count; i ++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 休眠5秒模拟下载过程</span><br><span class="line">                Thread.sleep(5 * 1000);</span><br><span class="line">                // 假设每个下载文件的大小为（序号*100）</span><br><span class="line">                size += i * 100;</span><br><span class="line">                // 发布进度更新</span><br><span class="line">                publishProgress( (100* i )/count);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onProgressUpdate(Integer... progress) &#123;</span><br><span class="line">        mProgress.setProgress(progress[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onPostExecute(Long result) &#123;</span><br><span class="line">        mText.setText(String.valueOf(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码可以看到要使用<code>AsyncTask</code>实行异步任务是非常容易的，只需要做两件事:</p><ul><li>确定在整个处理过程中需要的参数类型，包括<code>Params</code>,<code>Progress</code>和<code>Result</code>,分别对应着输入参数、进度参数和结果参数。</li><li>实现必要的回调方法，其中必须是实现的是<code>doInBackground</code>，耗时任务正是在这里进行处理的，可以想象<code>doInBackground</code>一定是在子线程里进行的；其他可选实现方法包括<code>onPreExecute</code>,<code>onProgressUpdate</code>和<code>onPostExecute</code>，这些在示例中都参与了UI的更新，所以一定是在主线程中进行的。</li></ul><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><p><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt; { ... }</code></p><p>可以发现<code>AsyncTask</code>中使用的都是泛型参数，在使用过程中要根据需求选择合适的参数类型，在示例中使用的参数类型分别是<code>String</code>,<code>Integer</code>和<code>Long</code>,如果某一个参数是不需要的，可以用<code>Void</code>来表示，下面通过一个表格来对每个参数进行说明：</p><table><thead><tr><th style="text-align:center">参数声明</th><th style="text-align:center">含义</th><th style="text-align:center">作用</th><th style="text-align:center">产生处/调用处</th><th style="text-align:center">注意事项</th></tr></thead><tbody><tr><td style="text-align:center">Params</td><td style="text-align:center">输入参数</td><td style="text-align:center">任务开始执行时客户端发送开始参数</td><td style="text-align:center">execute()中发送，在doInBackground()中调用。</td><td style="text-align:center">可变参类型</td></tr><tr><td style="text-align:center">Progress</td><td style="text-align:center">过程参数</td><td style="text-align:center">任务后台执行过程中服务端发布的当前执行进度</td><td style="text-align:center">在doInBackground()中产生并通过publishProgess()发送，在onProgressUpdate()调用。</td><td style="text-align:center">可变参类型</td></tr><tr><td style="text-align:center">Result</td><td style="text-align:center">结果参数</td><td style="text-align:center">任务执行完成后服务端发送的执行结果</td><td style="text-align:center">在doInBackground()中产生并在onPostExecute()中调用。</td></tr></tbody></table><blockquote><p>参数类型不能是基本数据类型，要使用对应的封装类型，例如示例的<code>Progress</code>和<code>Result</code>参数使用的<code>Integer</code>和<code>Long</code>而不是<code>int</code>和<code>long</code>。</p></blockquote><h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><table><thead><tr><th style="text-align:center">回调方法</th><th style="text-align:center">运行线程</th><th style="text-align:center">作用</th><th style="text-align:center">执行顺序</th><th style="text-align:center">是否需要重新实现</th></tr></thead><tbody><tr><td style="text-align:center">onPreExecute</td><td style="text-align:center">主线程</td><td style="text-align:center">在开始执行后台任务前进行初始化</td><td style="text-align:center">首先开始执行</td><td style="text-align:center">可选</td></tr><tr><td style="text-align:center">doInBackground</td><td style="text-align:center">后台线程</td><td style="text-align:center">执行后台耗时任务完成后返回结果</td><td style="text-align:center">onPreExecute 执行完成后执行</td><td style="text-align:center">必须实现</td></tr><tr><td style="text-align:center">publishProgress</td><td style="text-align:center">后台线程</td><td style="text-align:center">在执行任务过程中发布执行进度</td><td style="text-align:center">在 doInBackground 中执行</td><td style="text-align:center">无须实现，直接调用。</td></tr><tr><td style="text-align:center">onProgressUpdate</td><td style="text-align:center">主线程</td><td style="text-align:center">接收进度并在主线程处理</td><td style="text-align:center">在 publishProgress 之后执行</td><td style="text-align:center">可选</td></tr><tr><td style="text-align:center">onPostExecute</td><td style="text-align:center">主线程</td><td style="text-align:center">接收执行结果并在主线程处理</td><td style="text-align:center">在 doInBackground 执行完成后执行</td><td style="text-align:center">可选</td></tr></tbody></table><h2 id="AsyncTask-源码分析"><a href="#AsyncTask-源码分析" class="headerlink" title="AsyncTask 源码分析"></a>AsyncTask 源码分析</h2><p>回到我们一开始提到的那个示例代码，当我们定义了好自己的AsyncTask之后，要开始运行这个任务时非常简单，只需要一行代码：</p><blockquote><p><code>new DownloadFileTask().execute(url1, url2, url3);</code></p></blockquote><p>我们就以这个为切入点来分析，首先看下<code>execute()</code>做了什么</p><p>首先，new DownloadFileTask() ，执行DownloadFileTask的构造方法，因此必然会执行DownloadFileTask的父类AsyncTask的构造方法，也就是 AsyncTask() ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//设置当前任务已被执行</span></span><br><span class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">            Result result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//设置线程执行的优先级</span></span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                <span class="comment">//noinspection unchecked</span></span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的工作很简单，就是完成了mWorker 和 mFuture 的初始化工作，也就是Callable和Future 的初始化，并关联他们，让mFuture 可以获取mWorker 的执行结果，或者停止mWorker 的执行。</p><p>这里主要由两个方法call()和done()，总的来说当mFuture 开始被执行的时候，call() 就会执行，当这个任务执行完毕后done()方法就会执行。</p><p>那么这个mFuture 什么 时候会被执行呢？继续往下看<code>execute(Params... params)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task is already running."</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task has already been executed "</span></span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line">    <span class="comment">// 回调方法中首先被调用的方法，由于"execute()"是在主线程中执行的,</span></span><br><span class="line">    <span class="comment">// 目前为止也没有进行线程的切换，所以"onPreExecute"也是在主线程中执行的。</span></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就很清楚了，mStatus 默认状态为PENDING，因此任务开始执行后首先将其状态改为<code>RUNNING</code>；同时从异常判断我们也可以看出一个<code>AsyncTask</code>的execute方法不能同时执行两次。</p><p>接下来，onPreExecute()，我们是在onCreate 中开启了<code>AsyncTask</code>的任务，因此这个时候，依旧属于主线程，onPreExecute()方法也会工作在主线程，我们可以在这个方法中执行一些预备操作，初始相关内容。</p><p>mWorker，前面已经说过他就是实现了Callable接口，并添加了一个参数属性，在这里我们把executor中传入的参数赋给了这个属性。exec=sDefaultExecutor=SerialExecutor ，这里任务就开始真正的执行了；按照之前所说就会开始执行mFuture这个任务，因此就会开始执行mWorker的call方法。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;         <span class="comment">//设置当前任务已被执行</span></span><br><span class="line">&gt;         mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">&gt;         Result result = <span class="keyword">null</span>;</span><br><span class="line">&gt;         <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;             <span class="comment">//设置线程执行的优先级</span></span><br><span class="line">&gt;             &gt; &gt; &gt;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">&gt;             <span class="comment">//noinspection unchecked</span></span><br><span class="line">&gt;             result = doInBackground(mParams);</span><br><span class="line">&gt;             Binder.flushPendingCommands();</span><br><span class="line">&gt;         &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">&gt;             mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">&gt;             <span class="keyword">throw</span> tr;</span><br><span class="line">&gt;         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;             postResult(result);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> result;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>到这里，我们终于看到了熟悉的 <em>doInBackground</em>，这是我们必须实现的一个方法，在其中完成耗时操作，并返回结果。由于已经设置了Process的优先级，因此这个方法会处于后台进程。<br>在 <em>doInBackground</em> 里，我们还可以返回当前执行进度</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Long <span class="title">doInBackground</span><span class="params">(String... uris)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">int</span> count = uris.length;</span><br><span class="line">&gt;         <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i ++) &#123;</span><br><span class="line">&gt;             <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                 <span class="comment">// 休眠5秒模拟下载过程</span></span><br><span class="line">&gt;                 Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">&gt;                 <span class="comment">// 假设每个下载文件的大小为（序号*100）</span></span><br><span class="line">&gt;                 size += i * <span class="number">100</span>;</span><br><span class="line">&gt;                 <span class="comment">// 发布进度更新</span></span><br><span class="line">&gt;                 publishProgress( (<span class="number">100</span>* i )/count);</span><br><span class="line">&gt;             &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">&gt;                 ie.printStackTrace();</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> size;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>我们调用了 <em>publishProgress</em> 可以将 <em>doInBackground</em>中<strong>耗时任务的进度发送出去</strong>，大家都知道这个进度会<strong>发送</strong>到onProgressUpdate() 方法中，在onProgressUpdate我们可以方便的进行UI 更新，比如进度条进度更新等。那么他是怎么实现的呢？这就要看publishProgress这个方法的实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTaskResult 顾名思义，很好理解了，就是AsyncTask的执行结果，这是一个静态的内部类，包括两个属性mTask和mData 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsyncTask mTask;</span><br><span class="line">        <span class="keyword">final</span> Data[] mData;</span><br><span class="line"></span><br><span class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">            mData = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此publishProgress中 new AsyncTaskResult 就是创建了一个AsyncTaskResult,他的两个两个属性为当前的AsyncTask和任务任务执行进度。</p><p>到这里的逻辑很清楚了，如果当前任务没有被取消， 那么就从消息池中获取一个<code>Message</code>的实例，同时设置这个<code>Message</code>对象的msg.what=MESSAGE_POST_PROGRESS, msg.obj为一个<code>AsyncTaskResult</code>对象，最后执行sendToTarget方法，通过之前对Handler实现机制的了解，我们知道sendXXX方法殊途同归，所完成的任务都是将Message对象插入到MessageQueue当中，等着Looper的loop方法一个个取出。由于我们是在主线程开启了AsyncTask任务的执行，因此，一旦我们将一个消息插入到队列，那么就会执行Handler的handleMessage方法。下面就来看看你这个InternalHandler 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单,在handleMessage中首先取出结果，并强制转换为AsyncTaskResult对象，在msg.what=MESSAGE_POST_PROGRESS时，就会执行result.mTask.onProgressUpdate(result.mData);<br>mTask 就是当前AsyncTask，因此就会执行AsyncTask中声明的onProgressUpdate方法。这样，就把参数从一个子线程传递到了UI 线程，非常方便开发人员用这个完成相关业务。</p><p>我们再回到mWorker  的call() 方法中，当doInBackground执行完毕后，最后就会执行postResult。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和publishProgress逻辑一样，懂事把result 封装到一个AsyncTaskResult 对象中，做为一个Message对象的obj属性插入到MessageQueue中，只不过msg.what=MESSAGE_POST_RESULT.</p><p>这样就会来到<code>InternalHandler</code> 的<code>handleMessage</code>中，这一次<code>msg.what</code>=<code>MESSAGE_POST_RESULT</code>.时执行<code>result.mTask.finish(result.mData[0])</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也很简单，任务未取消时，onPostExecute(result) 方法被执行。这个onPostExecute(result)就是我们最后要执行的方法，在这个方法中得到最终的执行结果；并将任务状态标记为<code>FINISHED</code>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="串行or并行？"><a href="#串行or并行？" class="headerlink" title="串行or并行？"></a>串行or并行？</h3><p>在SimpleAsyncTask中，我们使用<code>private static final Executor EXECUTOR = Executors.newCachedThreadPool()</code>作为线程池，而实际上，源码中的默认线程池是自定义的，这个类是<code>SerialExecutor</code>，从类的命名上看，Serial是串行的意思，所以很明显，AsyncTask默认是串行的。除此之外，AsyncTask里还有个线程池 <code>THREAD_POOL_EXECUTOR</code>，实在需要并行的话我们就用这个线程池。</p><p>如果都些都不满足要求，我们也可以自定义符合自己业务要求的线程池，并通过<code>setDefaultExecutor(Executor exec)</code>改变默认的线程池。</p><p>在<strong>executeOnExecutor</strong>中我们还可以传入自己自定义的线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//跟默认一样的按顺序执行</span><br><span class="line">asyncTask.executeOnExecutor(Executors.newSingleThreadExecutor());</span><br><span class="line">//无限制的Executor</span><br><span class="line">asyncTask.executeOnExecutor(Executors.newCachedThreadPool());</span><br><span class="line">//同时执行数目为10的Executor</span><br><span class="line">asyncTask.executeOnExecutor(Executors.newFixedThreadPool(10));</span><br></pre></td></tr></table></figure><h3 id="postResultIfNotInvoked的作用是什么？"><a href="#postResultIfNotInvoked的作用是什么？" class="headerlink" title="postResultIfNotInvoked的作用是什么？"></a>postResultIfNotInvoked的作用是什么？</h3><p>AsyncTask有很多逻辑干扰了我们解读源码，postResultIfNotInvoked便是其中一个。它实际上是Google解决的一个bug，确保如果cancel()方法过早调用的场景下，onCancelled()仍然能顺利的执行，参考<a href="https://stackoverflow.com/questions/25322651/asynctask-source-code-questions" target="_blank" rel="noopener">stackoverflow这篇文章</a>。</p><h3 id="用这个玩意-退出页面必须取消运行-否则你下个页面用的时候就知道问题了-串行坑了我一次"><a href="#用这个玩意-退出页面必须取消运行-否则你下个页面用的时候就知道问题了-串行坑了我一次" class="headerlink" title="用这个玩意 退出页面必须取消运行 否则你下个页面用的时候就知道问题了 串行坑了我一次"></a>用这个玩意 退出页面必须取消运行 否则你下个页面用的时候就知道问题了 串行坑了我一次</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5c774c70e51d450636311481" target="_blank" rel="noopener">理解 AsyncTask 原理</a></p><p><a href="https://juejin.im/post/58842012570c350062c111dd" target="_blank" rel="noopener">关于AsyncTask的一次深度解析</a></p><p><a href="https://www.jianshu.com/p/b1574686faa3" target="_blank" rel="noopener">AsyncTask:一只命途多舛的小麻雀</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;framework/base/core/java/andorid/os/AsyncTask.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前讲解了能够在后台工作线程中执行耗时任务的&lt;a href=&quot;https://lingdage.com/posts/20470e2e.html&quot;&gt;IntentService&lt;/a&gt;框架，在这里我们继续学习&lt;code&gt;Android&lt;/code&gt;提供的另外一个异步执行任务的框架&lt;code&gt;AsyncTask&lt;/code&gt;，它和&lt;code&gt;IntentService&lt;/code&gt;既有相似点也有不同点，其相似之处在于都能在新的线程中执行耗时任务防止阻塞主线程，不同之处在于&lt;code&gt;AsyncTask&lt;/code&gt;能够追踪任务的执行过程和结果并在主线程中显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android Bound Service 知识总结</title>
    <link href="https://lingdage.com/posts/ccf7cf3d.html"/>
    <id>https://lingdage.com/posts/ccf7cf3d.html</id>
    <published>2019-03-25T03:35:44.000Z</published>
    <updated>2019-03-28T07:49:31.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。</p><p>本文向您介绍如何创建绑定服务，包括如何绑定到来自其他应用组件的服务。 不过，您还应参阅<a href="https://lingdage.com/posts/75909e64.html">Android Service 知识总结</a>，了解有关一般服务的更多信息，例如：如何利用服务传送通知、如何将服务设置为在前台运行等等。</p><p>绑定服务是 <code>Service</code> 类的实现，可让其他应用与其绑定和交互。要提供服务绑定，您必须实现 <code>onBind()</code> 回调方法。该方法返回的 <code>IBinder</code> 对象定义了客户端用来与服务进行交互的编程接口。</p><a id="more"></a><blockquote><p>绑定到已启动服务</p><p>正如<a href="https://lingdage.com/posts/75909e64.html">Android Service 知识总结</a>中所述，可以创建同时具有已启动和绑定两种状态的服务。 也就是说，可通过调用<code>startService()</code> 启动该服务，让服务无限期运行；此外，还可通过调用 <code>bindService()</code> 使客户端绑定到服务。</p><p>如果您确实允许服务同时具有已启动和绑定状态，则服务启动后，系统“不会”在所有客户端都取消绑定时销毁服务。 为此，您必须通过调用 <code>stopSelf()</code> 或 <code>stopService()</code> 显式停止服务。</p><p>尽管您通常应该实现 <code>onBind()</code> <em>或</em> <code>onStartCommand()</code>，但有时需要同时实现这两者。例如，音乐播放器可能发现让其服务无限期运行并同时提供绑定很有用处。 这样一来，Activity 便可启动服务进行音乐播放，即使用户离开应用，音乐播放也不会停止。 然后，当用户返回应用时，Activity 可绑定到服务，重新获得回放控制权。</p><p>请务必阅读<a href="https://lingdage.com/posts/75909e64.html#lifecycle">管理绑定服务的生命周期</a>部分，详细了解有关为已启动服务添加绑定时该服务的生命周期信息。</p></blockquote><p>客户端可通过调用 <code>bindService()</code> 绑定到服务。调用时，它必须提供 <code>ServiceConnection</code> 的实现，后者会监控与服务的连接。<code>bindService()</code> 方法会立即无值返回，但当 Android 系统创建客户端与服务之间的连接时，会对 <code>ServiceConnection</code> 调用 <code>onServiceConnected()</code>，向客户端传递用来与服务通信的 <code>IBinder</code>。</p><p>多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 <code>onBind()</code> 方法来检索 <code>IBinder</code>。系统随后无需再次调用 <code>onBind()</code>，便可将同一 <code>IBinder</code> 传递至任何其他绑定的客户端。</p><p>当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 <code>startService()</code> 也启动了该服务）。</p><p>当您实现绑定服务时，最重要的环节是定义您的 <code>onBind()</code> 回调方法返回的接口。您可以通过几种不同的方法定义服务的<code>IBinder</code> 接口，下文对这些方法逐一做了阐述。</p><h2 id="创建绑定服务"><a href="#创建绑定服务" class="headerlink" title="创建绑定服务"></a>创建绑定服务</h2><p>创建提供绑定的服务时，您必须提供 <code>IBinder</code>，用以提供客户端用来与服务进行交互的编程接口。 您可以通过三种方法定义接口：</p><ul><li><p>扩展 Binder 类<br>如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 <code>Binder</code> 类并从 <code>onBind()</code> 返回它的一个实例来创建接口。客户端收到 <code>Binder</code> 后，可利用它直接访问 <code>Binder</code> 实现中乃至 <code>Service</code>中可用的公共方法。<br>如果服务只是您的自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的服务被其他应用或不同的进程占用。</p></li><li><p>使用 Messenger<br>如需让接口跨不同的进程工作，则可使用 <code>Messenger</code> 为服务创建接口。服务可以这种方式定义对应于不同类型 <code>Message</code> 对象的 <code>Handler</code>。此 <code>Handler</code> 是 <code>Messenger</code> 的基础，后者随后可与客户端分享一个 <code>IBinder</code>，从而让客户端能利用 <code>Message</code> 对象向服务发送命令。此外，客户端还可定义自有 <code>Messenger</code>，以便服务回传消息。<br>这是执行进程间通信 (IPC) 的最简单方法，因为 <code>Messenger</code> 会在单一线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。</p></li><li><p>使用 AIDL<br>AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 <code>Messenger</code> 的方法实际上是以 AIDL 作为其底层结构。 如上所述，<code>Messenger</code> 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。<br>如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。</p><blockquote><p>注：大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用，本文也不会阐述如何将其用于您的服务。如果您确定自己需要直接使用 AIDL，请参阅 AIDL 文档。</p></blockquote><blockquote><p>在Android系统中，一个进程是不能直接访问另一个进程的内存的，需要提供一些机制在不同的进程之间进行通信，Android官方推出了AIDL(Android Interface Definition Language)，它是基于Binder机制的，至于官方为什么要采用Binder，查看<a href="https://www.zhihu.com/question/39440766" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制</a>，分析很全面。<br>如果组件与服务通信是在同一进程，就使用第一种方式；如果是跨进程通信，使用第二种和第三种，两者不同在于，Messenger不能处理多线程并发请求。</p></blockquote></li></ul><h3 id="Binder">扩展 Binder 类</h3><p>如果您的服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 <code>Binder</code> 类，让您的客户端通过该类直接访问服务中的公共方法。</p><blockquote><p><strong>注</strong>：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。</p></blockquote><p>以下是具体的设置方法：</p><ol><li><p>在您的服务中，创建一个可满足下列任一要求的<code>Binder</code><br> 实例：</p><ul><li>包含客户端可调用的公共方法</li><li>返回当前 <code>Service</code> 实例，其中包含客户端可调用的公共方法</li><li>或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法</li></ul></li><li><p>从 <code>onBind()</code> 回调方法返回此 <code>Binder</code> 实例。</p></li><li><p>在客户端中，从 <code>onServiceConnected()</code> 回调方法接收 <code>Binder</code>，并使用提供的方法调用绑定服务。</p></li></ol><blockquote><p><strong>注</strong>：之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组。</p></blockquote><p>例如，以下这个服务可让客户端通过 Binder 实现访问服务中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Binder given to clients</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">    <span class="comment">// Random number generator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random mGenerator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class used for the client Binder.  Because we know this service always</span></span><br><span class="line"><span class="comment">     * runs in the same process as its clients, we don't need to deal with IPC.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Return this instance of LocalService so clients can call public methods</span></span><br><span class="line">            <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** method for clients */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mGenerator.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalBinder</code> 为客户端提供 <code>getService()</code> 方法，以检索 <code>LocalService</code> 的当前实例。这样，客户端便可调用服务中的公共方法。 例如，客户端可调用服务中的 <code>getRandomNumber()</code>。</p><p>点击按钮时，以下这个 Activity 会绑定到 <code>LocalService</code> 并调用 <code>getRandomNumber()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    LocalService mService;</span><br><span class="line">    <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Bind to LocalService</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService.class);</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// Unbind from the service</span></span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Called when a button is clicked (the button in the layout file attaches to</span></span><br><span class="line"><span class="comment">      * this method with the android:onClick attribute) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            <span class="comment">// Call a method from the LocalService.</span></span><br><span class="line">            <span class="comment">// However, if this call were something that might hang, then this request should</span></span><br><span class="line">            <span class="comment">// occur in a separate thread to avoid slowing down the activity performance.</span></span><br><span class="line">            <span class="keyword">int</span> num = mService.getRandomNumber();</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"number: "</span> + num, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Defines callbacks for service binding, passed to bindService() */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className,</span></span></span><br><span class="line"><span class="function"><span class="params">                IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// We've bound to LocalService, cast the IBinder and get LocalService instance</span></span><br><span class="line">            LocalBinder binder = (LocalBinder) service;</span><br><span class="line">            mService = binder.getService();</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName arg0)</span> </span>&#123;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例说明了客户端如何使用 <code>ServiceConnection</code> 的实现和 <code>onServiceConnected()</code> 回调绑定到服务。<a href="#Binding">下文</a>更详细介绍了绑定到服务的过程。</p><blockquote><p><strong>注</strong>：在上例中，<code>onStop()</code> 方法将客户端与服务取消绑定。 客户端应在适当时机与服务取消绑定，如<a href="#Additional_Notes">附加说明</a>中所述。</p></blockquote><h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><blockquote><p>与 AIDL 比较</p><p>当您需要执行 IPC 时，为您的接口使用 <code>Messenger</code> 要比使用 AIDL 实现它更加简单，因为 <code>Messenger</code> 会将所有服务调用排入队列，而纯粹的 AIDL 接口会同时向服务发送多个请求，服务随后必须应对多线程处理。</p><p>对于大多数应用，服务不需要执行多线程处理，因此使用 <code>Messenger</code> 可让服务一次处理一个调用。如果您的服务必须执行多线程处理，则应使用 <a href="https://developer.android.com/guide/components/aidl.html?hl=zh-cn" target="_blank" rel="noopener">AIDL</a> 来定义接口。</p></blockquote><p>如需让服务与远程进程通信，则可使用 <code>Messenger</code> 为您的服务提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。</p><p>以下是 <code>Messenger</code> 的使用方法摘要：</p><ul><li>服务实现一个 <code>Handler</code>，由其接收来自客户端的每个调用的回调</li><li><code>Handler</code> 用于创建 <code>Messenger</code> 对象（对 <code>Handler</code> 的引用）</li><li><code>Messenger</code> 创建一个 <code>IBinder</code>，服务通过 <code>onBind()</code> 使其返回客户端</li><li>客户端使用 <code>IBinder</code> 将 <code>Messenger</code>（引用服务的 <code>Handler</code>）实例化，然后使用后者将 <code>Message</code> 对象发送给服务</li><li>服务在其 <code>Handler</code> 中（具体地讲，是在 <code>handleMessage()</code> 方法中）接收每个 <code>Message</code>。</li></ul><p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message 对象）是服务在其 Handler 中接收的。<br>以下是一个使用 Messenger 接口的简单服务示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Command to the service to display a message */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SAY_HELLO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handler of incoming messages from clients.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IncomingHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_SAY_HELLO:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">"hello!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Target we publish for clients to send messages to IncomingHandler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> IncomingHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When binding to the service, we return an interface to our messenger</span></span><br><span class="line"><span class="comment">     * for sending messages to the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">"binding"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，服务就是在 <code>Handler#handleMessage()</code> 方法中接收传入的 <code>Message</code>，并根据 what 成员决定下一步操作。</p><p>客户端只需根据服务返回的<code>IBinder</code> 创建一个 <code>Messenger</code>，然后利用 send() 发送一条消息。例如，以下就是一个绑定到服务并向服务传递 MSG_SAY_HELLO 消息的简单 Activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityMessenger</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Messenger for communicating with the service. */</span></span><br><span class="line">    Messenger mService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Flag indicating whether we have called bind on the service. */</span></span><br><span class="line">    <span class="keyword">boolean</span> mBound;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class for interacting with the main interface of the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This is called when the connection with the service has been</span></span><br><span class="line">            <span class="comment">// established, giving us the object we can use to</span></span><br><span class="line">            <span class="comment">// interact with the service.  We are communicating with the</span></span><br><span class="line">            <span class="comment">// service using a Messenger, so here we get a client-side</span></span><br><span class="line">            <span class="comment">// representation of that from the raw IBinder object.</span></span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This is called when the connection with the service has been</span></span><br><span class="line">            <span class="comment">// unexpectedly disconnected -- that is, its process crashed.</span></span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// Create and send a message to the service, using a supported 'what' value</span></span><br><span class="line">        Message msg = Message.obtain(<span class="keyword">null</span>, MessengerService.MSG_SAY_HELLO, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Bind to the service</span></span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class), mConnection,</span><br><span class="line">            Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// Unbind from the service</span></span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，此示例并未说明服务如何对客户端作出响应。如果您想让服务作出响应，则还需要在客户端中创建一个<code>Messenger</code>。然后，当客户端收到 <code>onServiceConnected()</code> 回调时，会向服务发送一条 <code>Message</code>，并在其 <code>send()</code> 方法的 <code>replyTo</code> 参数中包含客户端的 <code>Messenger</code>。</p><h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>AIDL，即<code>Android Interface Definition Language</code>，Android接口定义语言。它是一种IDL语言，可以拿来生成用于IPC的代码。在我看来，它其实就是一个模板。为什么这样说呢？在我们的使用中，实际上起作用的并不是我们写的AIDL代码，而是系统根据它生成的一个IInterface实例的代码。而如果大家多生成几个这样的实例，然后把它们拿来比较，你会发现它们都是有套路的——都是一样的流程，一样的结构，只是根据具体的AIDL文件的不同有细微的变动。所以其实AIDL就是为了避免我们一遍遍的写一些千篇一律的代码而出现的一个模板。</p><p>使用<code>Messenger</code>也是基于AIDL的，<code>Messenger</code>把所有请求都放在一个线程中，service每次处理一个。然而对于AIDL实现来说。service可以同时处理多个请求（应该是并发处理）。这种情况下，你的服务必须拥有多线程处理能力，并且是以线程安全的方式编写的。<br>要直接使用AIDL，你必须创建一个<code>.aidl</code>文件，其中定义了编程接口。 Android SDK 工具使用此文件来自动生成一个抽象类，其中实现了接口及对IPC的处理，然后我们就可以在自己的服务中继承该类。</p><p>那么如何使用AIDL来通过bindService()进行线程间通信呢？基本上有下面这些步骤：</p><p>服务端创建一个AIDL文件，将暴露给客户端的接口在里面声明<br>在service中实现这些接口<br>客户端绑定服务端，并将onServiceConnected()得到的IBinder转为AIDL生成的IInterface实例<br>通过得到的实例调用其暴露的方法<br>上面的描述其实比较抽象，基本上是那种看了也不知道怎么做的类型——这个如果要展开讲的话就又是长篇大论的了。基于这种考虑，这里只是简单的介绍一下AIDL这个东西，它的具体的语法，到底怎么来实现IPC，参考<a href="https://blog.csdn.net/xiaohanluo/article/details/53911529" target="_blank" rel="noopener">Android进程通信之Messenger&amp;AIDL使用详解</a>。</p><p></p><h2 id="Binding">绑定到服务</h2><br>应用组件（客户端）可通过调用 <code>bindService()</code> 绑定到服务。Android 系统随后调用服务的 <code>onBind()</code> 方法，该方法返回用于与服务交互的<code>IBinder</code>。<p></p><p>绑定是异步的。<code>bindService()</code> 会立即返回，“不会”使<code>IBinder</code>返回客户端。要接收 <code>IBinder</code>，客户端必须创建一个 <code>ServiceConnection</code> 实例，并将其传递给 <code>bindService()</code>。<code>ServiceConnection</code> 包括一个回调方法，系统通过调用它来传递<code>IBinder</code>。</p><blockquote><p><strong>注</strong>：只有 Activity、服务和内容提供程序可以绑定到服务 — 您<strong>无法</strong>从广播接收器绑定到服务。</p></blockquote><p>因此，要想从您的客户端绑定到服务，您必须：<br>1.实现<code>ServiceConnection</code>。<br>  您的实现必须重写两个回调方法：<br>  <code>onServiceConnected()</code><br>    系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。</p><p>  <code>onServiceDisconnected()</code><br>    Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。</p><p>2.调用 <code>bindService()</code>，传递 <code>ServiceConnection</code> 实现。<br>3.当系统调用您的 <code>onServiceConnected()</code> 回调方法时，您可以使用接口定义的方法开始调用服务。<br>4.要断开与服务的连接，请调用 <code>unbindService()</code>。<br>  如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。 更好的做法是在客户端与服务交互完成后立即取消绑定客户端。 这样可以关闭空闲服务。如需了解有关绑定和取消绑定的适当时机的详细信息，请参阅<a href="#Additional_Notes">附加说明</a>。</p><p>例如，以下代码段通过<a href="#Binder">扩展 Binder 类</a>将客户端与上面创建的服务相连，因此它只需将返回的 <code>IBinder</code>转换为 <code>LocalService</code>类并请求 <code>LocalService</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LocalService mService;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="comment">// Called when the connection with the service is established</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Because we have bound to an explicit</span></span><br><span class="line">        <span class="comment">// service that is running in our own process, we can</span></span><br><span class="line">        <span class="comment">// cast its IBinder to a concrete class and directly access it.</span></span><br><span class="line">        LocalBinder binder = (LocalBinder) service;</span><br><span class="line">        mService = binder.getService();</span><br><span class="line">        mBound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when the connection with the service disconnects unexpectedly</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onServiceDisconnected"</span>);</span><br><span class="line">        mBound = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端可通过将此 <code>ServiceConnection</code> 传递至 <code>bindService()</code> 绑定到服务。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService.class);</span><br><span class="line">bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><ul><li><code>bindService()</code> 的第一个参数是一个 <code>Intent</code>，用于显式命名要绑定的服务（但 Intent 可能是隐式的）</li><li>第二个参数是 <code>ServiceConnection</code> 对象</li><li>第三个参数是一个指示绑定选项的标志。它通常应该是 <code>BIND_AUTO_CREATE</code>，以便创建尚未激活的服务。其他可能的值为 <code>BIND_DEBUG_UNBIND</code> 和 <code>BIND_NOT_FOREGROUND</code>，或 <code>0</code>（表示无）。</li></ul><p></p><h3 id="Additional_Notes">附加说明</h3><br>以下是一些有关绑定到服务的重要说明：<p></p><ul><li>您应该始终捕获 <code>DeadObjectException</code> 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。</li><li>对象是跨进程计数的引用。</li><li>您通常应该在客户端生命周期的匹配引入 (bring-up) 和退出 (tear-down) 时刻期间配对绑定和取消绑定。 例如：<ul><li>如果您只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。</li><li>如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。</li></ul></li></ul><blockquote><p><strong>注</strong>：通常情况下，<strong>切勿</strong>在 Activity 的 <code>onResume()</code> 和 <code>onPause()</code> 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的处理保持在最低水平。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （<a href="https://developer.android.com/guide/components/activities.html?hl=zh-cn#CoordinatingActivities" target="_blank" rel="noopener">Activity</a>文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。）</p></blockquote><h2 id="管理绑定服务的生命周期"><a href="#管理绑定服务的生命周期" class="headerlink" title="管理绑定服务的生命周期"></a>管理绑定服务的生命周期</h2><p>当服务与所有客户端之间的绑定全部取消时，Android 系统便会销毁服务（除非还使用 <code>onStartCommand()</code> 启动了该服务）。因此，如果您的服务是纯粹的绑定服务，则无需对其生命周期进行管理 — Android 系统会根据它是否绑定到任何客户端代您管理。</p><p>不过，如果您选择实现 <code>onStartCommand()</code> 回调方法，则您必须显式停止服务，因为系统现在已将服务视为<em>已启动</em>。在此情况下，服务将一直运行到其通过 <code>stopSelf()</code> 自行停止，或其他组件调用 <code>stopService()</code> 为止，无论其是否绑定到任何客户端。</p><p>此外，如果您的服务已启动并接受绑定，则当系统调用您的 <code>onUnbind()</code> 方法时，如果您想在客户端下一次绑定到服务时接收 <code>onRebind()</code> 调用，则可选择返回 <code>true</code>。<code>onRebind()</code> 返回空值，但客户端仍在其 <code>onServiceConnected()</code> 回调中接收 <code>IBinder</code>。下图说明了这种生命周期的逻辑。</p><p><img src="/posts/ccf7cf3d/service_binding_tree_lifecycle.png" alt="service_binding_tree_lifecycle"></p><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><h3 id="Messenger与AIDL的比较"><a href="#Messenger与AIDL的比较" class="headerlink" title="Messenger与AIDL的比较"></a>Messenger与AIDL的比较</h3><p>首先，在实现的难度上，肯定是<code>Messenger</code>要简单的多——至少不需要写AIDL文件了(虽然如果认真的究其本质，会发现它的底层实现还是AIDL)。另外，使用<code>Messenger</code>还有一个显著的好处是它会把所有的请求排入队列，因此你几乎可以不用担心多线程可能会带来的问题。</p><p>但是这样说来，难道AIDL进行IPC就一无是处了么？当然不是，如果是那样的话它早就被淘汰了。一方面是如果项目中有并发处理问题的需求，或者会有大量的并发请求，这个时候Messenger就不适用了——它的特性让它只能串行的解决请求。另外，我们在使用Messenger的时候只能通过Message来传递信息实现交互，但是在有些时候也许我们需要直接跨进程调用服务端的方法，这个时候又怎么办呢？只能使用AIDL。</p><p>所以，这两种IPC方式各有各的优点和缺点，具体使用哪种就看具体的需要了——当然，能使用简单的就尽量使用简单的吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/components/bound-services.html?hl=zh-cn" target="_blank" rel="noopener">Android Developers/Docs/指南/绑定服务</a></p><p><a href="https://blog.csdn.net/luoyanglizi/article/details/51594016" target="_blank" rel="noopener">Android中的Service：Binder，Messenger，AIDL（2）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。&lt;/p&gt;
&lt;p&gt;本文向您介绍如何创建绑定服务，包括如何绑定到来自其他应用组件的服务。 不过，您还应参阅&lt;a href=&quot;https://lingdage.com/posts/75909e64.html&quot;&gt;Android Service 知识总结&lt;/a&gt;，了解有关一般服务的更多信息，例如：如何利用服务传送通知、如何将服务设置为在前台运行等等。&lt;/p&gt;
&lt;p&gt;绑定服务是 &lt;code&gt;Service&lt;/code&gt; 类的实现，可让其他应用与其绑定和交互。要提供服务绑定，您必须实现 &lt;code&gt;onBind()&lt;/code&gt; 回调方法。该方法返回的 &lt;code&gt;IBinder&lt;/code&gt; 对象定义了客户端用来与服务进行交互的编程接口。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android Service 知识总结</title>
    <link href="https://lingdage.com/posts/75909e64.html"/>
    <id>https://lingdage.com/posts/75909e64.html</id>
    <published>2019-03-23T09:18:16.000Z</published>
    <updated>2019-03-28T07:29:53.074Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码</em></p></blockquote><p><code>framework/base/core/java/andorid/app/Service.java</code></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>引用官方定义:</p><blockquote><p> <code>Service</code> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p><p> <strong>注意：</strong>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p></blockquote><a id="more"></a><p><code>Service</code>是一个可以在后台执行长时间操作而不使用用户界面的应用组件。那么问题来了，既然它不使用用户界面，那么它怎么知道应该什么时候开始执行什么操作呢？答案是——它可以与其他的引用组件形成一些联系，从而可以根据其传来的信息在合适的时候执行合适的操作。</p><p>一般来讲，这种联系分为两种：<code>startService()</code>以及<code>bindService()</code>。这两种联系都可以使得一个<code>Service</code>开始运行，但是在其他方面有着诸多不同。</p><table><thead><tr><th></th><th><strong>启动service的方式</strong></th><th><strong>停止service的方式</strong></th><th><strong>service与启动它的组件之间的通信方式</strong></th><th><strong>service的生命周期</strong></th></tr></thead><tbody><tr><td>startService</td><td>在其他组件中调用startService()方法后，服务即处于启动状态</td><td>service中调用stopSelf()方法，或者其他组件调用stopService()方法后，service将停止运行</td><td>没有提供默认的通信方式，启动service后该service就处于独立运行状态</td><td>一旦启动，service即可在后台无限期运行，即使启动service的组件已被销毁也不受其影响，直到其被停止</td></tr><tr><td>bindService</td><td>在其他组件中调用bindService()方法后，服务即处于启动状态</td><td>所有与service绑定的组件都被销毁，或者它们都调用了unbindService()方法后，service将停止运行</td><td>可以通过 ServiceConnection进行通信，组件可以与service进行交互、发送请求、获取结果，甚至是利用IPC跨进程执行这些操作</td><td>当所有与其绑定的组件都取消绑定(可能是组件被销毁也有可能是其调用了unbindService()方法)后，service将停止</td></tr></tbody></table><p>注：<br>1.表格中的“其他组件”不包括<code>Broadcast receiver</code>，其不能bindService,但是可以startService的</p><p>2.startService()与bindService()并不冲突，同一个service可能既有组件调用了startService()启动它，又有组件与它进行了绑定。当同一个service与其他组件同时存在这两种联系时，其生命周期会发生变化，必须<strong>从两种方法的角度看service均停止</strong>才能真正停止。</p><h2 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h2><p>创建一个<code>Service</code>一般有下面2个步骤</p><ul><li>创建一个类继承自<code>Service</code>(或它的子类，如<code>IntentService</code>)，重写里面的一些键的回调方法，如<code>onStartCommand()</code>，<code>onBind()</code>等</li><li>在Manifests文件里面为其声明，并根据需要配置一些其他属性。</li></ul><p>讲道理，这一切跟新建一个<code>Activity</code>非常的像。</p><ul><li>onCreate()<br>在每个<code>Service</code>的生命周期中这个方法会且仅会调用一次，并且它的调用在<code>onStartCommand()</code>以及<code>onBind()</code>之前，我们可以在这个方法中进行一些一次性的初始化工作。</li><li>onStartCommand()<br>当其他组件通过<code>startService()</code>方法启动<code>Service</code>时，此方法将会被调用。</li><li>onBind()<br>当其他组件通过<code>bindService()</code>方法与<code>Service</code>相绑定之后，此方法将会被调用。这个方法有一个<code>IBinder</code>的返回值，这意味着在重写它的时候必须返回一个<code>IBinder</code>对象，它是用来支撑其他组件与<code>Service</code>之间的通信的——另外，如果你不想让这个<code>Service</code>被其他组件所绑定，可以通过在这个方法返回一个null值来实现。</li><li>onDestroy()<br>这是<code>Service</code>一生中调用的最后一个方法，当这个方法被调用之后，<code>Service</code>就会被销毁。所以我们应当在这个方法里面进行一些资源的清理，比如注册的一些监听器什么的。</li></ul><p>在Manifests文件里进行声明的时候，只有android:name属性是必须要有的，其他的属性都可以没有。但是有的时候适当的配置可以让我们的开发进行地更加顺利，所以了解一下注册一个<code>Service</code>可以声明哪些属性也是很有必要的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:isolatedProcess</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>具体含义可参考<a href="https://developer.android.com/guide/topics/manifest/service-element.html?hl=zh-cn" target="_blank" rel="noopener">官网</a></p><ul><li>android:enabled : 如果为true，则这个<code>Service</code>可以被系统实例化，如果为false，则不行。默认为true</li><li>android:exported : 如果为true，则其他应用的组件也可以调用这个<code>Service</code>并且可以与它进行互动，如果为false，则只有与<code>Service</code>同一个应用或者相同user ID的应用可以开启或绑定此<code>Service</code>。它的默认值取决于<code>Service</code>是否有<code>intent filters</code>。如果一个filter都没有，就意味着只有指定了<code>Service</code>的准确的类名才能调用，也就是说这个<code>Service</code>只能应用内部使用——其他的应用不知道它的类名。这种情况下exported的默认值就为false。反之，只要有了一个filter，就意味着<code>Service</code>是考虑到外界使用的情况的，这时exported的默认值就为true</li><li>android:icon : 一个象征着这个<code>Service</code>的icon</li><li>android:isolatedProcess : 如果设置为true，这个<code>Service</code>将运行在一个从系统中其他部分分离出来的特殊进程中，我们只能通过Service API来与它进行交流。默认为false。</li><li>android:label : 显示给用户的这个<code>Service</code>的名字。如果不设置，将会默认使用<application>的label属性。</application></li><li>android:name : 这个<code>Service</code>的路径名，例如“com.lingdage.demo.ServiceDemo”。这个属性是唯一一个必须填的属性。</li><li>android:permission : 其他组件必须具有所填的权限才能启动这个<code>Service</code>。</li><li>android:process : <code>Service</code>运行的进程的name。默认启动的<code>Service</code>是运行在<strong>主进程</strong>中的。</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDemo</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ServiceDome"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">        <span class="comment">//只在service创建的时候调用一次，可以在此进行一些一次性的初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onStartCommand"</span>);</span><br><span class="line">        <span class="comment">//当其他组件调用startService()方法时，此方法将会被调用</span></span><br><span class="line">        <span class="comment">//在这里进行这个service主要的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onBind"</span>);</span><br><span class="line">        <span class="comment">//当其他组件调用bindService()方法时，此方法将会被调用</span></span><br><span class="line">        <span class="comment">//如果不想让这个service被绑定，在此返回null即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onDestroy"</span>);</span><br><span class="line">        <span class="comment">//service调用的最后一个方法</span></span><br><span class="line">        <span class="comment">//在此进行资源的回收</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:每个<code>Service</code>必须在<code>manifest</code>中 通过<service>来声明</service></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.ServiceDemo"</span> &gt;</span> </span><br><span class="line">&gt;   ... </span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>现在我们通过继承<code>Service</code>的方式定义了我们自己的<code>ServiceDemo</code>类,并且在<code>manifest</code>中声明了我们的<code>ServiceDemo</code>,接下来我们应该启动我们自己的服务.</p><p>请注意，<code>onStartCommand()</code> 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，<code>IntentService</code> 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从<code>onStartCommand()</code> 返回的值必须是以下常量之一：</p><ul><li><p><code>START_NOT_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则除非有挂起 Intent 要传递，否则系统<em>不会</em>重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p></li><li><p><code>START_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务并调用 <code>onStartCommand()</code>，但<em>不会</em>重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 <code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p></li><li><p><code>START_REDELIVER_INTENT</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用<code>onStartCommand()</code>。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p></li></ul><h2 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h2><p>另一个组件通过调用<code>startService()</code>方法，就可以启动一个特定的<code>Service</code>，并且这将导致<code>Service</code>中的<code>onStartCommand()</code>方法被调用。在调用<code>startService()</code>方法的时候，其他组件需要在方法中传递一个<code>Intent</code>参数，然后<code>Service</code>将会在<code>onStartCommand()</code>中接收这个<code>Intent</code>，并获取一些数据。比如此时某个<code>Activity</code>要将一些数据存入数据库中，我就可以通过<code>Intent</code>把数据传入<code>Service</code>，然后让<code>Service</code>去进行连接数据库，存储数据等操作，而此时用户可以执行其他的任何操作——甚至包括销毁那个<code>Activity</code>——这并不会影响<code>Service</code>存储数据这件事。</p><p>当一个<code>Service</code>通过这种方式启动之后，它的生命周期就已经不受启动它的组件影响了，它可以在后台无限期的运行下去，只要<code>Service</code>自身没有调用<code>stopSelf()</code>并且其他的组件没有调用针对它的<code>stopService()</code>。</p><p>另外，如果确定了使用这种方式启动<code>Service</code>并且不希望这个<code>Service</code>被绑定的话，那么也许除了传统的创建一个类继承<code>Service</code>之外我们有一个更好的选择——<a href="https://lingdage.com/posts/e4e64342.html">IntentService</a>。</p><p>相比<code>Service</code>，IntentService要简单许多。但是要注意的是，如果你有让<code>Service</code>同时处理多个请求的需求，这个时候就只能去继承Service了。这个时候就要自己去处理工作线</p><p>demo</p><p>我们通过一个<code>Intent</code>对象，并调用<code>startService()</code>方法来启动<code>ServiceDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ServiceDemo.class);  </span><br><span class="line">startService(startIntent);</span><br></pre></td></tr></table></figure><blockquote><p> 注意,假如我们是通过点击<code>Button</code>执行上面的代码,那么第一次点击的时候回执行其中的<code>onCreate()</code>和<code>onStartCommand()</code>方法,但是当我们第二次点击的时候就只会执行<code>onStartCommand()</code>方法了.</p><p>为什么会这样呢？<br>这是由于<code>onCreate()</code>方法只会在<code>Service</code>第一次被创建的时候调用，如果当前<code>Service</code>已经被创建过了(第一次点击创建了<code>ServiceDemo</code>)，不管怎样调用<code>startService()</code>方法，<code>onCreate()</code>方法都不会再执行。</p></blockquote><p>启动了之后,当我们想停止服务的时候该怎么做呢?</p><p>我们也是通过一个<code>Intent</code>对象，并调用<code>stopService()</code>方法来停止<code>ServiceDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ServiceDemo.class);</span><br><span class="line">stopService(stopIntent);</span><br></pre></td></tr></table></figure><h2 id="停止Service"><a href="#停止Service" class="headerlink" title="停止Service"></a>停止Service</h2><p>启动服务必须管理自己的生命周期。也就是说，除非系统必须回收内存资源，否则系统不会停止或销毁服务，而且服务在<code>onStartCommand()</code> 返回后会继续运行。因此，服务必须通过调用 <code>stopSelf()</code> 自行停止运行，或者由另一个组件通过调用 <code>stopService()</code> 来停止它。</p><p>一旦请求使用 <code>stopSelf()</code> 或 <code>stopService()</code> 停止服务，系统就会尽快销毁服务。</p><p>但是，如果服务同时处理多个 <code>onStartCommand()</code> 请求，则您不应在处理完一个启动请求之后停止服务，因为您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，您可以使用<code>stopSelf(int)</code> 确保服务停止请求始终基于最近的启动请求。也就说，在调用 <code>stopSelf(int)</code> 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 <code>onStartCommand()</code> 的 <code>startId</code>）。然后，如果在您能够调用 <code>stopSelf(int)</code> 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。</p><blockquote><p><strong>注意：</strong>为了避免浪费系统资源和消耗电池电量，应用必须在工作完成之后停止其服务。 如有必要，其他组件可以通过调用<code>stopService()</code> 来停止服务。即使为服务启用了绑定，一旦服务收到对 <code>onStartCommand()</code> 的调用，您始终仍须亲自停止服务。</p></blockquote><h2 id="创建绑定服务"><a href="#创建绑定服务" class="headerlink" title="创建绑定服务"></a>创建绑定服务</h2><p>绑定服务允许应用组件通过调用 <code>bindService()</code> 与其绑定，以便创建长期连接（通常不允许组件通过调用<code>startService()</code> 来<em>启动</em>它）。</p><p>如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。</p><p>要创建绑定服务，必须实现 <code>onBind()</code> 回调方法以返回 <code>IBinder</code>，用于定义与服务通信的接口。然后，其他应用组件可以调用 <code>bindService()</code> 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（您<em>不必</em>按通过 <code>onStartCommand()</code> 启动的服务那样来停止绑定服务）。</p><p>要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 <code>IBinder</code> 的实现，并且服务必须从 <code>onBind()</code> 回调方法返回它。一旦客户端收到 <code>IBinder</code>，即可开始通过该接口与服务进行交互。</p><p>多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 <code>unbindService()</code> 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。</p><p>bindService这是一种比startService更复杂的启动方式，同时使用这种方式启动的service也能完成更多的事情，比如其他组件可向其发送请求，接受来自它的响应，甚至通过它来进行IPC等等。我们通常将绑定它的组件成为客户端，而称它为服务器。</p><p>如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式</p><ul><li>继承Binder类</li><li>使用Messenger类(AIDL的简化版)</li><li>使用AIDL</li></ul><p>这一块比较复杂,我们新开一篇讲解。<a href="https://lingdage.com/posts/ccf7cf3d.html">Android Bound Service 知识总结</a></p><h2 id="在前台运行服务"><a href="#在前台运行服务" class="headerlink" title="在前台运行服务"></a>在前台运行服务</h2><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。</p><p>例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。</p><p>要请求让服务运行于前台，请调用 <code>startForeground()</code>。此方法采用两个参数：唯一标识通知的整型数和状态栏的<code>Notification</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = <span class="keyword">new</span> Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);</span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：</strong>提供给 <code>startForeground()</code> 的整型 ID 不得为 0。    </p></blockquote><p>要从前台移除服务，请调用<code>stopForeground()</code>。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。</p><h1 id="lifecycle">管理服务生命周期</h1><p>服务的生命周期比 <code>Activity</code>的生命周期要简单得多。但是，密切关注如何创建和销毁服务反而更加重要，因为服务可以在用户没有意识到的情况下运行于后台。</p><p>服务生命周期（从创建到销毁）可以遵循两条不同的路径：</p><ul><li><p>启动服务</p><p>该服务在其他组件调用 <code>startService()</code> 时创建，然后无限期运行，且必须通过调用 <code>stopSelf()</code> 来自行停止运行。此外，其他组件也可以通过调用 <code>stopService()</code> 来停止服务。服务停止后，系统会将其销毁。</p></li><li><p>绑定服务</p><p>该服务在另一个组件（客户端）调用 <code>bindService()</code> 时创建。然后，客户端通过 <code>IBinder</code> 接口与服务进行通信。客户端可以通过调用 <code>unbindService()</code> 关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统即会销毁该服务。 （服务<em>不必</em>自行停止运行。）</p></li></ul><p>这两条路径并非完全独立。也就是说，您可以绑定到已经使用 <code>startService()</code> 启动的服务。例如，可以通过使用<code>Intent</code>（标识要播放的音乐）调用 <code>startService()</code> 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 <code>bindService()</code> 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 <code>stopService()</code> 或 <code>stopSelf()</code> 不会实际停止服务。</p><h2 id="实现生命周期回调"><a href="#实现生命周期回调" class="headerlink" title="实现生命周期回调"></a>实现生命周期回调</h2><p>与 <code>Activity</code> 类似，服务也拥有生命周期回调方法，您可以实现这些方法来监控服务状态的变化并适时执行工作。 以下框架服务展示了每种生命周期方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mStartMode;       <span class="comment">// indicates how to behave if the service is killed</span></span><br><span class="line">    IBinder mBinder;      <span class="comment">// interface for clients that bind</span></span><br><span class="line">    <span class="keyword">boolean</span> mAllowRebind; <span class="comment">// indicates whether onRebind should be used</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is being created</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is starting, due to a call to startService()</span></span><br><span class="line">        <span class="keyword">return</span> mStartMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A client is binding to the service with bindService()</span></span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// All clients have unbound with unbindService()</span></span><br><span class="line">        <span class="keyword">return</span> mAllowRebind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRebind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A client is binding to the service with bindService(),</span></span><br><span class="line">        <span class="comment">// after onUnbind() has already been called</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is no longer used and is being destroyed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong>与 Activity 生命周期回调方法不同，您<em>不</em>需要调用这些回调方法的超类实现。</p></blockquote><p><img src="/posts/75909e64/service_lifecycle.png" alt="android service lifecycle"></p><p>通过实现这些方法，您可以监控服务生命周期的两个嵌套循环：</p><ul><li><p>服务的整个生命周期从调用<code>onCreate()</code> 开始起，到<code>onDestroy()</code>返回时结束。与 Activity 类似，服务也在<code>onCreate()</code>中完成初始设置，并在<code>onDestroy()</code>中释放所有剩余资源。例如，音乐播放服务可以在<code>onCreate()</code>中创建用于播放音乐的线程，然后在<code>onDestroy()</code>中停止该线程。</p><p>无论服务是通过 <code>startService()</code> 还是 <code>bindService()</code> 创建，都会为所有服务调用 <code>onCreate()</code> 和 <code>onDestroy()</code> 方法。</p></li><li><p>服务的有效生命周期从调用<code>onStartCommand()</code>或<code>onBind()</code>方法开始。每种方法均有<code>Intent</code>对象，该对象分别传递到<code>startService()</code>或<code>bindService()</code> 。</p><p>对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 <code>onStartCommand()</code> 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 <code>onUnbind()</code> 返回时结束。</p></li></ul><blockquote><p><strong>注：</strong>尽管启动服务是通过调用 <code>stopSelf()</code> 或 <code>stopService()</code> 来停止，但是该服务并无相应的回调（没有 <code>onStop()</code> 回调）。因此，除非服务绑定到客户端，否则在服务停止时，系统会将其销毁 — <code>onDestroy()</code> 是接收到的唯一回调。</p></blockquote><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="Service和Thread的关系"><a href="#Service和Thread的关系" class="headerlink" title="Service和Thread的关系"></a>Service和Thread的关系</h3><p>答案：<code>Service</code>和<code>Thread</code>之间没有任何关系！</p><ul><li><p>两者概念的迥异</p><ul><li><p><code>Thread</code> 是程序执行的最小单元，它是分配CPU的基本单位，<code>Android</code>系统中UI线程也是线程的一种，当然<code>Thread</code>还可以用于执行一些耗时异步的操作。</p></li><li><p><code>Service</code>是<code>Android</code>的一种机制，服务是运行在主线程上的，它是由系统进程托管。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是<code>Binder</code>，它是在linux层交换信息的一种IPC，而所谓的<code>Service</code>后台任务只不过是指没有UI的组件罢了。</p></li></ul></li><li><p>两者的执行任务迥异</p><ul><li>在<code>Android</code>系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作。如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。</li><li><code>Service</code> 则是<code>Android</code>系统中的组件，一般情况下它运行于<strong>主线程</strong>中，因此在<code>Service</code>中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称<code>Service</code>为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让<code>Service</code>执行耗时任务，可在<code>Service</code>中开启单独线程去执行。</li></ul></li><li><p>两者使用场景</p><ul><li><p>当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程<code>Thread</code>，这样才能保证UI线程不被占用而影响用户体验。</p></li><li><p>在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过<code>Service</code>+<code>Notification</code>方式在后台执行同时在通知栏显示着。</p></li></ul></li><li><p>两者的最佳使用方式<br>在大部分情况下，<code>Thread</code>和<code>Service</code>都会结合着使用，比如下载文件，一般会通过<code>Service</code>在后台执行+<code>Notification</code>在通知栏显示+<code>Thread</code>异步下载，再如应用程序会维持一个<code>Service</code>来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个<code>Thread</code>与<code>Service</code>的结合来方便我们执行后台耗时任务，它就是<code>IntentService</code>，(深入了解<code>IntentService</code>，可以看<a href="https://lingdage.com/posts/e4e64342.html">IntentService</a>)，当然<code>IntentService</code>并不适用于所有的场景，但它的优点是使用方便、代码简洁，不需要我们创建<code>Service</code>实例并同时也创建线程，某些场景下还是非常赞的！由于<code>IntentService</code>是单个<code>worker thread</code>，所以任务需要排队，因此不适合大多数的多任务情况。还有为什么不直接在<code>Activity</code>里创建呢？这是因为<code>Activity</code>很难对<code>Thread</code>进行控制，当<code>Activity</code>被销毁之后，就没有任何其它的办法可以再重新获取到<strong>之前创建的子线程的实例</strong>。而且在一个<code>Activity</code>中创建的子线程，另一个<code>Activity</code>无法对其进行操作。但是<code>Service</code>就不同了，所有的<code>Activity</code>都可以与<code>Service</code>进行关联(通过绑定)，然后可以很方便地操作其中的方法，即使<code>Activity</code>被销毁了，之后只要重新与<code>Service</code>建立关联，就又能够获取到原有的<code>Service</code>中<code>Binder</code>的实例。因此，使用<code>Service</code>来处理后台任务，<code>Activity</code>就可以放心地<code>finish</code>，完全不需要担心无法对后台任务进行控制的情况。</p></li></ul><h3 id="Service的种类"><a href="#Service的种类" class="headerlink" title="Service的种类"></a>Service的种类</h3><h4 id="按运行地点分类"><a href="#按运行地点分类" class="headerlink" title="按运行地点分类"></a><strong>按运行地点分类</strong></h4><table><thead><tr><th style="text-align:center"><strong>类别</strong></th><th style="text-align:center"><strong>区别</strong></th><th style="text-align:center"><strong>优点</strong></th><th style="text-align:center"><strong>缺点</strong></th><th style="text-align:center"><strong>应用</strong></th></tr></thead><tbody><tr><td style="text-align:center">本地服务(Local)</td><td style="text-align:center">该服务依附在主进程上</td><td style="text-align:center">服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。</td><td style="text-align:center">主进程被Kill后，服务便会终止。</td><td style="text-align:center">非常常见的应用如：音乐播放服务。</td></tr><tr><td style="text-align:center">远程服务(Remote)</td><td style="text-align:center">该服务是独立的进程</td><td style="text-align:center">服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。</td><td style="text-align:center">该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。</td><td style="text-align:center">一些提供系统服务的Service，这种Service是常驻的。</td></tr></tbody></table><h4 id="按运行类型分类"><a href="#按运行类型分类" class="headerlink" title="按运行类型分类"></a>按运行类型分类</h4><table><thead><tr><th style="text-align:center"><strong>类别</strong></th><th style="text-align:center"><strong>区别</strong></th><th style="text-align:center"><strong>应用</strong></th></tr></thead><tbody><tr><td style="text-align:center">前台服务</td><td style="text-align:center">会在通知一栏显示 ONGOING 的 Notification，</td><td style="text-align:center">当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。</td></tr><tr><td style="text-align:center">后台服务</td><td style="text-align:center">默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。</td><td style="text-align:center">当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。</td></tr></tbody></table><p>有同学可能会问，后台服务我们可以自己创建<code>ONGOING</code>的 <code>Notification</code> 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 <code>startForeground</code>（ android 2.0 及其以后版本 ）或 <code>setForeground</code>（android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，<code>ONGOING</code> 的 <code>Notification</code>任然会移除掉。</p><p>####　<strong>按使用方式分类</strong></p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">区别</th></tr></thead><tbody><tr><td style="text-align:center">startService 启动的服务</td><td style="text-align:center">主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService</td></tr><tr><td style="text-align:center">bindService 启动的服务</td><td style="text-align:center">该方法启动的服务要进行通信。停止服务使用unbindService</td></tr><tr><td style="text-align:center">startService 同时也 bindService 启动的服务</td><td style="text-align:center">停止服务应同时使用stepService与unbindService</td></tr></tbody></table><blockquote><p>特别注意:<br>1、你应当知道在调用 <code>bindService</code> 绑定到<code>Service</code>的时候，你就应当保证在某处调用 <code>unbindService</code> 解除绑定（尽管 <code>Activity</code>被 <code>finish</code> 的时候绑定会自动解除，并且<code>Service</code>会自动停止）；<br>2、你应当注意 使用<code>startService</code>启动服务之后，一定要使用 <code>stopService</code>停止服务，不管你是否使用<code>bindService</code>；<br>3、同时使用 <code>startService</code> 与 <code>bindService</code> 要注意到，<code>Service</code> 的终止，需要<code>unbindService</code>与<code>stopService</code>同时调用，才能终止 <code>Service</code>，不管 <code>startService</code> 与 <code>bindService</code> 的调用顺序，如果先调用 <code>unbindService</code> 此时服务不会自动终止，再调用 <code>stopService</code> 之后服务才会停止，如果先调用<code>stopService</code> 此时服务也不会终止，而再调用 <code>unbindService</code> 或者 之前调用 <code>bindService</code> 的 <code>Context</code>不存在了（如<code>Activity</code>被<code>finish</code> 的时候）之后服务才会自动停止；<br>4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 <strong>Activity</strong> 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（<code>Context</code>不存在了），对应服务的生命周期与上述相同。<br>5、在 sdk 2.0 及其以后的版本中，对应的 <code>onStart</code> 已经被否决变为了 <code>onStartCommand</code>，不过之前的 <code>onStart</code> 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用<code>onStartCommand</code>而不是 <code>onStart</code>。</p></blockquote><p>这两种启动方式生命周期可以参考<a href="https://www.jianshu.com/p/9ff1e04268c0" target="_blank" rel="noopener">Android Service本地服务详解</a></p><h3 id="onStartCommand详解"><a href="#onStartCommand详解" class="headerlink" title="onStartCommand详解"></a>onStartCommand详解</h3><p>第一次调用<code>startService</code>方法时，<code>onCreate</code>方法、<code>onStartCommand`</code>方法将依次被调用，而多次调用startService<code>时，只有</code>onStartCommand<code>方法被调用，最后我们调用</code>stopService<code>方法停止服务时</code>onDestory<code>方法被回调，这就是启动状态下</code>Service`的执行周期。接着我们重新回过头来进一步分析onStartCommand（Intent intent, int flags, int startId），这个方法有3个传入参数，它们的含义如下：</p><ul><li><p>intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service</p></li><li><p>flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：</p><ul><li>START_FLAG_REDELIVERY<br>这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。</li><li>START_FLAG_RETRY<br>该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。</li></ul></li><li><p>startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。</p></li></ul><hr><p>另外，我们注意到onStartCommand()的返回值是一个很奇怪的值<code>START_STICKY</code>，这是个什么呢？或者说这个方法的返回值是用来干嘛的呢？事实上，它的返回值是用来指定系统对当前线程的行为的。它的返回值必须是以下常量之一： </p><ul><li><p>START_NOT_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p></li><li><p>START_STICKY : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但绝对不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p></li><li><p>START_REDELIVER_INTENT : 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p></li></ul><h3 id="关于启动服务与绑定服务间的转换问题"><a href="#关于启动服务与绑定服务间的转换问题" class="headerlink" title="关于启动服务与绑定服务间的转换问题"></a>关于启动服务与绑定服务间的转换问题</h3><p>虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个<code>Service</code>创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个<code>Service</code>实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：</p><ul><li><p>先绑定服务后启动服务<br>如果当前<code>Service</code>实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主<code>Activity</code>被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p></li><li><p>先启动服务后绑定服务<br>如果当前<code>Service</code>实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有<code>Context</code>调用了<code>stopService()</code>或是服务本身调用了<code>stopSelf()</code>方法抑或内存不足时才会销毁服务。</p></li></ul><p>以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论<code>Service</code>是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用<code>Activity</code>那样通过调用<code>Intent</code> 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/luoyanglizi/article/details/51586437" target="_blank" rel="noopener">Android中的Service：默默的奉献者 (1)</a></p><p><a href="https://developer.android.com/guide/components/services?hl=zh-cn" target="_blank" rel="noopener">Android Developers/Docs/指南/服务</a></p><p><a href="https://juejin.im/entry/589fd89b61ff4b006b48e41c" target="_blank" rel="noopener">全面了解 Service</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/52709857" target="_blank" rel="noopener">关于Android Service真正的完全详解，你需要知道的一切</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;framework/base/core/java/andorid/app/Service.java&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;引用官方定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;code&gt;Service&lt;/code&gt; 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;注意：&lt;/strong&gt;服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 源码分析</title>
    <link href="https://lingdage.com/posts/26c77b42.html"/>
    <id>https://lingdage.com/posts/26c77b42.html</id>
    <published>2019-03-22T12:41:21.000Z</published>
    <updated>2019-03-26T11:32:01.347Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5c948d3b6fb9a070ba314002" target="_blank" rel="noopener">https://juejin.im/post/5c948d3b6fb9a070ba314002</a></p><p>基本使用</p><p>源码分析</p><p>使用场景</p><p>优缺点</p><h1 id="Java-并发编程：ThreadLocal-的使用及其源码实现https-juejin-im-post-5b44cd7c6fb9a04f980cb065"><a href="#Java-并发编程：ThreadLocal-的使用及其源码实现https-juejin-im-post-5b44cd7c6fb9a04f980cb065" class="headerlink" title="Java 并发编程：ThreadLocal 的使用及其源码实现https://juejin.im/post/5b44cd7c6fb9a04f980cb065"></a>Java 并发编程：ThreadLocal 的使用及其源码实现<a href="https://juejin.im/post/5b44cd7c6fb9a04f980cb065" target="_blank" rel="noopener">https://juejin.im/post/5b44cd7c6fb9a04f980cb065</a></h1><h1 id="Java-200-面试题补充-ThreadLocal-模块"><a href="#Java-200-面试题补充-ThreadLocal-模块" class="headerlink" title="Java 200+ 面试题补充 ThreadLocal 模块"></a>Java 200+ 面试题补充 ThreadLocal 模块</h1><p><a href="https://juejin.im/post/5c805cb9f265da2d9e177f6d" target="_blank" rel="noopener">https://juejin.im/post/5c805cb9f265da2d9e177f6d</a></p><p>带你揭秘神秘的ThreadLocal</p><p><a href="https://juejin.im/post/5c77a0dfe51d45374276fab9" target="_blank" rel="noopener">https://juejin.im/post/5c77a0dfe51d45374276fab9</a></p><p><a href="https://blog.csdn.net/carson_ho/article/details/82344011" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/82344011</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c948d3b6fb9a070ba314002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5c948d3b6fb9a070ba314002&lt;
      
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>IntentService 源码分析</title>
    <link href="https://lingdage.com/posts/e4e64342.html"/>
    <id>https://lingdage.com/posts/e4e64342.html</id>
    <published>2019-03-22T05:53:18.000Z</published>
    <updated>2019-03-27T14:35:17.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码</em></p></blockquote><p><code>framework/base/core/java/andorid/app/IntentService.java</code></p><h2 id="IntentService简介"><a href="#IntentService简介" class="headerlink" title="IntentService简介"></a>IntentService简介</h2><p><code>IntentService</code>是<code>Service</code>的子类，比普通的<code>Service</code>增加了额外的功能。先看<code>Service</code>本身存在两个问题：  </p><ul><li><code>Service</code>不会专门启动一条单独的进程，<code>Service</code>与它所在应用位于同一个进程中</li><li><code>Service</code> 也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。</li></ul><p><a href="https://lingdage.com/posts/75909e64.html"><code>Service</code></a>主要用来在后台进行任务处理，例如后台播放音乐、下载文件、上传文件等等。由于<code>Service</code>是运行在主线程中的，也有一定的时间限制，如果在主线程中对一个任务的处理时间超过了限制，进程就会出现“应用不响应”,即ANR, Application Not Responding。为了避免这样情况,一般都会在<code>Service</code>里用新的<code>thread</code>处理一些可能需要更多处理时间的任务。</p><p>其实Android早就替我们设计了一种更方便的<code>Service + Thread</code>模式，就是本文要讲的<code>IntentService</code>，通过它可以很方便地实现在<code>Service</code>中使用<code>Thread</code>进行耗时任务的处理。</p><a id="more"></a><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="扩展-IntentService-类"><a href="#扩展-IntentService-类" class="headerlink" title="扩展 IntentService 类"></a>扩展 IntentService 类</h3><p>以下是 <code>IntentService</code> 的实现示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A constructor is required, and must call the super IntentService(String)</span></span><br><span class="line"><span class="comment">   * constructor with a name for the worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The IntentService calls this method from the default worker thread with</span></span><br><span class="line"><span class="comment">   * the intent that started the service. When this method returns, IntentService</span></span><br><span class="line"><span class="comment">   * stops the service, as appropriate.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">      <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// Restore interrupt status.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您只需要一个构造函数和一个 <code>onHandleIntent()</code> 实现即可。</p><p>如果您决定还重写其他回调方法（如 <code>onCreate()</code>、<code>onStartCommand()</code> 或 <code>onDestroy()</code>），请确保调用超类实现，以便 <code>IntentService</code> 能够妥善处理工作线程的生命周期。</p><p>例如，<code>onStartCommand()</code> 必须返回默认实现（即，如何将 Intent 传递给 <code>onHandleIntent()</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">"service starting"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除 <code>onHandleIntent()</code> 之外，您无需从中调用超类的唯一方法就是 <code>onBind()</code>（仅当服务允许绑定时，才需要实现该方法）。</p><p>在下一部分中，您将了解如何在扩展 <code>Service</code> 基类时实现同类服务。该基类包含更多代码，但如需同时处理多个启动请求，则更适合使用该基类。</p><h3 id="扩展服务类"><a href="#扩展服务类" class="headerlink" title="扩展服务类"></a>扩展服务类</h3><p>正如上一部分中所述，使用 <code>IntentService</code> 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 <code>Service</code> 类来处理每个 Intent。</p><p>为了便于比较，以下提供了 <code>Service</code> 类实现的代码示例，该类执行的工作与上述使用 <code>IntentService</code> 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Looper mServiceLooper;</span><br><span class="line">  <span class="keyword">private</span> ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handler that receives messages from the thread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>(looper);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">          <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="comment">// Restore interrupt status.</span></span><br><span class="line">              Thread.currentThread().interrupt();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Stop the service using the startId, so that we don't stop</span></span><br><span class="line">          <span class="comment">// the service in the middle of handling another job</span></span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Start up the thread running the service.  Note that we create a</span></span><br><span class="line">    <span class="comment">// separate thread because the service normally runs in the process's</span></span><br><span class="line">    <span class="comment">// main thread, which we don't want to block.  We also make it</span></span><br><span class="line">    <span class="comment">// background priority so CPU-intensive work will not disrupt our UI.</span></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"ServiceStartArguments"</span>,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the HandlerThread's Looper and use it for our Handler</span></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>, <span class="string">"service starting"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// For each start request, send a message to start a job and deliver the</span></span><br><span class="line">      <span class="comment">// start ID so we know which request we're stopping when we finish the job</span></span><br><span class="line">      Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">      msg.arg1 = startId;</span><br><span class="line">      mServiceHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we get killed, after returning from here, restart</span></span><br><span class="line">      <span class="keyword">return</span> START_STICKY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// We don't provide binding, so return null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">"service done"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所见，与使用 <code>IntentService</code> 相比，这需要执行更多工作。</p><p>但是，因为是由您自己处理对 <code>onStartCommand()</code> 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。</p><p>请注意，<code>onStartCommand()</code> 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，<code>IntentService</code> 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从<code>onStartCommand()</code> 返回的值必须是以下常量之一：</p><ul><li><p><code>START_NOT_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则除非有挂起 Intent 要传递，否则系统<em>不会</em>重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p></li><li><p><code>START_STICKY</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务并调用 <code>onStartCommand()</code>，但<em>不会</em>重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 <code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p></li><li><p><code>START_REDELIVER_INTENT</code></p><p>如果系统在 <code>onStartCommand()</code> 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用<code>onStartCommand()</code>。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。<br>以上大部分来自<a href="https://developer.android.com/guide/components/services?hl=zh-cn#ExtendingIntentService" target="_blank" rel="noopener">官方文档</a></p></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="创建工作线程"><a href="#创建工作线程" class="headerlink" title="创建工作线程"></a>创建工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>IntentService</code>第一次启动的时候会调用其<code>onCreate</code>来完成一些初始化操作：</p><p>首先创建了一个<code>HandlerThread</code>对象，这就是前面一直提到的<code>Worker线程</code>。大家对<code>Handler</code>和<code>Thread</code>都很了解，那这个<code>HandlerThread</code>是什么呢？简单来说，它就是内部有一个消息循环队列的线程，我们知道默认的线程内部是没有消息循环队列的，这就导致我们无法直接在其内部使用<code>Handler</code>。<code>Android</code>为了方便使用，直接提供了一个含有消息循环队列的<code>HandlerThread</code>。具体见<a href="https://lingdage.com/posts/b4da2c1c.html">HandlerThread 源码分析</a></p><p>利用已创建的<code>HandlerThread</code>内部的消息循环创建一个 <code>ServiceHandler</code>对象，这样它的消息处理函数<code>handleMessage</code>就会在对应的线程中执行了。</p><h3 id="接收和处理请求"><a href="#接收和处理请求" class="headerlink" title="接收和处理请求"></a>接收和处理请求</h3><p>我们其他组件通过<code>startService</code>来发送请求的，结合<code>service</code>的生命周期，会执行<code>onStartCommand</code>回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码看到，<code>onStartCommand</code>会直接调用<code>onStart</code>，在这里对发送过来的请求接收并通过<code>mServiceHandler</code>进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>handleMessage</code>中对接收到的请求用<code>onHandleIntent</code>进行实际处理，而<code>onHandleIntent</code>就是我们在使用过程中必须实现的处理逻辑。</p><h3 id="销毁Worker线程"><a href="#销毁Worker线程" class="headerlink" title="销毁Worker线程"></a>销毁Worker线程</h3><p>前面提到：当所有请求都被处理完成后，<code>service</code>就会被销毁，这是如何实现的呢？在上面看到<code>handleMessage</code>方法里在处理完当前请求时会调用<code>stopSelf(msg.arg1)</code>来尝试停止当前服务，之所以说“尝试”，是因为它不一定能真正停止服务。还是来看下<code>stopSelf(int)</code>的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Old version of &#123;<span class="doctag">@link</span> #stopSelfResult&#125; that doesn't return a result.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #stopSelfResult</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">stopSelfResult</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stopSelf(int)</code>的声明里提到它是<code>stopSelfResult(int)</code>的老版本，唯一的区别就是没有返回值。那我们直接看<code>stopSelfResult(int)</code>的声明，其中提到只有在当前的<code>service</code>的最近一次启动是<code>startId</code>发起的才会被停止。我们把这句话放在<code>IntentService</code>的场景里去理解，如果说当前接收到3个请求，在处理第一个请求后打算去停止服务，但是调用<code>stopSelf(int)</code>的时候发现最后一次启动是第三个请求发生的，并不会停止服务；处理完第二个请求后是类似的，只有在处理完第三个请求后，去尝试停止服务，这时发现最近一次启动就是它发起的，可以去停止服务了。</p><p>停止服务时，其<code>onDestroy</code>会得到调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mServiceLooper.quit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的用法例子可以参考<a href="https://www.jianshu.com/p/332b6daf91f0" target="_blank" rel="noopener">IntentService 示例与详解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>IntentService</code>相比父类<code>Service</code>而言，最大特点是其回调函数<code>onHandleIntent</code>中可以直接进行耗时操作，不必再开线程。其原理是<code>IntentService</code>的成员变量 <code>Handler</code>在初始化时已属于工作线程，之后<code>handleMessage</code>，包括<code>onHandleIntent</code>等函数都运行在工作线程中。</p><p>如果对<code>IntentService</code>的了解仅限于此，会有种<code>IntentService</code>很鸡肋的观点，因为在<code>Service</code>中开线程进行耗时操作也不麻烦。我当初也是这个观点，所以很少用<code>IntentService</code>。</p><p>但是<code>IntentService</code>还有一个特点，就是多次调用<code>onHandleIntent</code>函数（也就是有多个耗时任务要执行），多个耗时任务会按顺序依次执行。原理是其内置的<code>Handler</code>关联了任务队列，<code>Handler</code>通过<code>Looper</code>取任务执行是顺序执行的。</p><p>这个特点就能解决多个耗时任务需要顺序依次执行的问题。而如果仅用<code>Service</code>，开多个线程去执行耗时操作，就很难管理。</p><p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 <code>IntentService</code> 类实现服务也许是最好的选择。</p><h1 id="IntentService特征"><a href="#IntentService特征" class="headerlink" title="IntentService特征"></a>IntentService特征</h1><ul><li>会创建独立的worker线程用于在应用的主线程外执行传递给 <code>onStartCommand()</code> 的所有 Intent。</li><li>创建worker队列，用于将 Intent 逐一传递给 <code>onHandleIntent()</code> 实现，这样您就永远不必担心多线程问题。</li><li>所有请求处理完成后，<code>IntentService</code>会自动停止，无需调用<code>stopSelf()</code>方法停止<code>Service</code></li><li>为<code>Service</code>的<code>onBind()</code>提供默认实现，返回null</li><li>为<code>Service</code>的<code>onStartCommand</code>提供默认实现，可将<code>Intent</code> 依次发送到工作队列和 <code>onHandleIntent()</code> 实现。</li><li><code>IntentService</code>不会阻塞UI线程，而普通<code>Serveice</code>会导致ANR异常</li><li>可以启动<code>IntentService</code> 多次，而每一个耗时操作会以工作队列的方式在<code>IntentService</code> 的 <code>onHandleIntent</code> 回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推`</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/zhengyin_tmac/article/details/52446696" target="_blank" rel="noopener">IntentService的实际应用场景</a><br><a href="https://juejin.im/post/5c75f3e851882540a702ea8f" target="_blank" rel="noopener">理解 IntentService 原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;framework/base/core/java/andorid/app/IntentService.java&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;IntentService简介&quot;&gt;&lt;a href=&quot;#IntentService简介&quot; class=&quot;headerlink&quot; title=&quot;IntentService简介&quot;&gt;&lt;/a&gt;IntentService简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;IntentService&lt;/code&gt;是&lt;code&gt;Service&lt;/code&gt;的子类，比普通的&lt;code&gt;Service&lt;/code&gt;增加了额外的功能。先看&lt;code&gt;Service&lt;/code&gt;本身存在两个问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Service&lt;/code&gt;不会专门启动一条单独的进程，&lt;code&gt;Service&lt;/code&gt;与它所在应用位于同一个进程中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Service&lt;/code&gt; 也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://lingdage.com/posts/75909e64.html&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt;主要用来在后台进行任务处理，例如后台播放音乐、下载文件、上传文件等等。由于&lt;code&gt;Service&lt;/code&gt;是运行在主线程中的，也有一定的时间限制，如果在主线程中对一个任务的处理时间超过了限制，进程就会出现“应用不响应”,即ANR, Application Not Responding。为了避免这样情况,一般都会在&lt;code&gt;Service&lt;/code&gt;里用新的&lt;code&gt;thread&lt;/code&gt;处理一些可能需要更多处理时间的任务。&lt;/p&gt;
&lt;p&gt;其实Android早就替我们设计了一种更方便的&lt;code&gt;Service + Thread&lt;/code&gt;模式，就是本文要讲的&lt;code&gt;IntentService&lt;/code&gt;，通过它可以很方便地实现在&lt;code&gt;Service&lt;/code&gt;中使用&lt;code&gt;Thread&lt;/code&gt;进行耗时任务的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread 源码分析</title>
    <link href="https://lingdage.com/posts/b4da2c1c.html"/>
    <id>https://lingdage.com/posts/b4da2c1c.html</id>
    <published>2019-03-21T08:47:54.000Z</published>
    <updated>2019-03-27T09:01:00.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> <em>本文基于Android 9.0.0的源代码</em></p></blockquote><p><code>framework/base/core/java/andorid/os/HandlerThread.java</code></p><h2 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h2><p>在<a href="https://lingdage.com/posts/20470e2e.html">Handler源码分析</a>中我们提到,在子线程中创建<code>Handler</code>,要手动调用<code>Looper.prepare()</code>,创建的过程大致如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createManualThreadWithHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Android为了简化<code>Handler</code>的创建过程提供了一个便捷的类，使用它我们可以快速的创建一个带有<code>Looper</code>的线程，有了<code>Looper</code>这个线程，我们就可以生成<code>Handler</code>。</p><a id="more"></a><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: 创建并启动HandlerThread线程，内部包含Looper</span></span><br><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"lingdage"</span>);</span><br><span class="line">handlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 创建Handler</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 发送消息</span></span><br><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread id="</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="创建HandlerThread对象"><a href="#创建HandlerThread对象" class="headerlink" title="创建HandlerThread对象"></a>创建HandlerThread对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="comment">//HandlerThread的默认优先级是Process.THREAD_PRIORITY_DEFAULT,具体值为0。</span></span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的<code>HandlerThread</code>没有必要设置这么高的优先级，因而需要我们降低其优先级。注意！是Process里的优先级而不是Thread的。</p><h4 id="可控制的优先级"><a href="#可控制的优先级" class="headerlink" title="可控制的优先级"></a>可控制的优先级</h4><ul><li><code>THREAD_PRIORITY_DEFAULT</code>，默认的线程优先级，值为0。</li><li><code>THREAD_PRIORITY_LOWEST</code>，最低的线程级别，值为19。</li><li><code>THREAD_PRIORITY_BACKGROUND</code> 后台线程建议设置这个优先级，值为10。</li><li><code>THREAD_PRIORITY_MORE_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微优先，值为-1。</li><li><p><code>THREAD_PRIORITY_LESS_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微落后一些，值为1。</p><p>以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。</p><p>常见的加入优先级的方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>关于Android中线程的调度详情，请参考<a href="https://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/" target="_blank" rel="noopener">剖析Android中进程与线程调度之nice</a></p><h3 id="获取Looper"><a href="#获取Looper" class="headerlink" title="获取Looper"></a>获取Looper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用handlerThread 要先start</span></span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123; <span class="comment">// 进入同步块，当条件不满足时无限等待，</span></span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// 直到mLooper被设置成有效值了才退出while（当然也可能是线程状态不满足）；</span></span><br><span class="line">                wait();  <span class="comment">// run方法里的notifyAll就是用来唤醒这里的</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，直接看官方的注释就明白了。</p><h3 id="执行HandlerThread的run"><a href="#执行HandlerThread的run" class="headerlink" title="执行HandlerThread的run()"></a>执行HandlerThread的run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();  <span class="comment">//获取线程的tid</span></span><br><span class="line">    Looper.prepare();   <span class="comment">// 创建Looper对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">//获取looper对象</span></span><br><span class="line">        notifyAll(); <span class="comment">//唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();  <span class="comment">// 重写 onLooperPrepared，做一些初始化工作</span></span><br><span class="line">    Looper.loop();   <span class="comment">//loop方法是阻塞的 在未执行quit()或quitSafely()的时候后面代码是不执行的</span></span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Looper退出"><a href="#Looper退出" class="headerlink" title="Looper退出"></a>Looper退出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quitSafely();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>quit()</code>与<code>quitSafely()</code>的区别，仅仅在于是否移除当前正在处理的消息。移除当前正在处理的消息可能会出现不安全的行为。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>总结之前，我们先想一个场景，如果我们现在需要请求网络数据(假设需要请求一张图片,图片请求返回后需要更新UI),我们都知道UI线程中不允许进行耗时的网络请求。那么，我们通常会开启一个子线程来进行请求,如果你不用网络请求的三方库，一般会通过<code>new Thread()</code>,然后<code>start()</code>来完成吧！这样的话，如果有多次请求图片，那么我们就得new 很多个<code>Thread</code>。所以这是个问题！！！</p><p>问题解决分析<br>通过上面代码我们知道：<code>HandlerThread</code>一个子线程，并且含有一个<code>Looper</code>。<br>再来看看那个问题：我们之所以需要<code>new Thread()</code>,然后<code>start()</code>.是因为UI线程无法进行网络请求，但是，<code>HandlerThread</code>可是一个子线程，所以，在它里面可以直接请求网络，于是上面的<code>new Thread()</code>然后<code>start()</code>问题就解决了。<br>当然，就凭他是个子线程还没法说服我，虽然它是一个子线程不需要<code>new Thread()</code>，但是它自己也可能需要多次创建啊！只不过是从new一个<code>Thread</code>变成了<code>new HanderThread()</code>而已。这还不是没卵用。</p><p>那么如何解释它不需要重复创建呢？<br>其实也不难，只需要子线程不结束不就行了。(run方法中加个<code>while(true)</code>啊)，不过，它这里并不是<code>while(true)</code>,而是用到了调用了一个<code>loop()</code>方法。</p><p>loop方法是阻塞的，所以它后面的语句在它未退出的（可以通过quit()方法和quitSafely()方法退出）时候是没办法执行的。再加上它可以通过在外部实现一个Handler，然后，通过这个Handler给Looper发送message，近而源源不断的实现网络请求。所以，这就真正的解决了上面提出的那个问题。<br>这里给一个连接，里面介绍了如何在外部创建一个Handler,然后源源不断进行网络请求。<br><a href="https://blog.csdn.net/javazejian/article/details/52426353" target="_blank" rel="noopener">Android 多线程之HandlerThread 完全详解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HandlerThread</code>所做的就是在新开的子线程中创建了 <code>Looper</code>，那它的使用场景就是 <code>Thread</code>+<code>Looper</code>使用场景的结合，即：在子线程中执行耗时的、可能有多个任务的操作。</p><p><code>HandlerThread</code>比较适用于单线程+异步队列的场景，比如IO读写操作，耗时不多而且也不会产生较大的阻塞。对于网络IO操作，<code>HandlerThread</code>并不适合，因为它只有一个线程，还得排队一个一个等着。</p><p>对于本地IO读取操作，我们可以使用<code>postAtFrontOfQueue</code>方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。</p><p>使用 HandlerThread 的典型例子就是 IntentService，参考另一篇文章。<a href="https://lingdage.com/posts/e4e64342.html">IntentService 源码分析</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></p><p><a href="https://blog.csdn.net/qq_25184739/article/details/77926247" target="_blank" rel="noopener">HandlerThread</a></p><p><a href="https://www.jianshu.com/p/e9b2c0831b0d" target="_blank" rel="noopener">对HandlerThread的理解</a></p><p><a href="https://blog.csdn.net/u011240877/article/details/72905631" target="_blank" rel="noopener">Android 进阶15：HandlerThread 使用场景及源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; &lt;em&gt;本文基于Android 9.0.0的源代码&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;framework/base/core/java/andorid/os/HandlerThread.java&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用简介&quot;&gt;&lt;a href=&quot;#使用简介&quot; class=&quot;headerlink&quot; title=&quot;使用简介&quot;&gt;&lt;/a&gt;使用简介&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://lingdage.com/posts/20470e2e.html&quot;&gt;Handler源码分析&lt;/a&gt;中我们提到,在子线程中创建&lt;code&gt;Handler&lt;/code&gt;,要手动调用&lt;code&gt;Looper.prepare()&lt;/code&gt;,创建的过程大致如下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Handler mHandler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createManualThreadWithHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Looper.prepare();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Handler(Looper.myLooper());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Looper.loop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Android为了简化&lt;code&gt;Handler&lt;/code&gt;的创建过程提供了一个便捷的类，使用它我们可以快速的创建一个带有&lt;code&gt;Looper&lt;/code&gt;的线程，有了&lt;code&gt;Looper&lt;/code&gt;这个线程，我们就可以生成&lt;code&gt;Handler&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Handler源码分析</title>
    <link href="https://lingdage.com/posts/20470e2e.html"/>
    <id>https://lingdage.com/posts/20470e2e.html</id>
    <published>2019-03-04T07:15:49.000Z</published>
    <updated>2019-03-28T08:03:00.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文基于Android 9.0.0的源代码，来分析Handler的用法</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">framework/base/core/java/andorid/os/</span><br><span class="line">  - Handler.java</span><br><span class="line">  - Looper.java</span><br><span class="line">  - Message.java</span><br><span class="line">  - MessageQueue.java</span><br></pre></td></tr></table></figure><h2 id="Handler作用"><a href="#Handler作用" class="headerlink" title="Handler作用"></a>Handler作用</h2><ul><li>任务调度：即通过 <code>post()</code> 和 <code>send()</code> 等方法来指定某个任务在某个时间执行</li><li>线程切换：执行耗时的操作，比如网络请求，IO操作等，需要在子线程中运行，不然会阻塞主线程。<br>而执行完网络请求等耗时操作后通常需要更新UI，如果在子线程中更新UI，那么程序会崩溃。因为Android的UI是线程不安全的。 在Android中使用Rxjava，还要配合RxAndroid来使用，RxAndroid 内部就使用 Handler 来实现线程切换。</li></ul><a id="more"></a><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>常见的子线程中更新UI,复现代码,更具体见 <a href="https://juejin.im/post/5c7e19b7518825196101a47d" target="_blank" rel="noopener">Android子线程和更新UI问题</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">textView = (TextView) findViewById(R.id.txt);</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SystemClock.sleep(<span class="number">3000</span>);<span class="comment">//这句不加不会报错，具体分析见上面链接</span></span><br><span class="line">  textView.setText(<span class="string">"from来自子线程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;).start();</span><br></pre></td></tr></table></figure></p><p>运行异常信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ErrorInfo: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br><span class="line">        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6903)</span><br><span class="line">        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1050)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.view.View.requestLayout(View.java:19785)</span><br><span class="line">        at android.widget.TextView.checkForRelayout(TextView.java:7368)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:4480)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:4337)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:4312)</span><br></pre></td></tr></table></figure></p><p>可以看到错误发生在<strong>android.view.ViewRootImpl#checkThread</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见此处会判断<code>mThread</code>是不是等于当前线程<br>看下<code>mThread</code>到底是啥，在何处赋值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中被赋值的，也就是说是创建<code>ViewRootImpl</code>时所在的线程<br><code>ViewRootImpl</code>又是在哪里被创建的呢?这里不深入讲了，是在main线程<br>更具体的异常分析可以参考<a href="https://github.com/peerless2012/AndroidBasis/blob/master/problem/Only%20the%20original%20thread%20that%20created%20a%20view%20hierarchy%20can%20touch%20its%20views.%20%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84.md" target="_blank" rel="noopener">这个</a></p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">android.os.Handler handler = <span class="keyword">new</span> Handler()&#123;<span class="comment">//在主线程中获取handler</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里接受并处理消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">2000</span>);<span class="comment">//子线程中执行耗时操作</span></span><br><span class="line">         <span class="comment">//发送消息</span></span><br><span class="line">         Message message = Message.obtain();</span><br><span class="line"> message.what=<span class="number">1</span>;</span><br><span class="line"> message.obj=<span class="keyword">new</span> Object();</span><br><span class="line">     handler.sendMessage(message);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实例化一个 <code>Handler</code> 重写<code>handleMessage</code>方法 ，然后在需要的时候调用它的 <code>send</code> 以及 <code>post</code>系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档）</p><p>但是我们并没有看到<code>Handler</code>是如何与<code>MessageQueue</code>以及<code>Looper</code>关联起来的，下面我们进入源码分析下</p><h2 id="Handler-源码分析"><a href="#Handler-源码分析" class="headerlink" title="Handler 源码分析"></a>Handler 源码分析</h2><h3 id="Handler-实例化"><a href="#Handler-实例化" class="headerlink" title="Handler  实例化"></a>Handler  实例化</h3><p>从构造函数开始,我们通常从主线程中创建,先看下Handler的构造函数有哪些</p><ul><li><p>Handler()</p></li><li><p>Handler(Callback callback)</p></li><li><p>Handler(Looper looper)</p></li><li><p>Handler(Looper looper, Callback callback)</p></li><li><p>Handler(boolean async)</p></li><li><p>Handler(Callback callback, boolean async)</p></li><li><p>Handler(Looper looper, Callback callback, boolean async)</p></li></ul><p>看最后两个构造方法就行，因为前面的几个也是依次调用到后的方法</p><p>先看<code>Handler(Callback callback, boolean async)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Handler(Looper looper, Callback callback, boolean async)</code>与上面的区别就是<code>Looper</code>是赋值进去的。</p><h3 id="Looper-实例化"><a href="#Looper-实例化" class="headerlink" title="Looper 实例化"></a>Looper 实例化</h3><p>由上面可以看到调用<code>Looper#myLooper</code>方法获取到Looper对象， 如果mLooper == null的话，会抛出异常</p><blockquote><p>Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p>这个错误我们应该也见过。实际上我们在实例化 <code>Handler</code> 的时候 会去检查当前线程的 <code>Looper</code> 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 <code>Looper</code> 。<br>我们平时一般不会遇到这个错，因为我们大多数都是在主线程创建<code>Handler</code>的，而为什么在主线程就不要自己创建<code>Looper</code>，我们待会再看，目前只需要知道如果<code>Looper.myLooper()</code>没有获取到<code>Looper</code>对象的话就会报这个错。</p><p>我们跟踪<code>Looper#myLooper</code>方法进去，解决为什么会抛出这个异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有一行代码，从线程中取出<code>Looper</code>对象，那么我们有理由相信，这个<code>ThreadLocal</code>是通过set方法把<code>Looper</code>对象设置进去的。关于<code>ThreadLocal</code>，参考<a href="https://lingdage.com/posts/26c77b42.html">ThreadLocal 源码分析</a>。</p><p>想一想ThreadLocal在哪里把Looper对象设置进去了呢。回到刚才想要解决的问题：Can’t create handler inside thread that has not called Looper.prepare() 。那会不会是Looper的prepare方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用私有构造方法    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>确实是在<code>Looper#prepare</code>方法里把<code>Looper</code>对象设置进去的，而且从第一行的判断可以知道，一个线程只有一个<code>Looper</code>对象。 </p><p>所以，要创建<code>Handler</code>,那么<code>Looper.myLooper()</code>就必须非空，上面分析得出要非空，要先调用<code>Looper.prepare()</code>。</p><p>到了这里，<code>Looper</code>与<code>ThreadLocal</code>建立起了关联。</p><h3 id="MessageQueue-实例化"><a href="#MessageQueue-实例化" class="headerlink" title="MessageQueue 实例化"></a>MessageQueue 实例化</h3><p>接着上面继续看下<code>Looper</code>的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们实例化一个 <code>Looper</code> 的时候会调用它的构造方法，并在其中实例化一个<code>MessageQueue</code>，相比于 <code>Looper</code> 和<code>Handler</code>，<code>MessageQueue</code>就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 <code>native</code> 的方法。可以在 <a href="https://link.juejin.im/?target=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fframeworks%2Fbase%2F%2B%2Fmaster%2Fcore%2Fjni%2Fandroid_os_MessageQueue.cpp" target="_blank" rel="noopener">android_os_MessageQueue</a> 查看其源码的定义。更多参考<a href="https://juejin.im/post/5bdec872e51d4551ee2761cb#heading-6" target="_blank" rel="noopener">MessageQueue 的实例化</a></p><p>我们接着看<code>Handle</code>构造函数里的</p><blockquote><p>mQueue = mLooper.mQueue</p></blockquote><p>我们知道消息是存放在<code>MessageQueue</code>消息队列中的,而<code>MessageQueue</code>就是在上面<code>Looper</code>构造函数中new出来的，至此<code>Handler</code>通过<code>Looper</code>与<code>MessageQueue</code>也建立起了关联。</p><p>总结一下，创建<code>Handler</code>,他的构造函数中会先调用<code>Looper.myLooper()</code>获取Looper，也即是从<code>ThreadLocal</code>中获取，而<code>ThreadLocal</code>中要想获取到，要先调用<code>Looper.prepare()</code>来set值，那么问题又来了，我们写程序时好像没有手动调用<code>Looper.prepare()</code>吧，也不会抛出异常。其实这是一个特殊情况，我们通常都是在主线程，也就是UI线程中创建handler的。而在主线程中，系统已经为我们创建了一个<code>Looper</code>对象，所以不会抛出异常了,而那些会抛出异常报错的情况，是在子线程中创建的<code>Handler</code>，但是又没有调用<code>Looper.prepare()</code>去创建<code>Looper</code>对象。<br>继续看，主线程在什么时候创建了<code>Looper</code>对象吧。</p><p>在<code>ActivityThread</code>的main方法，这个方法是应用程序的入口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Looper.prepareMainLooper();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到第一行还是调用了<code>prepar(false）</code>方法的(false代表不可退出)。所以主线程是已经创建了一个<code>Looper</code>对象的。 </p><p><code>Handler</code>的创建过程分析完毕，现在总算搞明白了。</p><h3 id="Handler、MessageQueue-和-Looper-之间的关系"><a href="#Handler、MessageQueue-和-Looper-之间的关系" class="headerlink" title="Handler、MessageQueue 和 Looper 之间的关系"></a>Handler、MessageQueue 和 Looper 之间的关系</h3><p>最后再总结一下，<code>Handler</code>的创建是依赖于<code>Looper</code>的。而主线程是默认创建了一个<code>Looper</code>对象的。每一个<code>Looper</code>会关联一个线程（<code>ThreadLocal</code>中封装了<code>Looper</code>)。每一个<code>Looper</code>中又会封装一个消息队列。<br>这样一来，<code>Handler</code>，<code>Looper</code>，<code>MessageQueue</code>，<code>Thread</code>四个角色就关联了起来。<br><code>Handler</code>在主线程中创建，是因为要和主线程的消息队列关联起来，那样<code>Handler#handleMessage</code>方法才会在主线程中执行，那么这样在更新UI就是线程安全的了。</p><h2 id="Handler-发送消息过程"><a href="#Handler-发送消息过程" class="headerlink" title="Handler  发送消息过程"></a>Handler  发送消息过程</h2><p>回想开头我们基础用法里提到 <code>Handler</code>一般是通过一下2个方法发送的</p><blockquote><p>handler.sendMessage(message);<br>handler.post(runnable);</p></blockquote><h3 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h3><p>我们先从第一个开始分析 <strong>handler.sendMessage(message)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendMessage</code>会调用<code>sendMessageDelayed</code>方法并将<code>message</code>对象传进去，第二个参数是延时时间，使用<code>sendMessage</code>方法时默认为0的,最后都会调用<code>sendMessageAtTime</code>。<br>上面分析了，在创建<code>Looper</code>对象的时候，会创建一个<code>MessageQueue</code>，所以只要<code>Looper</code>是正常创建的话，消息队列是不为空的。<br>那么到最后一行的<code>enqueueMessage</code>方法，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>handler</code>本身赋值给<code>msg.target</code> 然后最终调用<code>queue.enqueueMessage</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//消息是否正在使用</span></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">//很明显enqueueMessage需要同步,因为存在多个线程往一个Loop线程的MessageQueue中插入消息的场景。 </span></span><br><span class="line">                <span class="comment">//这里其实是将Message根据延时插入到特定的地方，先看下关键点1，mMessages其实代表消息队列的头部，如果mMessages为空，说明还没有消息，如果当前插入的消息不需要延时，或者说延时比mMessages头消息的延时要小，那么当前要插入的消息就需要放在头部</span></span><br><span class="line">                <span class="comment">//至于是否需要唤醒队列，则需要根据当前的Loop线程的状态来判断，后面讲Loop线程的时候再回过头说；</span></span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//再来看下关键点2，这个时候需要将消息插入到队列中间，其实就是找到第一个Delay事件小于当前Message的非空Message，并插入到它的前面，往队列中插入消息时，如果Loop线程在睡眠，是不应该唤醒的，异步消息的处理会更加特殊一些，先不讨论。</span></span><br><span class="line">                <span class="comment">//最后看关键点3，如果需要唤醒Loop线程，通过nativeWake唤醒，以上，就是普通消息的插入。</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>Messagequeue</code>中有一个对象<code>mMessage</code>用于指向当前传进的<code>msg</code>，即最新的消息。而刚才的<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>方法，第二个参数指定了时间，然后在这里按照这个<code>uptimeMillis</code>来进行消息的排序，这样每一个消息都是按照时间的排序关联了起来，排在前面的消息指向了排在后面的消息。</p><p>以上是进入消息队列的分析，<code>Handler</code>调用<code>sendMessage</code>方法的最终将<code>message</code>对象传进<code>Messagequeue</code>。</p><h3 id="取出消息"><a href="#取出消息" class="headerlink" title="取出消息"></a>取出消息</h3><p>那么消息是怎么从消息队列出来的呢？<br>这时我们要回看<code>ActiviryThread</code>的main方法，去寻找点线索。源码在上面已贴出。<br>发现了倒数第二行的<code>Looper.loop()</code>，简单理解就是消息执行循环操作。<br><strong>android.os.Looper#loop</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保MessageQueue准备好</span></span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//for 无限循环，阻塞于消息队列的 next() 方法；</span></span><br><span class="line">            <span class="comment">//不断从队列中读取消息并移除，如果队列为空，阻塞等待</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block </span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;<span class="comment">//跳出循环，looper退出就是利用了这点</span></span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//清理，回收到缓存池</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loop方法是个死循环，但是为什么不会卡死主线程呢，参考</p><p><a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a> </p><p><a href="https://juejin.im/post/5c5694b951882562e5441e71" target="_blank" rel="noopener">Handler后传篇一: 为什么Looper中的Loop()方法不能导致主线程卡死?</a></p><p><a href="https://pqpo.me/2017/05/03/learn-messagequeue/" target="_blank" rel="noopener">深入理解 MessageQueue</a></p><p>loop内容有点复杂，借用一张图来看下</p><p><img src="/posts/20470e2e/loop.png" alt="Looper#loop"></p><p>当我们调用 <code>Looper#loop()</code> 方法之后整个 <code>Looper</code> 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 <code>MessageQueue#next()`</code> 方法来获取下一个消息的时候，会调用 nativePollOnce()<code>方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从</code>MessageQueuue<code>中取得一个消息之后给</code>Looper <code>进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的</code>Looper <code>的作用就是通过阻塞消息队列获取消息的过程阻塞</code> Looper`。</p><p>再看下关键的<code>Message msg = queue.next()</code>  深入分析参见<a href="https://juejin.im/post/59083d7fda2f60005d14efdb#heading-1" target="_blank" rel="noopener">MessageQueue中Message消息的执行</a>以及 <a href="https://juejin.im/post/5bdec872e51d4551ee2761cb#heading-10" target="_blank" rel="noopener">MessageQueue 的消息管理</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否需要阻塞等待，第一次一定不阻塞</span></span><br><span class="line">            <span class="comment">// 调用 Native 层的 nativePollOnce() 方法进行精准时间的阻塞。</span></span><br><span class="line">            <span class="comment">// 在 Native 层，将进入 pullInner() 方法，使用 epoll_wait 阻塞等待以读取管道的通知。</span></span><br><span class="line">            <span class="comment">// 如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//互斥同步</span></span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="comment">//是否存在barier</span></span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一个消息是否需要阻塞等待，并计算出阻塞等待时间</span></span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    <span class="comment">//需要无限等待</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="comment">//没有可以即刻执行的Message，查看是否存在需要处理的IdleHandler，如果不存在，则返回，阻塞等待，如果存在则执行IdleHandler</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="comment">// 如果目前没有消息，已经处在空闲状态，则执行 idler.queueIdle</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">            <span class="comment">//处理完IdleHandler ，需要重新判断Message队列 nextPollTimeoutMillis赋值为0</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面分析过<code>msg.target</code>就是<code>handler</code>，所以<code>loop</code>循环的时候又把消息取出扔给<code>handler#dispatchMessage</code>方法了，我们来看下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于这种方法没有传<code>callback</code>，所以最终调用<code>handleMessage</code>，我们来看下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，相信大家应该很熟悉了，这就是我们重写的方法。</p><p>我们再看看另一个发送消息的方法 <strong>handler.post(runnable)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收一个实现了<code>Runable</code>接口的对象，然后将其传进<code>getPostMessage()</code>方法。跟进<code>getPostMessage()</code>方法看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实就是将<code>Runable</code>包装成<code>message的callback</code>嘛。<br>所以，如果我们使用<code>post</code>方法发送消息，在执行<code>dispatchMessage</code>的时候,<code>callback</code>字段是不为空的，那么就会执行<code>handleCallback()</code>方法，而不是执行<code>handleMessage</code>方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们发现不管是使用<code>post</code>方法还是<code>sendMessage</code>方法来发送消息，最终都会调用<code>sendMessageDelayed</code>方法。<code>handler</code>将消息追加到消息队列中的过程都是一样的，然后<code>Looper</code>不断的从<code>MessageQueue</code>中取出消息，并由<code>handler</code>去分发消息，处理消息，这样就构成了完善的Android消息机制体系。</p><h2 id="Handler扩展"><a href="#Handler扩展" class="headerlink" title="Handler扩展"></a>Handler扩展</h2><p><code>Handler</code> 虽然简单易用，但是要用好它还是需要注意一点。</p><p>由于<code>Handler</code> 的特性，它在 Android 里的应用非常广泛，比如： <a href="https://lingdage.com/posts/96014b68.html">AsyncTask</a>、<a href="https://lingdage.com/posts/b4da2c1c.html">HandlerThread</a>、<a href="https://lingdage.com/posts/ccf7cf3d.html">Messenger</a>、IdleHandler 和 <a href="https://lingdage.com/posts/e4e64342.html">IntentService</a> 等等。</p><h3 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h3><p><code>Handler</code> 允许我们发送<strong>延时消息</strong>，如果在延时期间用户关闭了 <code>Activity</code>，那么该 <code>Activity</code>会泄露。</p><p>这个泄露是因为<code>Message</code>会持有<code>Handler</code>，而又因为 <strong>Java 的特性，内部类会持有外部类</strong>，使得 <code>Activity</code> 会被 <code>Handler</code>持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：<strong>将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息</strong>。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;HandlerActivity&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        HandlerActivity activity = ref.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且再在 <code>Activity.onDestroy()</code> 前移除消息，加一层保障：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  safeHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样双重保障，就能完全避免内存泄露了。</p><p><strong>注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。</strong></p><h3 id="Handler-里的-Callback-用处"><a href="#Handler-里的-Callback-用处" class="headerlink" title="Handler 里的 Callback 用处"></a>Handler 里的 Callback 用处</h3><p>在 <code>Handler</code> 的构造方法中有几个 要求传入 <code>Callback</code> ，那它是什么，又能做什么呢？</p><p>来看看 <code>Handler.dispatchMessage(msg)</code>  方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里的 callback 是 Runnable</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Handler.Callback</code> 有<strong>优先处理消息的权利</strong> ，当一条消息被 <code>Callback</code> 处理<strong>并拦截（返回 true）</strong>，那么 <code>Handler</code> 的 <code>handleMessage(msg)</code> 方法就不会被调用了；如果 <code>Callback</code>处理了消息，但是并没有拦截，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p>这个就很有意思了，这有什么作用呢？</p><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><p>场景：Hook <code>ActivityThread.mH</code> ， 在 <code>ActivityThread</code> 中有个成员变量 <code>mH</code> ，它是个 <code>Handler</code>，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h3 id="创建-Message-实例的最佳方式"><a href="#创建-Message-实例的最佳方式" class="headerlink" title="创建 Message 实例的最佳方式"></a>创建 Message 实例的最佳方式</h3><p>由于 <code>Handler</code> 极为常用，所以为了节省开销，Android 给 <code>Message</code> 设计了回收机制，所以我们在使用的时候尽量复用 <code>Message</code> ，减少内存消耗。</p><p>方法有二：</p><ol><li>通过 <code>Message</code> 的静态方法 <code>Message.obtain();</code>   获取；</li><li>通过 <code>Handler</code> 的公有方法 <code>handler.obtainMessage();</code> 。</li></ol><h3 id="妙用-Looper-机制"><a href="#妙用-Looper-机制" class="headerlink" title="妙用 Looper 机制"></a>妙用 Looper 机制</h3><p>我们可以利用 <code>Looper</code> 的机制来帮助我们做一些事情：</p><ul><li><p>将 <code>Runnable</code> post 到主线程执行</p><blockquote><p> Activity.runOnUiThread(Runnable)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>View.post(Runnable)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//直接通过handler发送Post消息</span></span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先加入队列,等attachInfo被赋值时,会通过handler发送消息.</span></span><br><span class="line">  getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>Looper</code> 判断当前线程是否是主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(@NonNull Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        HANDLER.post(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Looper-和-Handler-一定要处于一个线程吗？子线程中可以用-MainLooper-去创建-Handler吗？"><a href="#Looper-和-Handler-一定要处于一个线程吗？子线程中可以用-MainLooper-去创建-Handler吗？" class="headerlink" title="Looper 和 Handler 一定要处于一个线程吗？子线程中可以用 MainLooper 去创建 Handler吗？"></a>Looper 和 Handler 一定要处于一个线程吗？子线程中可以用 MainLooper 去创建 Handler吗？</h3><p><code>Looper</code> 和<code>Handler</code> 不需要再一个线程中，默认的情况下会从<code>ThreadLocal</code>中取当前线程对应的 <code>Looper</code>，但我们可以通过显式地指定一个 <code>Looper</code>的方式来创建<code>Handler</code>. 比如，当我们想要在子线程中发送消息到主线程中，那么我们可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure><h3 id="子线程中进行UI操作的方法"><a href="#子线程中进行UI操作的方法" class="headerlink" title="子线程中进行UI操作的方法"></a>子线程中进行UI操作的方法</h3><ul><li><p>Handler的post()方法</p></li><li><p>View的post()方法</p></li><li><p>Activity的runOnUiThread()方法</p></li></ul><h3 id="如何理解Handler的异步"><a href="#如何理解Handler的异步" class="headerlink" title="如何理解Handler的异步"></a>如何理解Handler的异步</h3><p>参见<a href="https://juejin.im/post/5c592dc9f265da2de04a91ec" target="_blank" rel="noopener">Handler后传篇二: 该如何理解Handler的”异步”？</a></p><h3 id="MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？-MessageQueue-next-方法内部的原理？"><a href="#MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？-MessageQueue-next-方法内部的原理？" class="headerlink" title="MessageQueue.next() 会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？  MessageQueue.next() 方法内部的原理？"></a>MessageQueue.next() 会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？  MessageQueue.next() 方法内部的原理？</h3><p>调用 <code>MessageQueue.next()</code> 方法的时候会调用 Native 层的 <code>nativePollOnce()</code> 方法进行精准时间的阻塞。在 Native 层，将进入 <code>pullInner()</code> 方法，使用 <code>epoll_wait</code> 阻塞等待以读取管道的通知。如果没有从 Native 层得到消息，那么这个方法就不会返回。此时主线程会释放 CPU 资源进入休眠状态。</p><p>当我们加入消息的时候，会调用 <code>MessageQueue.enqueueMessage()</code> 方法，添加完 Message 后，如果消息队列被阻塞，则会调用 Native 层的 <code>nativeWake()</code> 方法去唤醒。它通过向管道中写入一个消息，结束上述阻塞，触发上面提到的 <code>nativePollOnce()</code> 方法返回，好让加入的 Message 得到分发处理。</p><p><code>MessageQueue.enqueueMessage()</code> 使用 synchronized 代码块去进行同步。</p><p>资料：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.liangzl.com%2Fget-article-detail-14435.html" target="_blank" rel="noopener">Android 中的 Handler 的 Native 层研究</a></p><h3 id="Looper-的退出方法？"><a href="#Looper-的退出方法？" class="headerlink" title="Looper 的退出方法？"></a>Looper 的退出方法？</h3><blockquote><p>quit() 和 quitSafely() 有什么区别<br>子线程中创建了 Looper，在使用完毕后，终止消息循环的方法？<br>quit() 和 quitSafely() 的本质是什么？</p></blockquote><p><code>quit()</code> 和 <code>quitSafely()</code>的本质就是让消息队列的 <code>next()</code> 返回 <code>null</code>，以此来退出<code>Looper.loop()</code>。<br><code>quit()</code> 调用后直接终止 <code>Looper</code>，不在处理任何 <code>Message</code>，所有尝试把<code>Message</code> 放进消息队列的操作都会失败，比如 <code>Handler.sendMessage()</code> 会返回 false，但是存在不安全性，因为有可能有<code>Message</code> 还在消息队列中没来的及处理就终止<code>Looper</code>了。<br><code>quitSafely()</code> 调用后会在所有消息都处理后再终止 <code>Looper</code>，所有尝试把 <code>Message</code>放进消息队列的操作也都会失败。</p><h3 id="知识点汇总"><a href="#知识点汇总" class="headerlink" title="知识点汇总"></a>知识点汇总</h3><p>由前文可得出一些知识点，汇总一下，方便记忆。</p><ol><li><code>Handler</code> 的背后有 <code>Looper</code>、<code>MessageQueue</code> 支撑，<code>Looper</code> 负责消息分发，<code>MessageQueue</code> 负责消息管理</li><li>在创建 <code>Handler</code> 之前一定需要先创建<code>Looper</code></li><li><code>Looper</code> 有退出的功能，但是主线程的 <code>Looper</code> 不允许退出</li><li>异步线程的<code>Looper</code> 需要自己调用 <code>Looper.myLooper().quit();</code>  退出</li><li><code>Runnable</code>被封装进了 <code>Message</code>，可以说是一个特殊的 <code>Message</code></li><li><code>Handler.handleMessage()</code> 所在的线程是 <code>Looper.loop()</code> 方法被调用的线程，也可以说成<code>Looper</code>所在的线程，并不是创建 <code>Handler</code> 的线程</li><li>使用内部类的方式使用<code>Handler</code>可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/xyh269/article/details/52554712" target="_blank" rel="noopener">Android中的消息机制</a><br><a href="https://juejin.im/post/5c4fb8e9e51d4502723b1f68#heading-3" target="_blank" rel="noopener">Android点将台：烽火狼烟[-Handler-]</a><br><a href="https://juejin.im/post/5c74b64a6fb9a049be5e22fc" target="_blank" rel="noopener">Handler 都没搞懂，拿什么去跳槽啊？</a><br><a href="https://juejin.im/post/5c6a9a106fb9a04a0c2f0093" target="_blank" rel="noopener">Android 高级面试-1：Handler 相关</a><a href="https://juejin.im/post/5bdec872e51d4551ee2761cb" target="_blank" rel="noopener">Android 消息机制：Handler、MessageQueue 和 Looper</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文基于Android 9.0.0的源代码，来分析Handler的用法&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;framework/base/core/java/andorid/os/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - Handler.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - Looper.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - Message.java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - MessageQueue.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Handler作用&quot;&gt;&lt;a href=&quot;#Handler作用&quot; class=&quot;headerlink&quot; title=&quot;Handler作用&quot;&gt;&lt;/a&gt;Handler作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;任务调度：即通过 &lt;code&gt;post()&lt;/code&gt; 和 &lt;code&gt;send()&lt;/code&gt; 等方法来指定某个任务在某个时间执行&lt;/li&gt;
&lt;li&gt;线程切换：执行耗时的操作，比如网络请求，IO操作等，需要在子线程中运行，不然会阻塞主线程。&lt;br&gt;而执行完网络请求等耗时操作后通常需要更新UI，如果在子线程中更新UI，那么程序会崩溃。因为Android的UI是线程不安全的。 在Android中使用Rxjava，还要配合RxAndroid来使用，RxAndroid 内部就使用 Handler 来实现线程切换。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Handler" scheme="https://lingdage.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>how to read android framework source code in android studio</title>
    <link href="https://lingdage.com/posts/ca9841f5.html"/>
    <id>https://lingdage.com/posts/ca9841f5.html</id>
    <published>2019-02-28T05:25:24.000Z</published>
    <updated>2019-02-28T07:00:53.891Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录最快捷的将framework层源码导入android studio进行源码分析的方法</p><ul><li><p>获取framework源码，这里使用清华大学的<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">镜像</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/WorkSpace/AOSP</span><br><span class="line">cd ~/WorkSpace/AOSP</span><br><span class="line">git clone -b android-9.0.0_r1 https://aosp.tuna.tsinghua.edu.cn/platform/frameworks/base platform/frameworks/ --depth 1</span><br></pre></td></tr></table></figure></li><li><p>新建out文件夹 和 frameworks 同级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/WorkSpace/AOSP/platform/frameworks</span><br><span class="line">mkdir -p ./out/host/linux-x86/framework</span><br></pre></td></tr></table></figure></li><li><p>获取idegen.jar 并复制到 out/host/linux-x86/framework  下<br><a href="ca9841f5/idegen.jar">idegen.jar</a></p></li><li><p>获取idegen.sh </p><ul><li><p>clone development 到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://aosp.tuna.tsinghua.edu.cn/platform/development platform/development platform/</span><br><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure></li><li><p>或直接选择别人下好的idegen.sh<br><a href="ca9841f5/idegen.sh">idegen.sh</a><br>执行idegen.sh将会在～/WorkSpace/AOSP/platform/ 下生成android.iml 和 android.ipr 文件</p></li></ul></li><li>打开android studio 选择android.ipr 导入工程即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将记录最快捷的将framework层源码导入android studio进行源码分析的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取framework源码，这里使用清华大学的&lt;a href=&quot;https://mirror.tuna.tsinghua.edu.cn/help/
      
    
    </summary>
    
      <category term="技术随笔" scheme="https://lingdage.com/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="源码" scheme="https://lingdage.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="AOSP" scheme="https://lingdage.com/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>计划2019</title>
    <link href="https://lingdage.com/posts/397a8e26.html"/>
    <id>https://lingdage.com/posts/397a8e26.html</id>
    <published>2019-01-18T06:03:24.000Z</published>
    <updated>2019-03-21T10:32:14.481Z</updated>
    
    <content type="html"><![CDATA[<p> 　　2015年12月入职的，一直在这家公司，时光如白驹过隙，一晃3年就过去了，从来没有好好静下心来回头看看。今年结了婚，有了十一，压力一下子大了一个级别，生活也瞬间过得捉襟见肘的。3年过去，自己的能力明显没有达到自己的期望，在公司这3年，怎么说呢，虽然不说虚度，但至少没有自己想象的那么努力，技术上广度我自认为还是可以的，深度就不行了，杂而不精。</p><p><img src="/posts/397a8e26/01-big.jpg" alt="01"></p><p>　　希望今年不再碌碌无为，能有个质变。</p><a id="more"></a><hr><p>　　2019年要努力达成的目标 ： </p><ul><li style="list-style: none"><input type="checkbox"> 长10斤肉</li><li style="list-style: none"><input type="checkbox"> 早睡早起</li><li style="list-style: none"><input type="checkbox"> 每周至少运动2次</li><li style="list-style: none"><input type="checkbox"> 精读至少10本技术书</li><li style="list-style: none"><input type="checkbox"> 尽量阅读英文文档</li><li style="list-style: none"><input type="checkbox"> 产出至少10篇技术博客，3篇非技术博客</li><li style="list-style: none"><input type="checkbox"> 开源至少1个<a href="http://www.google.com/" target="_blank" rel="noopener">项目</a></li><li style="list-style: none"><input type="checkbox"> Android常见组件以及目前流行框架源码至少都过一遍</li><li style="list-style: none"><input type="checkbox"> 参加至少1次技术沙龙</li><li style="list-style: none"><input type="checkbox"> 有机会去北上广深杭感受下</li><li style="list-style: none"><input type="checkbox"> 学会Kotlin/Flutter 并投入生产</li><li style="list-style: none"><input type="checkbox"> 了解，并初步使用Go</li><li style="list-style: none"><input type="checkbox"> 简单学习一些shell编程</li><li style="list-style: none"><input type="checkbox"> 工资翻一番</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　　2015年12月入职的，一直在这家公司，时光如白驹过隙，一晃3年就过去了，从来没有好好静下心来回头看看。今年结了婚，有了十一，压力一下子大了一个级别，生活也瞬间过得捉襟见肘的。3年过去，自己的能力明显没有达到自己的期望，在公司这3年，怎么说呢，虽然不说虚度，但至少没有自己想象的那么努力，技术上广度我自认为还是可以的，深度就不行了，杂而不精。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/397a8e26/01-big.jpg&quot; alt=&quot;01&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　希望今年不再碌碌无为，能有个质变。&lt;/p&gt;
    
    </summary>
    
      <category term="生活随笔" scheme="https://lingdage.com/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活随笔" scheme="https://lingdage.com/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="计划" scheme="https://lingdage.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
</feed>
